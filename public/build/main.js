(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x + '" is not supported');
  });
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __reExport = (target, module, desc) => {
    if (module && typeof module === "object" || typeof module === "function") {
      for (let key of __getOwnPropNames(module))
        if (!__hasOwnProp.call(target, key) && key !== "default")
          __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
    }
    return target;
  };
  var __toModule = (module) => {
    return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
  };

  // node_modules/dompurify/dist/purify.js
  var require_purify = __commonJS({
    "node_modules/dompurify/dist/purify.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = global2 || self, global2.DOMPurify = factory());
      })(exports, function() {
        "use strict";
        function _toConsumableArray(arr) {
          if (Array.isArray(arr)) {
            for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
              arr2[i] = arr[i];
            }
            return arr2;
          } else {
            return Array.from(arr);
          }
        }
        var hasOwnProperty = Object.hasOwnProperty, setPrototypeOf = Object.setPrototypeOf, isFrozen = Object.isFrozen, getPrototypeOf = Object.getPrototypeOf, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
        var freeze = Object.freeze, seal = Object.seal, create = Object.create;
        var _ref = typeof Reflect !== "undefined" && Reflect, apply = _ref.apply, construct = _ref.construct;
        if (!apply) {
          apply = function apply2(fun, thisValue, args) {
            return fun.apply(thisValue, args);
          };
        }
        if (!freeze) {
          freeze = function freeze2(x) {
            return x;
          };
        }
        if (!seal) {
          seal = function seal2(x) {
            return x;
          };
        }
        if (!construct) {
          construct = function construct2(Func, args) {
            return new (Function.prototype.bind.apply(Func, [null].concat(_toConsumableArray(args))))();
          };
        }
        var arrayForEach = unapply(Array.prototype.forEach);
        var arrayPop = unapply(Array.prototype.pop);
        var arrayPush = unapply(Array.prototype.push);
        var stringToLowerCase = unapply(String.prototype.toLowerCase);
        var stringMatch = unapply(String.prototype.match);
        var stringReplace = unapply(String.prototype.replace);
        var stringIndexOf = unapply(String.prototype.indexOf);
        var stringTrim = unapply(String.prototype.trim);
        var regExpTest = unapply(RegExp.prototype.test);
        var typeErrorCreate = unconstruct(TypeError);
        function unapply(func) {
          return function(thisArg) {
            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            return apply(func, thisArg, args);
          };
        }
        function unconstruct(func) {
          return function() {
            for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2];
            }
            return construct(func, args);
          };
        }
        function addToSet(set, array) {
          if (setPrototypeOf) {
            setPrototypeOf(set, null);
          }
          var l = array.length;
          while (l--) {
            var element2 = array[l];
            if (typeof element2 === "string") {
              var lcElement = stringToLowerCase(element2);
              if (lcElement !== element2) {
                if (!isFrozen(array)) {
                  array[l] = lcElement;
                }
                element2 = lcElement;
              }
            }
            set[element2] = true;
          }
          return set;
        }
        function clone(object) {
          var newObject = create(null);
          var property = void 0;
          for (property in object) {
            if (apply(hasOwnProperty, object, [property])) {
              newObject[property] = object[property];
            }
          }
          return newObject;
        }
        function lookupGetter(object, prop) {
          while (object !== null) {
            var desc = getOwnPropertyDescriptor(object, prop);
            if (desc) {
              if (desc.get) {
                return unapply(desc.get);
              }
              if (typeof desc.value === "function") {
                return unapply(desc.value);
              }
            }
            object = getPrototypeOf(object);
          }
          function fallbackValue(element2) {
            console.warn("fallback value for", element2);
            return null;
          }
          return fallbackValue;
        }
        var html = freeze(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
        var svg = freeze(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
        var svgFilters = freeze(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
        var svgDisallowed = freeze(["animate", "color-profile", "cursor", "discard", "fedropshadow", "feimage", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
        var mathMl = freeze(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover"]);
        var mathMlDisallowed = freeze(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
        var text2 = freeze(["#text"]);
        var html$1 = freeze(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]);
        var svg$1 = freeze(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
        var mathMl$1 = freeze(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
        var xml = freeze(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
        var MUSTACHE_EXPR = seal(/\{\{[\s\S]*|[\s\S]*\}\}/gm);
        var ERB_EXPR = seal(/<%[\s\S]*|[\s\S]*%>/gm);
        var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/);
        var ARIA_ATTR = seal(/^aria-[\-\w]+$/);
        var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i);
        var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
        var ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g);
        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
          return typeof obj;
        } : function(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
        function _toConsumableArray$1(arr) {
          if (Array.isArray(arr)) {
            for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
              arr2[i] = arr[i];
            }
            return arr2;
          } else {
            return Array.from(arr);
          }
        }
        var getGlobal = function getGlobal2() {
          return typeof window === "undefined" ? null : window;
        };
        var _createTrustedTypesPolicy = function _createTrustedTypesPolicy2(trustedTypes, document2) {
          if ((typeof trustedTypes === "undefined" ? "undefined" : _typeof(trustedTypes)) !== "object" || typeof trustedTypes.createPolicy !== "function") {
            return null;
          }
          var suffix = null;
          var ATTR_NAME = "data-tt-policy-suffix";
          if (document2.currentScript && document2.currentScript.hasAttribute(ATTR_NAME)) {
            suffix = document2.currentScript.getAttribute(ATTR_NAME);
          }
          var policyName = "dompurify" + (suffix ? "#" + suffix : "");
          try {
            return trustedTypes.createPolicy(policyName, {
              createHTML: function createHTML(html$$1) {
                return html$$1;
              }
            });
          } catch (_) {
            console.warn("TrustedTypes policy " + policyName + " could not be created.");
            return null;
          }
        };
        function createDOMPurify() {
          var window2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
          var DOMPurify2 = function DOMPurify3(root) {
            return createDOMPurify(root);
          };
          DOMPurify2.version = "2.3.1";
          DOMPurify2.removed = [];
          if (!window2 || !window2.document || window2.document.nodeType !== 9) {
            DOMPurify2.isSupported = false;
            return DOMPurify2;
          }
          var originalDocument = window2.document;
          var document2 = window2.document;
          var DocumentFragment = window2.DocumentFragment, HTMLTemplateElement = window2.HTMLTemplateElement, Node = window2.Node, Element = window2.Element, NodeFilter = window2.NodeFilter, _window$NamedNodeMap = window2.NamedNodeMap, NamedNodeMap = _window$NamedNodeMap === void 0 ? window2.NamedNodeMap || window2.MozNamedAttrMap : _window$NamedNodeMap, Text = window2.Text, Comment = window2.Comment, DOMParser = window2.DOMParser, trustedTypes = window2.trustedTypes;
          var ElementPrototype = Element.prototype;
          var cloneNode = lookupGetter(ElementPrototype, "cloneNode");
          var getNextSibling = lookupGetter(ElementPrototype, "nextSibling");
          var getChildNodes = lookupGetter(ElementPrototype, "childNodes");
          var getParentNode = lookupGetter(ElementPrototype, "parentNode");
          if (typeof HTMLTemplateElement === "function") {
            var template = document2.createElement("template");
            if (template.content && template.content.ownerDocument) {
              document2 = template.content.ownerDocument;
            }
          }
          var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);
          var emptyHTML = trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML("") : "";
          var _document = document2, implementation = _document.implementation, createNodeIterator = _document.createNodeIterator, createDocumentFragment = _document.createDocumentFragment, getElementsByTagName = _document.getElementsByTagName;
          var importNode = originalDocument.importNode;
          var documentMode = {};
          try {
            documentMode = clone(document2).documentMode ? document2.documentMode : {};
          } catch (_) {
          }
          var hooks = {};
          DOMPurify2.isSupported = typeof getParentNode === "function" && implementation && typeof implementation.createHTMLDocument !== "undefined" && documentMode !== 9;
          var MUSTACHE_EXPR$$1 = MUSTACHE_EXPR, ERB_EXPR$$1 = ERB_EXPR, DATA_ATTR$$1 = DATA_ATTR, ARIA_ATTR$$1 = ARIA_ATTR, IS_SCRIPT_OR_DATA$$1 = IS_SCRIPT_OR_DATA, ATTR_WHITESPACE$$1 = ATTR_WHITESPACE;
          var IS_ALLOWED_URI$$1 = IS_ALLOWED_URI;
          var ALLOWED_TAGS = null;
          var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(html), _toConsumableArray$1(svg), _toConsumableArray$1(svgFilters), _toConsumableArray$1(mathMl), _toConsumableArray$1(text2)));
          var ALLOWED_ATTR = null;
          var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray$1(html$1), _toConsumableArray$1(svg$1), _toConsumableArray$1(mathMl$1), _toConsumableArray$1(xml)));
          var FORBID_TAGS = null;
          var FORBID_ATTR = null;
          var ALLOW_ARIA_ATTR = true;
          var ALLOW_DATA_ATTR = true;
          var ALLOW_UNKNOWN_PROTOCOLS = false;
          var SAFE_FOR_TEMPLATES = false;
          var WHOLE_DOCUMENT = false;
          var SET_CONFIG = false;
          var FORCE_BODY = false;
          var RETURN_DOM = false;
          var RETURN_DOM_FRAGMENT = false;
          var RETURN_DOM_IMPORT = true;
          var RETURN_TRUSTED_TYPE = false;
          var SANITIZE_DOM = true;
          var KEEP_CONTENT = true;
          var IN_PLACE = false;
          var USE_PROFILES = {};
          var FORBID_CONTENTS = null;
          var DEFAULT_FORBID_CONTENTS = addToSet({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
          var DATA_URI_TAGS = null;
          var DEFAULT_DATA_URI_TAGS = addToSet({}, ["audio", "video", "img", "source", "image", "track"]);
          var URI_SAFE_ATTRIBUTES = null;
          var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]);
          var MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
          var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
          var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
          var NAMESPACE = HTML_NAMESPACE;
          var IS_EMPTY_INPUT = false;
          var CONFIG = null;
          var formElement = document2.createElement("form");
          var _parseConfig = function _parseConfig2(cfg) {
            if (CONFIG && CONFIG === cfg) {
              return;
            }
            if (!cfg || (typeof cfg === "undefined" ? "undefined" : _typeof(cfg)) !== "object") {
              cfg = {};
            }
            cfg = clone(cfg);
            ALLOWED_TAGS = "ALLOWED_TAGS" in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;
            ALLOWED_ATTR = "ALLOWED_ATTR" in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;
            URI_SAFE_ATTRIBUTES = "ADD_URI_SAFE_ATTR" in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;
            DATA_URI_TAGS = "ADD_DATA_URI_TAGS" in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS) : DEFAULT_DATA_URI_TAGS;
            FORBID_CONTENTS = "FORBID_CONTENTS" in cfg ? addToSet({}, cfg.FORBID_CONTENTS) : DEFAULT_FORBID_CONTENTS;
            FORBID_TAGS = "FORBID_TAGS" in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};
            FORBID_ATTR = "FORBID_ATTR" in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};
            USE_PROFILES = "USE_PROFILES" in cfg ? cfg.USE_PROFILES : false;
            ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
            ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
            ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
            SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
            WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
            RETURN_DOM = cfg.RETURN_DOM || false;
            RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
            RETURN_DOM_IMPORT = cfg.RETURN_DOM_IMPORT !== false;
            RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
            FORCE_BODY = cfg.FORCE_BODY || false;
            SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
            KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
            IN_PLACE = cfg.IN_PLACE || false;
            IS_ALLOWED_URI$$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$$1;
            NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
            if (SAFE_FOR_TEMPLATES) {
              ALLOW_DATA_ATTR = false;
            }
            if (RETURN_DOM_FRAGMENT) {
              RETURN_DOM = true;
            }
            if (USE_PROFILES) {
              ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(text2)));
              ALLOWED_ATTR = [];
              if (USE_PROFILES.html === true) {
                addToSet(ALLOWED_TAGS, html);
                addToSet(ALLOWED_ATTR, html$1);
              }
              if (USE_PROFILES.svg === true) {
                addToSet(ALLOWED_TAGS, svg);
                addToSet(ALLOWED_ATTR, svg$1);
                addToSet(ALLOWED_ATTR, xml);
              }
              if (USE_PROFILES.svgFilters === true) {
                addToSet(ALLOWED_TAGS, svgFilters);
                addToSet(ALLOWED_ATTR, svg$1);
                addToSet(ALLOWED_ATTR, xml);
              }
              if (USE_PROFILES.mathMl === true) {
                addToSet(ALLOWED_TAGS, mathMl);
                addToSet(ALLOWED_ATTR, mathMl$1);
                addToSet(ALLOWED_ATTR, xml);
              }
            }
            if (cfg.ADD_TAGS) {
              if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
                ALLOWED_TAGS = clone(ALLOWED_TAGS);
              }
              addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);
            }
            if (cfg.ADD_ATTR) {
              if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
                ALLOWED_ATTR = clone(ALLOWED_ATTR);
              }
              addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);
            }
            if (cfg.ADD_URI_SAFE_ATTR) {
              addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);
            }
            if (cfg.FORBID_CONTENTS) {
              if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
                FORBID_CONTENTS = clone(FORBID_CONTENTS);
              }
              addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS);
            }
            if (KEEP_CONTENT) {
              ALLOWED_TAGS["#text"] = true;
            }
            if (WHOLE_DOCUMENT) {
              addToSet(ALLOWED_TAGS, ["html", "head", "body"]);
            }
            if (ALLOWED_TAGS.table) {
              addToSet(ALLOWED_TAGS, ["tbody"]);
              delete FORBID_TAGS.tbody;
            }
            if (freeze) {
              freeze(cfg);
            }
            CONFIG = cfg;
          };
          var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ["mi", "mo", "mn", "ms", "mtext"]);
          var HTML_INTEGRATION_POINTS = addToSet({}, ["foreignobject", "desc", "title", "annotation-xml"]);
          var ALL_SVG_TAGS = addToSet({}, svg);
          addToSet(ALL_SVG_TAGS, svgFilters);
          addToSet(ALL_SVG_TAGS, svgDisallowed);
          var ALL_MATHML_TAGS = addToSet({}, mathMl);
          addToSet(ALL_MATHML_TAGS, mathMlDisallowed);
          var _checkValidNamespace = function _checkValidNamespace2(element2) {
            var parent = getParentNode(element2);
            if (!parent || !parent.tagName) {
              parent = {
                namespaceURI: HTML_NAMESPACE,
                tagName: "template"
              };
            }
            var tagName = stringToLowerCase(element2.tagName);
            var parentTagName = stringToLowerCase(parent.tagName);
            if (element2.namespaceURI === SVG_NAMESPACE) {
              if (parent.namespaceURI === HTML_NAMESPACE) {
                return tagName === "svg";
              }
              if (parent.namespaceURI === MATHML_NAMESPACE) {
                return tagName === "svg" && (parentTagName === "annotation-xml" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
              }
              return Boolean(ALL_SVG_TAGS[tagName]);
            }
            if (element2.namespaceURI === MATHML_NAMESPACE) {
              if (parent.namespaceURI === HTML_NAMESPACE) {
                return tagName === "math";
              }
              if (parent.namespaceURI === SVG_NAMESPACE) {
                return tagName === "math" && HTML_INTEGRATION_POINTS[parentTagName];
              }
              return Boolean(ALL_MATHML_TAGS[tagName]);
            }
            if (element2.namespaceURI === HTML_NAMESPACE) {
              if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
                return false;
              }
              if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
                return false;
              }
              var commonSvgAndHTMLElements = addToSet({}, ["title", "style", "font", "a", "script"]);
              return !ALL_MATHML_TAGS[tagName] && (commonSvgAndHTMLElements[tagName] || !ALL_SVG_TAGS[tagName]);
            }
            return false;
          };
          var _forceRemove = function _forceRemove2(node) {
            arrayPush(DOMPurify2.removed, { element: node });
            try {
              node.parentNode.removeChild(node);
            } catch (_) {
              try {
                node.outerHTML = emptyHTML;
              } catch (_2) {
                node.remove();
              }
            }
          };
          var _removeAttribute = function _removeAttribute2(name, node) {
            try {
              arrayPush(DOMPurify2.removed, {
                attribute: node.getAttributeNode(name),
                from: node
              });
            } catch (_) {
              arrayPush(DOMPurify2.removed, {
                attribute: null,
                from: node
              });
            }
            node.removeAttribute(name);
            if (name === "is" && !ALLOWED_ATTR[name]) {
              if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
                try {
                  _forceRemove(node);
                } catch (_) {
                }
              } else {
                try {
                  node.setAttribute(name, "");
                } catch (_) {
                }
              }
            }
          };
          var _initDocument = function _initDocument2(dirty) {
            var doc2 = void 0;
            var leadingWhitespace = void 0;
            if (FORCE_BODY) {
              dirty = "<remove></remove>" + dirty;
            } else {
              var matches = stringMatch(dirty, /^[\r\n\t ]+/);
              leadingWhitespace = matches && matches[0];
            }
            var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
            if (NAMESPACE === HTML_NAMESPACE) {
              try {
                doc2 = new DOMParser().parseFromString(dirtyPayload, "text/html");
              } catch (_) {
              }
            }
            if (!doc2 || !doc2.documentElement) {
              doc2 = implementation.createDocument(NAMESPACE, "template", null);
              try {
                doc2.documentElement.innerHTML = IS_EMPTY_INPUT ? "" : dirtyPayload;
              } catch (_) {
              }
            }
            var body = doc2.body || doc2.documentElement;
            if (dirty && leadingWhitespace) {
              body.insertBefore(document2.createTextNode(leadingWhitespace), body.childNodes[0] || null);
            }
            if (NAMESPACE === HTML_NAMESPACE) {
              return getElementsByTagName.call(doc2, WHOLE_DOCUMENT ? "html" : "body")[0];
            }
            return WHOLE_DOCUMENT ? doc2.documentElement : body;
          };
          var _createIterator = function _createIterator2(root) {
            return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);
          };
          var _isClobbered = function _isClobbered2(elm) {
            if (elm instanceof Text || elm instanceof Comment) {
              return false;
            }
            if (typeof elm.nodeName !== "string" || typeof elm.textContent !== "string" || typeof elm.removeChild !== "function" || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== "function" || typeof elm.setAttribute !== "function" || typeof elm.namespaceURI !== "string" || typeof elm.insertBefore !== "function") {
              return true;
            }
            return false;
          };
          var _isNode = function _isNode2(object) {
            return (typeof Node === "undefined" ? "undefined" : _typeof(Node)) === "object" ? object instanceof Node : object && (typeof object === "undefined" ? "undefined" : _typeof(object)) === "object" && typeof object.nodeType === "number" && typeof object.nodeName === "string";
          };
          var _executeHook = function _executeHook2(entryPoint, currentNode, data) {
            if (!hooks[entryPoint]) {
              return;
            }
            arrayForEach(hooks[entryPoint], function(hook) {
              hook.call(DOMPurify2, currentNode, data, CONFIG);
            });
          };
          var _sanitizeElements = function _sanitizeElements2(currentNode) {
            var content = void 0;
            _executeHook("beforeSanitizeElements", currentNode, null);
            if (_isClobbered(currentNode)) {
              _forceRemove(currentNode);
              return true;
            }
            if (stringMatch(currentNode.nodeName, /[\u0080-\uFFFF]/)) {
              _forceRemove(currentNode);
              return true;
            }
            var tagName = stringToLowerCase(currentNode.nodeName);
            _executeHook("uponSanitizeElement", currentNode, {
              tagName,
              allowedTags: ALLOWED_TAGS
            });
            if (!_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
              _forceRemove(currentNode);
              return true;
            }
            if (tagName === "select" && regExpTest(/<template/i, currentNode.innerHTML)) {
              _forceRemove(currentNode);
              return true;
            }
            if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
              if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
                var parentNode = getParentNode(currentNode) || currentNode.parentNode;
                var childNodes = getChildNodes(currentNode) || currentNode.childNodes;
                if (childNodes && parentNode) {
                  var childCount = childNodes.length;
                  for (var i = childCount - 1; i >= 0; --i) {
                    parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));
                  }
                }
              }
              _forceRemove(currentNode);
              return true;
            }
            if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
              _forceRemove(currentNode);
              return true;
            }
            if ((tagName === "noscript" || tagName === "noembed") && regExpTest(/<\/no(script|embed)/i, currentNode.innerHTML)) {
              _forceRemove(currentNode);
              return true;
            }
            if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
              content = currentNode.textContent;
              content = stringReplace(content, MUSTACHE_EXPR$$1, " ");
              content = stringReplace(content, ERB_EXPR$$1, " ");
              if (currentNode.textContent !== content) {
                arrayPush(DOMPurify2.removed, { element: currentNode.cloneNode() });
                currentNode.textContent = content;
              }
            }
            _executeHook("afterSanitizeElements", currentNode, null);
            return false;
          };
          var _isValidAttribute = function _isValidAttribute2(lcTag, lcName, value) {
            if (SANITIZE_DOM && (lcName === "id" || lcName === "name") && (value in document2 || value in formElement)) {
              return false;
            }
            if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$$1, lcName))
              ;
            else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$$1, lcName))
              ;
            else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
              return false;
            } else if (URI_SAFE_ATTRIBUTES[lcName])
              ;
            else if (regExpTest(IS_ALLOWED_URI$$1, stringReplace(value, ATTR_WHITESPACE$$1, "")))
              ;
            else if ((lcName === "src" || lcName === "xlink:href" || lcName === "href") && lcTag !== "script" && stringIndexOf(value, "data:") === 0 && DATA_URI_TAGS[lcTag])
              ;
            else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$$1, stringReplace(value, ATTR_WHITESPACE$$1, "")))
              ;
            else if (!value)
              ;
            else {
              return false;
            }
            return true;
          };
          var _sanitizeAttributes = function _sanitizeAttributes2(currentNode) {
            var attr2 = void 0;
            var value = void 0;
            var lcName = void 0;
            var l = void 0;
            _executeHook("beforeSanitizeAttributes", currentNode, null);
            var attributes = currentNode.attributes;
            if (!attributes) {
              return;
            }
            var hookEvent = {
              attrName: "",
              attrValue: "",
              keepAttr: true,
              allowedAttributes: ALLOWED_ATTR
            };
            l = attributes.length;
            while (l--) {
              attr2 = attributes[l];
              var _attr = attr2, name = _attr.name, namespaceURI = _attr.namespaceURI;
              value = stringTrim(attr2.value);
              lcName = stringToLowerCase(name);
              hookEvent.attrName = lcName;
              hookEvent.attrValue = value;
              hookEvent.keepAttr = true;
              hookEvent.forceKeepAttr = void 0;
              _executeHook("uponSanitizeAttribute", currentNode, hookEvent);
              value = hookEvent.attrValue;
              if (hookEvent.forceKeepAttr) {
                continue;
              }
              _removeAttribute(name, currentNode);
              if (!hookEvent.keepAttr) {
                continue;
              }
              if (regExpTest(/\/>/i, value)) {
                _removeAttribute(name, currentNode);
                continue;
              }
              if (SAFE_FOR_TEMPLATES) {
                value = stringReplace(value, MUSTACHE_EXPR$$1, " ");
                value = stringReplace(value, ERB_EXPR$$1, " ");
              }
              var lcTag = currentNode.nodeName.toLowerCase();
              if (!_isValidAttribute(lcTag, lcName, value)) {
                continue;
              }
              try {
                if (namespaceURI) {
                  currentNode.setAttributeNS(namespaceURI, name, value);
                } else {
                  currentNode.setAttribute(name, value);
                }
                arrayPop(DOMPurify2.removed);
              } catch (_) {
              }
            }
            _executeHook("afterSanitizeAttributes", currentNode, null);
          };
          var _sanitizeShadowDOM = function _sanitizeShadowDOM2(fragment) {
            var shadowNode = void 0;
            var shadowIterator = _createIterator(fragment);
            _executeHook("beforeSanitizeShadowDOM", fragment, null);
            while (shadowNode = shadowIterator.nextNode()) {
              _executeHook("uponSanitizeShadowNode", shadowNode, null);
              if (_sanitizeElements(shadowNode)) {
                continue;
              }
              if (shadowNode.content instanceof DocumentFragment) {
                _sanitizeShadowDOM2(shadowNode.content);
              }
              _sanitizeAttributes(shadowNode);
            }
            _executeHook("afterSanitizeShadowDOM", fragment, null);
          };
          DOMPurify2.sanitize = function(dirty, cfg) {
            var body = void 0;
            var importedNode = void 0;
            var currentNode = void 0;
            var oldNode = void 0;
            var returnNode = void 0;
            IS_EMPTY_INPUT = !dirty;
            if (IS_EMPTY_INPUT) {
              dirty = "<!-->";
            }
            if (typeof dirty !== "string" && !_isNode(dirty)) {
              if (typeof dirty.toString !== "function") {
                throw typeErrorCreate("toString is not a function");
              } else {
                dirty = dirty.toString();
                if (typeof dirty !== "string") {
                  throw typeErrorCreate("dirty is not a string, aborting");
                }
              }
            }
            if (!DOMPurify2.isSupported) {
              if (_typeof(window2.toStaticHTML) === "object" || typeof window2.toStaticHTML === "function") {
                if (typeof dirty === "string") {
                  return window2.toStaticHTML(dirty);
                }
                if (_isNode(dirty)) {
                  return window2.toStaticHTML(dirty.outerHTML);
                }
              }
              return dirty;
            }
            if (!SET_CONFIG) {
              _parseConfig(cfg);
            }
            DOMPurify2.removed = [];
            if (typeof dirty === "string") {
              IN_PLACE = false;
            }
            if (IN_PLACE)
              ;
            else if (dirty instanceof Node) {
              body = _initDocument("<!---->");
              importedNode = body.ownerDocument.importNode(dirty, true);
              if (importedNode.nodeType === 1 && importedNode.nodeName === "BODY") {
                body = importedNode;
              } else if (importedNode.nodeName === "HTML") {
                body = importedNode;
              } else {
                body.appendChild(importedNode);
              }
            } else {
              if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && dirty.indexOf("<") === -1) {
                return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
              }
              body = _initDocument(dirty);
              if (!body) {
                return RETURN_DOM ? null : emptyHTML;
              }
            }
            if (body && FORCE_BODY) {
              _forceRemove(body.firstChild);
            }
            var nodeIterator = _createIterator(IN_PLACE ? dirty : body);
            while (currentNode = nodeIterator.nextNode()) {
              if (currentNode.nodeType === 3 && currentNode === oldNode) {
                continue;
              }
              if (_sanitizeElements(currentNode)) {
                continue;
              }
              if (currentNode.content instanceof DocumentFragment) {
                _sanitizeShadowDOM(currentNode.content);
              }
              _sanitizeAttributes(currentNode);
              oldNode = currentNode;
            }
            oldNode = null;
            if (IN_PLACE) {
              return dirty;
            }
            if (RETURN_DOM) {
              if (RETURN_DOM_FRAGMENT) {
                returnNode = createDocumentFragment.call(body.ownerDocument);
                while (body.firstChild) {
                  returnNode.appendChild(body.firstChild);
                }
              } else {
                returnNode = body;
              }
              if (RETURN_DOM_IMPORT) {
                returnNode = importNode.call(originalDocument, returnNode, true);
              }
              return returnNode;
            }
            var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
            if (SAFE_FOR_TEMPLATES) {
              serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$$1, " ");
              serializedHTML = stringReplace(serializedHTML, ERB_EXPR$$1, " ");
            }
            return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
          };
          DOMPurify2.setConfig = function(cfg) {
            _parseConfig(cfg);
            SET_CONFIG = true;
          };
          DOMPurify2.clearConfig = function() {
            CONFIG = null;
            SET_CONFIG = false;
          };
          DOMPurify2.isValidAttribute = function(tag, attr2, value) {
            if (!CONFIG) {
              _parseConfig({});
            }
            var lcTag = stringToLowerCase(tag);
            var lcName = stringToLowerCase(attr2);
            return _isValidAttribute(lcTag, lcName, value);
          };
          DOMPurify2.addHook = function(entryPoint, hookFunction) {
            if (typeof hookFunction !== "function") {
              return;
            }
            hooks[entryPoint] = hooks[entryPoint] || [];
            arrayPush(hooks[entryPoint], hookFunction);
          };
          DOMPurify2.removeHook = function(entryPoint) {
            if (hooks[entryPoint]) {
              arrayPop(hooks[entryPoint]);
            }
          };
          DOMPurify2.removeHooks = function(entryPoint) {
            if (hooks[entryPoint]) {
              hooks[entryPoint] = [];
            }
          };
          DOMPurify2.removeAllHooks = function() {
            hooks = {};
          };
          return DOMPurify2;
        }
        var purify = createDOMPurify();
        return purify;
      });
    }
  });

  // node_modules/@mozilla/readability/Readability.js
  var require_Readability = __commonJS({
    "node_modules/@mozilla/readability/Readability.js"(exports, module) {
      function Readability2(doc2, options) {
        if (options && options.documentElement) {
          doc2 = options;
          options = arguments[2];
        } else if (!doc2 || !doc2.documentElement) {
          throw new Error("First argument to Readability constructor should be a document object.");
        }
        options = options || {};
        this._doc = doc2;
        this._docJSDOMParser = this._doc.firstChild.__JSDOMParser__;
        this._articleTitle = null;
        this._articleByline = null;
        this._articleDir = null;
        this._articleSiteName = null;
        this._attempts = [];
        this._debug = !!options.debug;
        this._maxElemsToParse = options.maxElemsToParse || this.DEFAULT_MAX_ELEMS_TO_PARSE;
        this._nbTopCandidates = options.nbTopCandidates || this.DEFAULT_N_TOP_CANDIDATES;
        this._charThreshold = options.charThreshold || this.DEFAULT_CHAR_THRESHOLD;
        this._classesToPreserve = this.CLASSES_TO_PRESERVE.concat(options.classesToPreserve || []);
        this._keepClasses = !!options.keepClasses;
        this._serializer = options.serializer || function(el) {
          return el.innerHTML;
        };
        this._disableJSONLD = !!options.disableJSONLD;
        this._flags = this.FLAG_STRIP_UNLIKELYS | this.FLAG_WEIGHT_CLASSES | this.FLAG_CLEAN_CONDITIONALLY;
        if (this._debug) {
          let logNode = function(node) {
            if (node.nodeType == node.TEXT_NODE) {
              return `${node.nodeName} ("${node.textContent}")`;
            }
            let attrPairs = Array.from(node.attributes || [], function(attr2) {
              return `${attr2.name}="${attr2.value}"`;
            }).join(" ");
            return `<${node.localName} ${attrPairs}>`;
          };
          this.log = function() {
            if (typeof dump !== "undefined") {
              var msg = Array.prototype.map.call(arguments, function(x) {
                return x && x.nodeName ? logNode(x) : x;
              }).join(" ");
              dump("Reader: (Readability) " + msg + "\n");
            } else if (typeof console !== "undefined") {
              let args = Array.from(arguments, (arg) => {
                if (arg && arg.nodeType == this.ELEMENT_NODE) {
                  return logNode(arg);
                }
                return arg;
              });
              args.unshift("Reader: (Readability)");
              console.log.apply(console, args);
            }
          };
        } else {
          this.log = function() {
          };
        }
      }
      Readability2.prototype = {
        FLAG_STRIP_UNLIKELYS: 1,
        FLAG_WEIGHT_CLASSES: 2,
        FLAG_CLEAN_CONDITIONALLY: 4,
        ELEMENT_NODE: 1,
        TEXT_NODE: 3,
        DEFAULT_MAX_ELEMS_TO_PARSE: 0,
        DEFAULT_N_TOP_CANDIDATES: 5,
        DEFAULT_TAGS_TO_SCORE: "section,h2,h3,h4,h5,h6,p,td,pre".toUpperCase().split(","),
        DEFAULT_CHAR_THRESHOLD: 500,
        REGEXPS: {
          unlikelyCandidates: /-ad-|ai2html|banner|breadcrumbs|combx|comment|community|cover-wrap|disqus|extra|footer|gdpr|header|legends|menu|related|remark|replies|rss|shoutbox|sidebar|skyscraper|social|sponsor|supplemental|ad-break|agegate|pagination|pager|popup|yom-remote/i,
          okMaybeItsACandidate: /and|article|body|column|content|main|shadow/i,
          positive: /article|body|content|entry|hentry|h-entry|main|page|pagination|post|text|blog|story/i,
          negative: /-ad-|hidden|^hid$| hid$| hid |^hid |banner|combx|comment|com-|contact|foot|footer|footnote|gdpr|masthead|media|meta|outbrain|promo|related|scroll|share|shoutbox|sidebar|skyscraper|sponsor|shopping|tags|tool|widget/i,
          extraneous: /print|archive|comment|discuss|e[\-]?mail|share|reply|all|login|sign|single|utility/i,
          byline: /byline|author|dateline|writtenby|p-author/i,
          replaceFonts: /<(\/?)font[^>]*>/gi,
          normalize: /\s{2,}/g,
          videos: /\/\/(www\.)?((dailymotion|youtube|youtube-nocookie|player\.vimeo|v\.qq)\.com|(archive|upload\.wikimedia)\.org|player\.twitch\.tv)/i,
          shareElements: /(\b|_)(share|sharedaddy)(\b|_)/i,
          nextLink: /(next|weiter|continue|>([^\|]|$)|»([^\|]|$))/i,
          prevLink: /(prev|earl|old|new|<|«)/i,
          tokenize: /\W+/g,
          whitespace: /^\s*$/,
          hasContent: /\S$/,
          hashUrl: /^#.+/,
          srcsetUrl: /(\S+)(\s+[\d.]+[xw])?(\s*(?:,|$))/g,
          b64DataUrl: /^data:\s*([^\s;,]+)\s*;\s*base64\s*,/i,
          jsonLdArticleTypes: /^Article|AdvertiserContentArticle|NewsArticle|AnalysisNewsArticle|AskPublicNewsArticle|BackgroundNewsArticle|OpinionNewsArticle|ReportageNewsArticle|ReviewNewsArticle|Report|SatiricalArticle|ScholarlyArticle|MedicalScholarlyArticle|SocialMediaPosting|BlogPosting|LiveBlogPosting|DiscussionForumPosting|TechArticle|APIReference$/
        },
        UNLIKELY_ROLES: ["menu", "menubar", "complementary", "navigation", "alert", "alertdialog", "dialog"],
        DIV_TO_P_ELEMS: new Set(["BLOCKQUOTE", "DL", "DIV", "IMG", "OL", "P", "PRE", "TABLE", "UL"]),
        ALTER_TO_DIV_EXCEPTIONS: ["DIV", "ARTICLE", "SECTION", "P"],
        PRESENTATIONAL_ATTRIBUTES: ["align", "background", "bgcolor", "border", "cellpadding", "cellspacing", "frame", "hspace", "rules", "style", "valign", "vspace"],
        DEPRECATED_SIZE_ATTRIBUTE_ELEMS: ["TABLE", "TH", "TD", "HR", "PRE"],
        PHRASING_ELEMS: [
          "ABBR",
          "AUDIO",
          "B",
          "BDO",
          "BR",
          "BUTTON",
          "CITE",
          "CODE",
          "DATA",
          "DATALIST",
          "DFN",
          "EM",
          "EMBED",
          "I",
          "IMG",
          "INPUT",
          "KBD",
          "LABEL",
          "MARK",
          "MATH",
          "METER",
          "NOSCRIPT",
          "OBJECT",
          "OUTPUT",
          "PROGRESS",
          "Q",
          "RUBY",
          "SAMP",
          "SCRIPT",
          "SELECT",
          "SMALL",
          "SPAN",
          "STRONG",
          "SUB",
          "SUP",
          "TEXTAREA",
          "TIME",
          "VAR",
          "WBR"
        ],
        CLASSES_TO_PRESERVE: ["page"],
        HTML_ESCAPE_MAP: {
          "lt": "<",
          "gt": ">",
          "amp": "&",
          "quot": '"',
          "apos": "'"
        },
        _postProcessContent: function(articleContent) {
          this._fixRelativeUris(articleContent);
          this._simplifyNestedElements(articleContent);
          if (!this._keepClasses) {
            this._cleanClasses(articleContent);
          }
        },
        _removeNodes: function(nodeList, filterFn) {
          if (this._docJSDOMParser && nodeList._isLiveNodeList) {
            throw new Error("Do not pass live node lists to _removeNodes");
          }
          for (var i = nodeList.length - 1; i >= 0; i--) {
            var node = nodeList[i];
            var parentNode = node.parentNode;
            if (parentNode) {
              if (!filterFn || filterFn.call(this, node, i, nodeList)) {
                parentNode.removeChild(node);
              }
            }
          }
        },
        _replaceNodeTags: function(nodeList, newTagName) {
          if (this._docJSDOMParser && nodeList._isLiveNodeList) {
            throw new Error("Do not pass live node lists to _replaceNodeTags");
          }
          for (const node of nodeList) {
            this._setNodeTag(node, newTagName);
          }
        },
        _forEachNode: function(nodeList, fn) {
          Array.prototype.forEach.call(nodeList, fn, this);
        },
        _findNode: function(nodeList, fn) {
          return Array.prototype.find.call(nodeList, fn, this);
        },
        _someNode: function(nodeList, fn) {
          return Array.prototype.some.call(nodeList, fn, this);
        },
        _everyNode: function(nodeList, fn) {
          return Array.prototype.every.call(nodeList, fn, this);
        },
        _concatNodeLists: function() {
          var slice = Array.prototype.slice;
          var args = slice.call(arguments);
          var nodeLists = args.map(function(list) {
            return slice.call(list);
          });
          return Array.prototype.concat.apply([], nodeLists);
        },
        _getAllNodesWithTag: function(node, tagNames) {
          if (node.querySelectorAll) {
            return node.querySelectorAll(tagNames.join(","));
          }
          return [].concat.apply([], tagNames.map(function(tag) {
            var collection = node.getElementsByTagName(tag);
            return Array.isArray(collection) ? collection : Array.from(collection);
          }));
        },
        _cleanClasses: function(node) {
          var classesToPreserve = this._classesToPreserve;
          var className = (node.getAttribute("class") || "").split(/\s+/).filter(function(cls) {
            return classesToPreserve.indexOf(cls) != -1;
          }).join(" ");
          if (className) {
            node.setAttribute("class", className);
          } else {
            node.removeAttribute("class");
          }
          for (node = node.firstElementChild; node; node = node.nextElementSibling) {
            this._cleanClasses(node);
          }
        },
        _fixRelativeUris: function(articleContent) {
          var baseURI = this._doc.baseURI;
          var documentURI = this._doc.documentURI;
          function toAbsoluteURI(uri) {
            if (baseURI == documentURI && uri.charAt(0) == "#") {
              return uri;
            }
            try {
              return new URL(uri, baseURI).href;
            } catch (ex) {
            }
            return uri;
          }
          var links = this._getAllNodesWithTag(articleContent, ["a"]);
          this._forEachNode(links, function(link) {
            var href = link.getAttribute("href");
            if (href) {
              if (href.indexOf("javascript:") === 0) {
                if (link.childNodes.length === 1 && link.childNodes[0].nodeType === this.TEXT_NODE) {
                  var text2 = this._doc.createTextNode(link.textContent);
                  link.parentNode.replaceChild(text2, link);
                } else {
                  var container = this._doc.createElement("span");
                  while (link.childNodes.length > 0) {
                    container.appendChild(link.childNodes[0]);
                  }
                  link.parentNode.replaceChild(container, link);
                }
              } else {
                link.setAttribute("href", toAbsoluteURI(href));
              }
            }
          });
          var medias = this._getAllNodesWithTag(articleContent, [
            "img",
            "picture",
            "figure",
            "video",
            "audio",
            "source"
          ]);
          this._forEachNode(medias, function(media) {
            var src = media.getAttribute("src");
            var poster = media.getAttribute("poster");
            var srcset = media.getAttribute("srcset");
            if (src) {
              media.setAttribute("src", toAbsoluteURI(src));
            }
            if (poster) {
              media.setAttribute("poster", toAbsoluteURI(poster));
            }
            if (srcset) {
              var newSrcset = srcset.replace(this.REGEXPS.srcsetUrl, function(_, p1, p2, p3) {
                return toAbsoluteURI(p1) + (p2 || "") + p3;
              });
              media.setAttribute("srcset", newSrcset);
            }
          });
        },
        _simplifyNestedElements: function(articleContent) {
          var node = articleContent;
          while (node) {
            if (node.parentNode && ["DIV", "SECTION"].includes(node.tagName) && !(node.id && node.id.startsWith("readability"))) {
              if (this._isElementWithoutContent(node)) {
                node = this._removeAndGetNext(node);
                continue;
              } else if (this._hasSingleTagInsideElement(node, "DIV") || this._hasSingleTagInsideElement(node, "SECTION")) {
                var child = node.children[0];
                for (var i = 0; i < node.attributes.length; i++) {
                  child.setAttribute(node.attributes[i].name, node.attributes[i].value);
                }
                node.parentNode.replaceChild(child, node);
                node = child;
                continue;
              }
            }
            node = this._getNextNode(node);
          }
        },
        _getArticleTitle: function() {
          var doc2 = this._doc;
          var curTitle = "";
          var origTitle = "";
          try {
            curTitle = origTitle = doc2.title.trim();
            if (typeof curTitle !== "string")
              curTitle = origTitle = this._getInnerText(doc2.getElementsByTagName("title")[0]);
          } catch (e) {
          }
          var titleHadHierarchicalSeparators = false;
          function wordCount(str) {
            return str.split(/\s+/).length;
          }
          if (/ [\|\-\\\/>»] /.test(curTitle)) {
            titleHadHierarchicalSeparators = / [\\\/>»] /.test(curTitle);
            curTitle = origTitle.replace(/(.*)[\|\-\\\/>»] .*/gi, "$1");
            if (wordCount(curTitle) < 3)
              curTitle = origTitle.replace(/[^\|\-\\\/>»]*[\|\-\\\/>»](.*)/gi, "$1");
          } else if (curTitle.indexOf(": ") !== -1) {
            var headings = this._concatNodeLists(doc2.getElementsByTagName("h1"), doc2.getElementsByTagName("h2"));
            var trimmedTitle = curTitle.trim();
            var match = this._someNode(headings, function(heading) {
              return heading.textContent.trim() === trimmedTitle;
            });
            if (!match) {
              curTitle = origTitle.substring(origTitle.lastIndexOf(":") + 1);
              if (wordCount(curTitle) < 3) {
                curTitle = origTitle.substring(origTitle.indexOf(":") + 1);
              } else if (wordCount(origTitle.substr(0, origTitle.indexOf(":"))) > 5) {
                curTitle = origTitle;
              }
            }
          } else if (curTitle.length > 150 || curTitle.length < 15) {
            var hOnes = doc2.getElementsByTagName("h1");
            if (hOnes.length === 1)
              curTitle = this._getInnerText(hOnes[0]);
          }
          curTitle = curTitle.trim().replace(this.REGEXPS.normalize, " ");
          var curTitleWordCount = wordCount(curTitle);
          if (curTitleWordCount <= 4 && (!titleHadHierarchicalSeparators || curTitleWordCount != wordCount(origTitle.replace(/[\|\-\\\/>»]+/g, "")) - 1)) {
            curTitle = origTitle;
          }
          return curTitle;
        },
        _prepDocument: function() {
          var doc2 = this._doc;
          this._removeNodes(this._getAllNodesWithTag(doc2, ["style"]));
          if (doc2.body) {
            this._replaceBrs(doc2.body);
          }
          this._replaceNodeTags(this._getAllNodesWithTag(doc2, ["font"]), "SPAN");
        },
        _nextNode: function(node) {
          var next = node;
          while (next && next.nodeType != this.ELEMENT_NODE && this.REGEXPS.whitespace.test(next.textContent)) {
            next = next.nextSibling;
          }
          return next;
        },
        _replaceBrs: function(elem) {
          this._forEachNode(this._getAllNodesWithTag(elem, ["br"]), function(br) {
            var next = br.nextSibling;
            var replaced = false;
            while ((next = this._nextNode(next)) && next.tagName == "BR") {
              replaced = true;
              var brSibling = next.nextSibling;
              next.parentNode.removeChild(next);
              next = brSibling;
            }
            if (replaced) {
              var p = this._doc.createElement("p");
              br.parentNode.replaceChild(p, br);
              next = p.nextSibling;
              while (next) {
                if (next.tagName == "BR") {
                  var nextElem = this._nextNode(next.nextSibling);
                  if (nextElem && nextElem.tagName == "BR")
                    break;
                }
                if (!this._isPhrasingContent(next))
                  break;
                var sibling = next.nextSibling;
                p.appendChild(next);
                next = sibling;
              }
              while (p.lastChild && this._isWhitespace(p.lastChild)) {
                p.removeChild(p.lastChild);
              }
              if (p.parentNode.tagName === "P")
                this._setNodeTag(p.parentNode, "DIV");
            }
          });
        },
        _setNodeTag: function(node, tag) {
          this.log("_setNodeTag", node, tag);
          if (this._docJSDOMParser) {
            node.localName = tag.toLowerCase();
            node.tagName = tag.toUpperCase();
            return node;
          }
          var replacement = node.ownerDocument.createElement(tag);
          while (node.firstChild) {
            replacement.appendChild(node.firstChild);
          }
          node.parentNode.replaceChild(replacement, node);
          if (node.readability)
            replacement.readability = node.readability;
          for (var i = 0; i < node.attributes.length; i++) {
            try {
              replacement.setAttribute(node.attributes[i].name, node.attributes[i].value);
            } catch (ex) {
            }
          }
          return replacement;
        },
        _prepArticle: function(articleContent) {
          this._cleanStyles(articleContent);
          this._markDataTables(articleContent);
          this._fixLazyImages(articleContent);
          this._cleanConditionally(articleContent, "form");
          this._cleanConditionally(articleContent, "fieldset");
          this._clean(articleContent, "object");
          this._clean(articleContent, "embed");
          this._clean(articleContent, "footer");
          this._clean(articleContent, "link");
          this._clean(articleContent, "aside");
          var shareElementThreshold = this.DEFAULT_CHAR_THRESHOLD;
          this._forEachNode(articleContent.children, function(topCandidate) {
            this._cleanMatchedNodes(topCandidate, function(node, matchString) {
              return this.REGEXPS.shareElements.test(matchString) && node.textContent.length < shareElementThreshold;
            });
          });
          this._clean(articleContent, "iframe");
          this._clean(articleContent, "input");
          this._clean(articleContent, "textarea");
          this._clean(articleContent, "select");
          this._clean(articleContent, "button");
          this._cleanHeaders(articleContent);
          this._cleanConditionally(articleContent, "table");
          this._cleanConditionally(articleContent, "ul");
          this._cleanConditionally(articleContent, "div");
          this._replaceNodeTags(this._getAllNodesWithTag(articleContent, ["h1"]), "h2");
          this._removeNodes(this._getAllNodesWithTag(articleContent, ["p"]), function(paragraph) {
            var imgCount = paragraph.getElementsByTagName("img").length;
            var embedCount = paragraph.getElementsByTagName("embed").length;
            var objectCount = paragraph.getElementsByTagName("object").length;
            var iframeCount = paragraph.getElementsByTagName("iframe").length;
            var totalCount = imgCount + embedCount + objectCount + iframeCount;
            return totalCount === 0 && !this._getInnerText(paragraph, false);
          });
          this._forEachNode(this._getAllNodesWithTag(articleContent, ["br"]), function(br) {
            var next = this._nextNode(br.nextSibling);
            if (next && next.tagName == "P")
              br.parentNode.removeChild(br);
          });
          this._forEachNode(this._getAllNodesWithTag(articleContent, ["table"]), function(table) {
            var tbody = this._hasSingleTagInsideElement(table, "TBODY") ? table.firstElementChild : table;
            if (this._hasSingleTagInsideElement(tbody, "TR")) {
              var row = tbody.firstElementChild;
              if (this._hasSingleTagInsideElement(row, "TD")) {
                var cell = row.firstElementChild;
                cell = this._setNodeTag(cell, this._everyNode(cell.childNodes, this._isPhrasingContent) ? "P" : "DIV");
                table.parentNode.replaceChild(cell, table);
              }
            }
          });
        },
        _initializeNode: function(node) {
          node.readability = { "contentScore": 0 };
          switch (node.tagName) {
            case "DIV":
              node.readability.contentScore += 5;
              break;
            case "PRE":
            case "TD":
            case "BLOCKQUOTE":
              node.readability.contentScore += 3;
              break;
            case "ADDRESS":
            case "OL":
            case "UL":
            case "DL":
            case "DD":
            case "DT":
            case "LI":
            case "FORM":
              node.readability.contentScore -= 3;
              break;
            case "H1":
            case "H2":
            case "H3":
            case "H4":
            case "H5":
            case "H6":
            case "TH":
              node.readability.contentScore -= 5;
              break;
          }
          node.readability.contentScore += this._getClassWeight(node);
        },
        _removeAndGetNext: function(node) {
          var nextNode = this._getNextNode(node, true);
          node.parentNode.removeChild(node);
          return nextNode;
        },
        _getNextNode: function(node, ignoreSelfAndKids) {
          if (!ignoreSelfAndKids && node.firstElementChild) {
            return node.firstElementChild;
          }
          if (node.nextElementSibling) {
            return node.nextElementSibling;
          }
          do {
            node = node.parentNode;
          } while (node && !node.nextElementSibling);
          return node && node.nextElementSibling;
        },
        _textSimilarity: function(textA, textB) {
          var tokensA = textA.toLowerCase().split(this.REGEXPS.tokenize).filter(Boolean);
          var tokensB = textB.toLowerCase().split(this.REGEXPS.tokenize).filter(Boolean);
          if (!tokensA.length || !tokensB.length) {
            return 0;
          }
          var uniqTokensB = tokensB.filter((token2) => !tokensA.includes(token2));
          var distanceB = uniqTokensB.join(" ").length / tokensB.join(" ").length;
          return 1 - distanceB;
        },
        _checkByline: function(node, matchString) {
          if (this._articleByline) {
            return false;
          }
          if (node.getAttribute !== void 0) {
            var rel = node.getAttribute("rel");
            var itemprop = node.getAttribute("itemprop");
          }
          if ((rel === "author" || itemprop && itemprop.indexOf("author") !== -1 || this.REGEXPS.byline.test(matchString)) && this._isValidByline(node.textContent)) {
            this._articleByline = node.textContent.trim();
            return true;
          }
          return false;
        },
        _getNodeAncestors: function(node, maxDepth) {
          maxDepth = maxDepth || 0;
          var i = 0, ancestors = [];
          while (node.parentNode) {
            ancestors.push(node.parentNode);
            if (maxDepth && ++i === maxDepth)
              break;
            node = node.parentNode;
          }
          return ancestors;
        },
        _grabArticle: function(page) {
          this.log("**** grabArticle ****");
          var doc2 = this._doc;
          var isPaging = page !== null;
          page = page ? page : this._doc.body;
          if (!page) {
            this.log("No body found in document. Abort.");
            return null;
          }
          var pageCacheHtml = page.innerHTML;
          while (true) {
            this.log("Starting grabArticle loop");
            var stripUnlikelyCandidates = this._flagIsActive(this.FLAG_STRIP_UNLIKELYS);
            var elementsToScore = [];
            var node = this._doc.documentElement;
            let shouldRemoveTitleHeader = true;
            while (node) {
              var matchString = node.className + " " + node.id;
              if (!this._isProbablyVisible(node)) {
                this.log("Removing hidden node - " + matchString);
                node = this._removeAndGetNext(node);
                continue;
              }
              if (this._checkByline(node, matchString)) {
                node = this._removeAndGetNext(node);
                continue;
              }
              if (shouldRemoveTitleHeader && this._headerDuplicatesTitle(node)) {
                this.log("Removing header: ", node.textContent.trim(), this._articleTitle.trim());
                shouldRemoveTitleHeader = false;
                node = this._removeAndGetNext(node);
                continue;
              }
              if (stripUnlikelyCandidates) {
                if (this.REGEXPS.unlikelyCandidates.test(matchString) && !this.REGEXPS.okMaybeItsACandidate.test(matchString) && !this._hasAncestorTag(node, "table") && !this._hasAncestorTag(node, "code") && node.tagName !== "BODY" && node.tagName !== "A") {
                  this.log("Removing unlikely candidate - " + matchString);
                  node = this._removeAndGetNext(node);
                  continue;
                }
                if (this.UNLIKELY_ROLES.includes(node.getAttribute("role"))) {
                  this.log("Removing content with role " + node.getAttribute("role") + " - " + matchString);
                  node = this._removeAndGetNext(node);
                  continue;
                }
              }
              if ((node.tagName === "DIV" || node.tagName === "SECTION" || node.tagName === "HEADER" || node.tagName === "H1" || node.tagName === "H2" || node.tagName === "H3" || node.tagName === "H4" || node.tagName === "H5" || node.tagName === "H6") && this._isElementWithoutContent(node)) {
                node = this._removeAndGetNext(node);
                continue;
              }
              if (this.DEFAULT_TAGS_TO_SCORE.indexOf(node.tagName) !== -1) {
                elementsToScore.push(node);
              }
              if (node.tagName === "DIV") {
                var p = null;
                var childNode = node.firstChild;
                while (childNode) {
                  var nextSibling = childNode.nextSibling;
                  if (this._isPhrasingContent(childNode)) {
                    if (p !== null) {
                      p.appendChild(childNode);
                    } else if (!this._isWhitespace(childNode)) {
                      p = doc2.createElement("p");
                      node.replaceChild(p, childNode);
                      p.appendChild(childNode);
                    }
                  } else if (p !== null) {
                    while (p.lastChild && this._isWhitespace(p.lastChild)) {
                      p.removeChild(p.lastChild);
                    }
                    p = null;
                  }
                  childNode = nextSibling;
                }
                if (this._hasSingleTagInsideElement(node, "P") && this._getLinkDensity(node) < 0.25) {
                  var newNode = node.children[0];
                  node.parentNode.replaceChild(newNode, node);
                  node = newNode;
                  elementsToScore.push(node);
                } else if (!this._hasChildBlockElement(node)) {
                  node = this._setNodeTag(node, "P");
                  elementsToScore.push(node);
                }
              }
              node = this._getNextNode(node);
            }
            var candidates = [];
            this._forEachNode(elementsToScore, function(elementToScore) {
              if (!elementToScore.parentNode || typeof elementToScore.parentNode.tagName === "undefined")
                return;
              var innerText = this._getInnerText(elementToScore);
              if (innerText.length < 25)
                return;
              var ancestors2 = this._getNodeAncestors(elementToScore, 5);
              if (ancestors2.length === 0)
                return;
              var contentScore = 0;
              contentScore += 1;
              contentScore += innerText.split(",").length;
              contentScore += Math.min(Math.floor(innerText.length / 100), 3);
              this._forEachNode(ancestors2, function(ancestor, level) {
                if (!ancestor.tagName || !ancestor.parentNode || typeof ancestor.parentNode.tagName === "undefined")
                  return;
                if (typeof ancestor.readability === "undefined") {
                  this._initializeNode(ancestor);
                  candidates.push(ancestor);
                }
                if (level === 0)
                  var scoreDivider = 1;
                else if (level === 1)
                  scoreDivider = 2;
                else
                  scoreDivider = level * 3;
                ancestor.readability.contentScore += contentScore / scoreDivider;
              });
            });
            var topCandidates = [];
            for (var c = 0, cl = candidates.length; c < cl; c += 1) {
              var candidate = candidates[c];
              var candidateScore = candidate.readability.contentScore * (1 - this._getLinkDensity(candidate));
              candidate.readability.contentScore = candidateScore;
              this.log("Candidate:", candidate, "with score " + candidateScore);
              for (var t = 0; t < this._nbTopCandidates; t++) {
                var aTopCandidate = topCandidates[t];
                if (!aTopCandidate || candidateScore > aTopCandidate.readability.contentScore) {
                  topCandidates.splice(t, 0, candidate);
                  if (topCandidates.length > this._nbTopCandidates)
                    topCandidates.pop();
                  break;
                }
              }
            }
            var topCandidate = topCandidates[0] || null;
            var neededToCreateTopCandidate = false;
            var parentOfTopCandidate;
            if (topCandidate === null || topCandidate.tagName === "BODY") {
              topCandidate = doc2.createElement("DIV");
              neededToCreateTopCandidate = true;
              var kids = page.childNodes;
              while (kids.length) {
                this.log("Moving child out:", kids[0]);
                topCandidate.appendChild(kids[0]);
              }
              page.appendChild(topCandidate);
              this._initializeNode(topCandidate);
            } else if (topCandidate) {
              var alternativeCandidateAncestors = [];
              for (var i = 1; i < topCandidates.length; i++) {
                if (topCandidates[i].readability.contentScore / topCandidate.readability.contentScore >= 0.75) {
                  alternativeCandidateAncestors.push(this._getNodeAncestors(topCandidates[i]));
                }
              }
              var MINIMUM_TOPCANDIDATES = 3;
              if (alternativeCandidateAncestors.length >= MINIMUM_TOPCANDIDATES) {
                parentOfTopCandidate = topCandidate.parentNode;
                while (parentOfTopCandidate.tagName !== "BODY") {
                  var listsContainingThisAncestor = 0;
                  for (var ancestorIndex = 0; ancestorIndex < alternativeCandidateAncestors.length && listsContainingThisAncestor < MINIMUM_TOPCANDIDATES; ancestorIndex++) {
                    listsContainingThisAncestor += Number(alternativeCandidateAncestors[ancestorIndex].includes(parentOfTopCandidate));
                  }
                  if (listsContainingThisAncestor >= MINIMUM_TOPCANDIDATES) {
                    topCandidate = parentOfTopCandidate;
                    break;
                  }
                  parentOfTopCandidate = parentOfTopCandidate.parentNode;
                }
              }
              if (!topCandidate.readability) {
                this._initializeNode(topCandidate);
              }
              parentOfTopCandidate = topCandidate.parentNode;
              var lastScore = topCandidate.readability.contentScore;
              var scoreThreshold = lastScore / 3;
              while (parentOfTopCandidate.tagName !== "BODY") {
                if (!parentOfTopCandidate.readability) {
                  parentOfTopCandidate = parentOfTopCandidate.parentNode;
                  continue;
                }
                var parentScore = parentOfTopCandidate.readability.contentScore;
                if (parentScore < scoreThreshold)
                  break;
                if (parentScore > lastScore) {
                  topCandidate = parentOfTopCandidate;
                  break;
                }
                lastScore = parentOfTopCandidate.readability.contentScore;
                parentOfTopCandidate = parentOfTopCandidate.parentNode;
              }
              parentOfTopCandidate = topCandidate.parentNode;
              while (parentOfTopCandidate.tagName != "BODY" && parentOfTopCandidate.children.length == 1) {
                topCandidate = parentOfTopCandidate;
                parentOfTopCandidate = topCandidate.parentNode;
              }
              if (!topCandidate.readability) {
                this._initializeNode(topCandidate);
              }
            }
            var articleContent = doc2.createElement("DIV");
            if (isPaging)
              articleContent.id = "readability-content";
            var siblingScoreThreshold = Math.max(10, topCandidate.readability.contentScore * 0.2);
            parentOfTopCandidate = topCandidate.parentNode;
            var siblings = parentOfTopCandidate.children;
            for (var s = 0, sl = siblings.length; s < sl; s++) {
              var sibling = siblings[s];
              var append2 = false;
              this.log("Looking at sibling node:", sibling, sibling.readability ? "with score " + sibling.readability.contentScore : "");
              this.log("Sibling has score", sibling.readability ? sibling.readability.contentScore : "Unknown");
              if (sibling === topCandidate) {
                append2 = true;
              } else {
                var contentBonus = 0;
                if (sibling.className === topCandidate.className && topCandidate.className !== "")
                  contentBonus += topCandidate.readability.contentScore * 0.2;
                if (sibling.readability && sibling.readability.contentScore + contentBonus >= siblingScoreThreshold) {
                  append2 = true;
                } else if (sibling.nodeName === "P") {
                  var linkDensity = this._getLinkDensity(sibling);
                  var nodeContent = this._getInnerText(sibling);
                  var nodeLength = nodeContent.length;
                  if (nodeLength > 80 && linkDensity < 0.25) {
                    append2 = true;
                  } else if (nodeLength < 80 && nodeLength > 0 && linkDensity === 0 && nodeContent.search(/\.( |$)/) !== -1) {
                    append2 = true;
                  }
                }
              }
              if (append2) {
                this.log("Appending node:", sibling);
                if (this.ALTER_TO_DIV_EXCEPTIONS.indexOf(sibling.nodeName) === -1) {
                  this.log("Altering sibling:", sibling, "to div.");
                  sibling = this._setNodeTag(sibling, "DIV");
                }
                articleContent.appendChild(sibling);
                s -= 1;
                sl -= 1;
              }
            }
            if (this._debug)
              this.log("Article content pre-prep: " + articleContent.innerHTML);
            this._prepArticle(articleContent);
            if (this._debug)
              this.log("Article content post-prep: " + articleContent.innerHTML);
            if (neededToCreateTopCandidate) {
              topCandidate.id = "readability-page-1";
              topCandidate.className = "page";
            } else {
              var div = doc2.createElement("DIV");
              div.id = "readability-page-1";
              div.className = "page";
              var children2 = articleContent.childNodes;
              while (children2.length) {
                div.appendChild(children2[0]);
              }
              articleContent.appendChild(div);
            }
            if (this._debug)
              this.log("Article content after paging: " + articleContent.innerHTML);
            var parseSuccessful = true;
            var textLength = this._getInnerText(articleContent, true).length;
            if (textLength < this._charThreshold) {
              parseSuccessful = false;
              page.innerHTML = pageCacheHtml;
              if (this._flagIsActive(this.FLAG_STRIP_UNLIKELYS)) {
                this._removeFlag(this.FLAG_STRIP_UNLIKELYS);
                this._attempts.push({ articleContent, textLength });
              } else if (this._flagIsActive(this.FLAG_WEIGHT_CLASSES)) {
                this._removeFlag(this.FLAG_WEIGHT_CLASSES);
                this._attempts.push({ articleContent, textLength });
              } else if (this._flagIsActive(this.FLAG_CLEAN_CONDITIONALLY)) {
                this._removeFlag(this.FLAG_CLEAN_CONDITIONALLY);
                this._attempts.push({ articleContent, textLength });
              } else {
                this._attempts.push({ articleContent, textLength });
                this._attempts.sort(function(a, b) {
                  return b.textLength - a.textLength;
                });
                if (!this._attempts[0].textLength) {
                  return null;
                }
                articleContent = this._attempts[0].articleContent;
                parseSuccessful = true;
              }
            }
            if (parseSuccessful) {
              var ancestors = [parentOfTopCandidate, topCandidate].concat(this._getNodeAncestors(parentOfTopCandidate));
              this._someNode(ancestors, function(ancestor) {
                if (!ancestor.tagName)
                  return false;
                var articleDir = ancestor.getAttribute("dir");
                if (articleDir) {
                  this._articleDir = articleDir;
                  return true;
                }
                return false;
              });
              return articleContent;
            }
          }
        },
        _isValidByline: function(byline) {
          if (typeof byline == "string" || byline instanceof String) {
            byline = byline.trim();
            return byline.length > 0 && byline.length < 100;
          }
          return false;
        },
        _unescapeHtmlEntities: function(str) {
          if (!str) {
            return str;
          }
          var htmlEscapeMap = this.HTML_ESCAPE_MAP;
          return str.replace(/&(quot|amp|apos|lt|gt);/g, function(_, tag) {
            return htmlEscapeMap[tag];
          }).replace(/&#(?:x([0-9a-z]{1,4})|([0-9]{1,4}));/gi, function(_, hex, numStr) {
            var num = parseInt(hex || numStr, hex ? 16 : 10);
            return String.fromCharCode(num);
          });
        },
        _getJSONLD: function(doc2) {
          var scripts = this._getAllNodesWithTag(doc2, ["script"]);
          var jsonLdElement = this._findNode(scripts, function(el) {
            return el.getAttribute("type") === "application/ld+json";
          });
          if (jsonLdElement) {
            try {
              var content = jsonLdElement.textContent.replace(/^\s*<!\[CDATA\[|\]\]>\s*$/g, "");
              var parsed = JSON.parse(content);
              var metadata = {};
              if (!parsed["@context"] || !parsed["@context"].match(/^https?\:\/\/schema\.org$/)) {
                return metadata;
              }
              if (!parsed["@type"] && Array.isArray(parsed["@graph"])) {
                parsed = parsed["@graph"].find(function(it) {
                  return (it["@type"] || "").match(this.REGEXPS.jsonLdArticleTypes);
                });
              }
              if (!parsed || !parsed["@type"] || !parsed["@type"].match(this.REGEXPS.jsonLdArticleTypes)) {
                return metadata;
              }
              if (typeof parsed.name === "string") {
                metadata.title = parsed.name.trim();
              } else if (typeof parsed.headline === "string") {
                metadata.title = parsed.headline.trim();
              }
              if (parsed.author) {
                if (typeof parsed.author.name === "string") {
                  metadata.byline = parsed.author.name.trim();
                } else if (Array.isArray(parsed.author) && parsed.author[0] && typeof parsed.author[0].name === "string") {
                  metadata.byline = parsed.author.filter(function(author) {
                    return author && typeof author.name === "string";
                  }).map(function(author) {
                    return author.name.trim();
                  }).join(", ");
                }
              }
              if (typeof parsed.description === "string") {
                metadata.excerpt = parsed.description.trim();
              }
              if (parsed.publisher && typeof parsed.publisher.name === "string") {
                metadata.siteName = parsed.publisher.name.trim();
              }
              return metadata;
            } catch (err) {
              this.log(err.message);
            }
          }
          return {};
        },
        _getArticleMetadata: function(jsonld) {
          var metadata = {};
          var values = {};
          var metaElements = this._doc.getElementsByTagName("meta");
          var propertyPattern = /\s*(dc|dcterm|og|twitter)\s*:\s*(author|creator|description|title|site_name)\s*/gi;
          var namePattern = /^\s*(?:(dc|dcterm|og|twitter|weibo:(article|webpage))\s*[\.:]\s*)?(author|creator|description|title|site_name)\s*$/i;
          this._forEachNode(metaElements, function(element2) {
            var elementName = element2.getAttribute("name");
            var elementProperty = element2.getAttribute("property");
            var content = element2.getAttribute("content");
            if (!content) {
              return;
            }
            var matches = null;
            var name = null;
            if (elementProperty) {
              matches = elementProperty.match(propertyPattern);
              if (matches) {
                name = matches[0].toLowerCase().replace(/\s/g, "");
                values[name] = content.trim();
              }
            }
            if (!matches && elementName && namePattern.test(elementName)) {
              name = elementName;
              if (content) {
                name = name.toLowerCase().replace(/\s/g, "").replace(/\./g, ":");
                values[name] = content.trim();
              }
            }
          });
          metadata.title = jsonld.title || values["dc:title"] || values["dcterm:title"] || values["og:title"] || values["weibo:article:title"] || values["weibo:webpage:title"] || values["title"] || values["twitter:title"];
          if (!metadata.title) {
            metadata.title = this._getArticleTitle();
          }
          metadata.byline = jsonld.byline || values["dc:creator"] || values["dcterm:creator"] || values["author"];
          metadata.excerpt = jsonld.excerpt || values["dc:description"] || values["dcterm:description"] || values["og:description"] || values["weibo:article:description"] || values["weibo:webpage:description"] || values["description"] || values["twitter:description"];
          metadata.siteName = jsonld.siteName || values["og:site_name"];
          metadata.title = this._unescapeHtmlEntities(metadata.title);
          metadata.byline = this._unescapeHtmlEntities(metadata.byline);
          metadata.excerpt = this._unescapeHtmlEntities(metadata.excerpt);
          metadata.siteName = this._unescapeHtmlEntities(metadata.siteName);
          return metadata;
        },
        _isSingleImage: function(node) {
          if (node.tagName === "IMG") {
            return true;
          }
          if (node.children.length !== 1 || node.textContent.trim() !== "") {
            return false;
          }
          return this._isSingleImage(node.children[0]);
        },
        _unwrapNoscriptImages: function(doc2) {
          var imgs = Array.from(doc2.getElementsByTagName("img"));
          this._forEachNode(imgs, function(img) {
            for (var i = 0; i < img.attributes.length; i++) {
              var attr2 = img.attributes[i];
              switch (attr2.name) {
                case "src":
                case "srcset":
                case "data-src":
                case "data-srcset":
                  return;
              }
              if (/\.(jpg|jpeg|png|webp)/i.test(attr2.value)) {
                return;
              }
            }
            img.parentNode.removeChild(img);
          });
          var noscripts = Array.from(doc2.getElementsByTagName("noscript"));
          this._forEachNode(noscripts, function(noscript) {
            var tmp = doc2.createElement("div");
            tmp.innerHTML = noscript.innerHTML;
            if (!this._isSingleImage(tmp)) {
              return;
            }
            var prevElement = noscript.previousElementSibling;
            if (prevElement && this._isSingleImage(prevElement)) {
              var prevImg = prevElement;
              if (prevImg.tagName !== "IMG") {
                prevImg = prevElement.getElementsByTagName("img")[0];
              }
              var newImg = tmp.getElementsByTagName("img")[0];
              for (var i = 0; i < prevImg.attributes.length; i++) {
                var attr2 = prevImg.attributes[i];
                if (attr2.value === "") {
                  continue;
                }
                if (attr2.name === "src" || attr2.name === "srcset" || /\.(jpg|jpeg|png|webp)/i.test(attr2.value)) {
                  if (newImg.getAttribute(attr2.name) === attr2.value) {
                    continue;
                  }
                  var attrName = attr2.name;
                  if (newImg.hasAttribute(attrName)) {
                    attrName = "data-old-" + attrName;
                  }
                  newImg.setAttribute(attrName, attr2.value);
                }
              }
              noscript.parentNode.replaceChild(tmp.firstElementChild, prevElement);
            }
          });
        },
        _removeScripts: function(doc2) {
          this._removeNodes(this._getAllNodesWithTag(doc2, ["script"]), function(scriptNode) {
            scriptNode.nodeValue = "";
            scriptNode.removeAttribute("src");
            return true;
          });
          this._removeNodes(this._getAllNodesWithTag(doc2, ["noscript"]));
        },
        _hasSingleTagInsideElement: function(element2, tag) {
          if (element2.children.length != 1 || element2.children[0].tagName !== tag) {
            return false;
          }
          return !this._someNode(element2.childNodes, function(node) {
            return node.nodeType === this.TEXT_NODE && this.REGEXPS.hasContent.test(node.textContent);
          });
        },
        _isElementWithoutContent: function(node) {
          return node.nodeType === this.ELEMENT_NODE && node.textContent.trim().length == 0 && (node.children.length == 0 || node.children.length == node.getElementsByTagName("br").length + node.getElementsByTagName("hr").length);
        },
        _hasChildBlockElement: function(element2) {
          return this._someNode(element2.childNodes, function(node) {
            return this.DIV_TO_P_ELEMS.has(node.tagName) || this._hasChildBlockElement(node);
          });
        },
        _isPhrasingContent: function(node) {
          return node.nodeType === this.TEXT_NODE || this.PHRASING_ELEMS.indexOf(node.tagName) !== -1 || (node.tagName === "A" || node.tagName === "DEL" || node.tagName === "INS") && this._everyNode(node.childNodes, this._isPhrasingContent);
        },
        _isWhitespace: function(node) {
          return node.nodeType === this.TEXT_NODE && node.textContent.trim().length === 0 || node.nodeType === this.ELEMENT_NODE && node.tagName === "BR";
        },
        _getInnerText: function(e, normalizeSpaces) {
          normalizeSpaces = typeof normalizeSpaces === "undefined" ? true : normalizeSpaces;
          var textContent = e.textContent.trim();
          if (normalizeSpaces) {
            return textContent.replace(this.REGEXPS.normalize, " ");
          }
          return textContent;
        },
        _getCharCount: function(e, s) {
          s = s || ",";
          return this._getInnerText(e).split(s).length - 1;
        },
        _cleanStyles: function(e) {
          if (!e || e.tagName.toLowerCase() === "svg")
            return;
          for (var i = 0; i < this.PRESENTATIONAL_ATTRIBUTES.length; i++) {
            e.removeAttribute(this.PRESENTATIONAL_ATTRIBUTES[i]);
          }
          if (this.DEPRECATED_SIZE_ATTRIBUTE_ELEMS.indexOf(e.tagName) !== -1) {
            e.removeAttribute("width");
            e.removeAttribute("height");
          }
          var cur = e.firstElementChild;
          while (cur !== null) {
            this._cleanStyles(cur);
            cur = cur.nextElementSibling;
          }
        },
        _getLinkDensity: function(element2) {
          var textLength = this._getInnerText(element2).length;
          if (textLength === 0)
            return 0;
          var linkLength = 0;
          this._forEachNode(element2.getElementsByTagName("a"), function(linkNode) {
            var href = linkNode.getAttribute("href");
            var coefficient = href && this.REGEXPS.hashUrl.test(href) ? 0.3 : 1;
            linkLength += this._getInnerText(linkNode).length * coefficient;
          });
          return linkLength / textLength;
        },
        _getClassWeight: function(e) {
          if (!this._flagIsActive(this.FLAG_WEIGHT_CLASSES))
            return 0;
          var weight = 0;
          if (typeof e.className === "string" && e.className !== "") {
            if (this.REGEXPS.negative.test(e.className))
              weight -= 25;
            if (this.REGEXPS.positive.test(e.className))
              weight += 25;
          }
          if (typeof e.id === "string" && e.id !== "") {
            if (this.REGEXPS.negative.test(e.id))
              weight -= 25;
            if (this.REGEXPS.positive.test(e.id))
              weight += 25;
          }
          return weight;
        },
        _clean: function(e, tag) {
          var isEmbed = ["object", "embed", "iframe"].indexOf(tag) !== -1;
          this._removeNodes(this._getAllNodesWithTag(e, [tag]), function(element2) {
            if (isEmbed) {
              for (var i = 0; i < element2.attributes.length; i++) {
                if (this.REGEXPS.videos.test(element2.attributes[i].value)) {
                  return false;
                }
              }
              if (element2.tagName === "object" && this.REGEXPS.videos.test(element2.innerHTML)) {
                return false;
              }
            }
            return true;
          });
        },
        _hasAncestorTag: function(node, tagName, maxDepth, filterFn) {
          maxDepth = maxDepth || 3;
          tagName = tagName.toUpperCase();
          var depth = 0;
          while (node.parentNode) {
            if (maxDepth > 0 && depth > maxDepth)
              return false;
            if (node.parentNode.tagName === tagName && (!filterFn || filterFn(node.parentNode)))
              return true;
            node = node.parentNode;
            depth++;
          }
          return false;
        },
        _getRowAndColumnCount: function(table) {
          var rows2 = 0;
          var columns2 = 0;
          var trs = table.getElementsByTagName("tr");
          for (var i = 0; i < trs.length; i++) {
            var rowspan = trs[i].getAttribute("rowspan") || 0;
            if (rowspan) {
              rowspan = parseInt(rowspan, 10);
            }
            rows2 += rowspan || 1;
            var columnsInThisRow = 0;
            var cells = trs[i].getElementsByTagName("td");
            for (var j = 0; j < cells.length; j++) {
              var colspan = cells[j].getAttribute("colspan") || 0;
              if (colspan) {
                colspan = parseInt(colspan, 10);
              }
              columnsInThisRow += colspan || 1;
            }
            columns2 = Math.max(columns2, columnsInThisRow);
          }
          return { rows: rows2, columns: columns2 };
        },
        _markDataTables: function(root) {
          var tables = root.getElementsByTagName("table");
          for (var i = 0; i < tables.length; i++) {
            var table = tables[i];
            var role = table.getAttribute("role");
            if (role == "presentation") {
              table._readabilityDataTable = false;
              continue;
            }
            var datatable = table.getAttribute("datatable");
            if (datatable == "0") {
              table._readabilityDataTable = false;
              continue;
            }
            var summary = table.getAttribute("summary");
            if (summary) {
              table._readabilityDataTable = true;
              continue;
            }
            var caption = table.getElementsByTagName("caption")[0];
            if (caption && caption.childNodes.length > 0) {
              table._readabilityDataTable = true;
              continue;
            }
            var dataTableDescendants = ["col", "colgroup", "tfoot", "thead", "th"];
            var descendantExists = function(tag) {
              return !!table.getElementsByTagName(tag)[0];
            };
            if (dataTableDescendants.some(descendantExists)) {
              this.log("Data table because found data-y descendant");
              table._readabilityDataTable = true;
              continue;
            }
            if (table.getElementsByTagName("table")[0]) {
              table._readabilityDataTable = false;
              continue;
            }
            var sizeInfo = this._getRowAndColumnCount(table);
            if (sizeInfo.rows >= 10 || sizeInfo.columns > 4) {
              table._readabilityDataTable = true;
              continue;
            }
            table._readabilityDataTable = sizeInfo.rows * sizeInfo.columns > 10;
          }
        },
        _fixLazyImages: function(root) {
          this._forEachNode(this._getAllNodesWithTag(root, ["img", "picture", "figure"]), function(elem) {
            if (elem.src && this.REGEXPS.b64DataUrl.test(elem.src)) {
              var parts = this.REGEXPS.b64DataUrl.exec(elem.src);
              if (parts[1] === "image/svg+xml") {
                return;
              }
              var srcCouldBeRemoved = false;
              for (var i = 0; i < elem.attributes.length; i++) {
                var attr2 = elem.attributes[i];
                if (attr2.name === "src") {
                  continue;
                }
                if (/\.(jpg|jpeg|png|webp)/i.test(attr2.value)) {
                  srcCouldBeRemoved = true;
                  break;
                }
              }
              if (srcCouldBeRemoved) {
                var b64starts = elem.src.search(/base64\s*/i) + 7;
                var b64length = elem.src.length - b64starts;
                if (b64length < 133) {
                  elem.removeAttribute("src");
                }
              }
            }
            if ((elem.src || elem.srcset && elem.srcset != "null") && elem.className.toLowerCase().indexOf("lazy") === -1) {
              return;
            }
            for (var j = 0; j < elem.attributes.length; j++) {
              attr2 = elem.attributes[j];
              if (attr2.name === "src" || attr2.name === "srcset") {
                continue;
              }
              var copyTo = null;
              if (/\.(jpg|jpeg|png|webp)\s+\d/.test(attr2.value)) {
                copyTo = "srcset";
              } else if (/^\s*\S+\.(jpg|jpeg|png|webp)\S*\s*$/.test(attr2.value)) {
                copyTo = "src";
              }
              if (copyTo) {
                if (elem.tagName === "IMG" || elem.tagName === "PICTURE") {
                  elem.setAttribute(copyTo, attr2.value);
                } else if (elem.tagName === "FIGURE" && !this._getAllNodesWithTag(elem, ["img", "picture"]).length) {
                  var img = this._doc.createElement("img");
                  img.setAttribute(copyTo, attr2.value);
                  elem.appendChild(img);
                }
              }
            }
          });
        },
        _getTextDensity: function(e, tags) {
          var textLength = this._getInnerText(e, true).length;
          if (textLength === 0) {
            return 0;
          }
          var childrenLength = 0;
          var children2 = this._getAllNodesWithTag(e, tags);
          this._forEachNode(children2, (child) => childrenLength += this._getInnerText(child, true).length);
          return childrenLength / textLength;
        },
        _cleanConditionally: function(e, tag) {
          if (!this._flagIsActive(this.FLAG_CLEAN_CONDITIONALLY))
            return;
          this._removeNodes(this._getAllNodesWithTag(e, [tag]), function(node) {
            var isDataTable = function(t) {
              return t._readabilityDataTable;
            };
            var isList = tag === "ul" || tag === "ol";
            if (!isList) {
              var listLength = 0;
              var listNodes = this._getAllNodesWithTag(node, ["ul", "ol"]);
              this._forEachNode(listNodes, (list) => listLength += this._getInnerText(list).length);
              isList = listLength / this._getInnerText(node).length > 0.9;
            }
            if (tag === "table" && isDataTable(node)) {
              return false;
            }
            if (this._hasAncestorTag(node, "table", -1, isDataTable)) {
              return false;
            }
            if (this._hasAncestorTag(node, "code")) {
              return false;
            }
            var weight = this._getClassWeight(node);
            this.log("Cleaning Conditionally", node);
            var contentScore = 0;
            if (weight + contentScore < 0) {
              return true;
            }
            if (this._getCharCount(node, ",") < 10) {
              var p = node.getElementsByTagName("p").length;
              var img = node.getElementsByTagName("img").length;
              var li = node.getElementsByTagName("li").length - 100;
              var input = node.getElementsByTagName("input").length;
              var headingDensity = this._getTextDensity(node, ["h1", "h2", "h3", "h4", "h5", "h6"]);
              var embedCount = 0;
              var embeds = this._getAllNodesWithTag(node, ["object", "embed", "iframe"]);
              for (var i = 0; i < embeds.length; i++) {
                for (var j = 0; j < embeds[i].attributes.length; j++) {
                  if (this.REGEXPS.videos.test(embeds[i].attributes[j].value)) {
                    return false;
                  }
                }
                if (embeds[i].tagName === "object" && this.REGEXPS.videos.test(embeds[i].innerHTML)) {
                  return false;
                }
                embedCount++;
              }
              var linkDensity = this._getLinkDensity(node);
              var contentLength = this._getInnerText(node).length;
              var haveToRemove = img > 1 && p / img < 0.5 && !this._hasAncestorTag(node, "figure") || !isList && li > p || input > Math.floor(p / 3) || !isList && headingDensity < 0.9 && contentLength < 25 && (img === 0 || img > 2) && !this._hasAncestorTag(node, "figure") || !isList && weight < 25 && linkDensity > 0.2 || weight >= 25 && linkDensity > 0.5 || (embedCount === 1 && contentLength < 75 || embedCount > 1);
              return haveToRemove;
            }
            return false;
          });
        },
        _cleanMatchedNodes: function(e, filter) {
          var endOfSearchMarkerNode = this._getNextNode(e, true);
          var next = this._getNextNode(e);
          while (next && next != endOfSearchMarkerNode) {
            if (filter.call(this, next, next.className + " " + next.id)) {
              next = this._removeAndGetNext(next);
            } else {
              next = this._getNextNode(next);
            }
          }
        },
        _cleanHeaders: function(e) {
          let headingNodes = this._getAllNodesWithTag(e, ["h1", "h2"]);
          this._removeNodes(headingNodes, function(node) {
            let shouldRemove = this._getClassWeight(node) < 0;
            if (shouldRemove) {
              this.log("Removing header with low class weight:", node);
            }
            return shouldRemove;
          });
        },
        _headerDuplicatesTitle: function(node) {
          if (node.tagName != "H1" && node.tagName != "H2") {
            return false;
          }
          var heading = this._getInnerText(node, false);
          this.log("Evaluating similarity of header:", heading, this._articleTitle);
          return this._textSimilarity(this._articleTitle, heading) > 0.75;
        },
        _flagIsActive: function(flag) {
          return (this._flags & flag) > 0;
        },
        _removeFlag: function(flag) {
          this._flags = this._flags & ~flag;
        },
        _isProbablyVisible: function(node) {
          return (!node.style || node.style.display != "none") && !node.hasAttribute("hidden") && (!node.hasAttribute("aria-hidden") || node.getAttribute("aria-hidden") != "true" || node.className && node.className.indexOf && node.className.indexOf("fallback-image") !== -1);
        },
        parse: function() {
          if (this._maxElemsToParse > 0) {
            var numTags = this._doc.getElementsByTagName("*").length;
            if (numTags > this._maxElemsToParse) {
              throw new Error("Aborting parsing document; " + numTags + " elements found");
            }
          }
          this._unwrapNoscriptImages(this._doc);
          var jsonLd = this._disableJSONLD ? {} : this._getJSONLD(this._doc);
          this._removeScripts(this._doc);
          this._prepDocument();
          var metadata = this._getArticleMetadata(jsonLd);
          this._articleTitle = metadata.title;
          var articleContent = this._grabArticle();
          if (!articleContent)
            return null;
          this.log("Grabbed: " + articleContent.innerHTML);
          this._postProcessContent(articleContent);
          if (!metadata.excerpt) {
            var paragraphs = articleContent.getElementsByTagName("p");
            if (paragraphs.length > 0) {
              metadata.excerpt = paragraphs[0].textContent.trim();
            }
          }
          var textContent = articleContent.textContent;
          return {
            title: this._articleTitle,
            byline: metadata.byline || this._articleByline,
            dir: this._articleDir,
            content: this._serializer(articleContent),
            textContent,
            length: textContent.length,
            excerpt: metadata.excerpt,
            siteName: metadata.siteName || this._articleSiteName
          };
        }
      };
      if (typeof module === "object") {
        module.exports = Readability2;
      }
    }
  });

  // node_modules/@mozilla/readability/Readability-readerable.js
  var require_Readability_readerable = __commonJS({
    "node_modules/@mozilla/readability/Readability-readerable.js"(exports, module) {
      var REGEXPS = {
        unlikelyCandidates: /-ad-|ai2html|banner|breadcrumbs|combx|comment|community|cover-wrap|disqus|extra|footer|gdpr|header|legends|menu|related|remark|replies|rss|shoutbox|sidebar|skyscraper|social|sponsor|supplemental|ad-break|agegate|pagination|pager|popup|yom-remote/i,
        okMaybeItsACandidate: /and|article|body|column|content|main|shadow/i
      };
      function isNodeVisible(node) {
        return (!node.style || node.style.display != "none") && !node.hasAttribute("hidden") && (!node.hasAttribute("aria-hidden") || node.getAttribute("aria-hidden") != "true" || node.className && node.className.indexOf && node.className.indexOf("fallback-image") !== -1);
      }
      function isProbablyReaderable(doc2, options = {}) {
        if (typeof options == "function") {
          options = { visibilityChecker: options };
        }
        var defaultOptions = { minScore: 20, minContentLength: 140, visibilityChecker: isNodeVisible };
        options = Object.assign(defaultOptions, options);
        var nodes = doc2.querySelectorAll("p, pre");
        var brNodes = doc2.querySelectorAll("div > br");
        if (brNodes.length) {
          var set = new Set(nodes);
          [].forEach.call(brNodes, function(node) {
            set.add(node.parentNode);
          });
          nodes = Array.from(set);
        }
        var score = 0;
        return [].some.call(nodes, function(node) {
          if (!options.visibilityChecker(node)) {
            return false;
          }
          var matchString = node.className + " " + node.id;
          if (REGEXPS.unlikelyCandidates.test(matchString) && !REGEXPS.okMaybeItsACandidate.test(matchString)) {
            return false;
          }
          if (node.matches("li p")) {
            return false;
          }
          var textContentLength = node.textContent.trim().length;
          if (textContentLength < options.minContentLength) {
            return false;
          }
          score += Math.sqrt(textContentLength - options.minContentLength);
          if (score > options.minScore) {
            return true;
          }
          return false;
        });
      }
      if (typeof module === "object") {
        module.exports = isProbablyReaderable;
      }
    }
  });

  // node_modules/@mozilla/readability/index.js
  var require_readability = __commonJS({
    "node_modules/@mozilla/readability/index.js"(exports, module) {
      var Readability2 = require_Readability();
      var isProbablyReaderable = require_Readability_readerable();
      module.exports = {
        Readability: Readability2,
        isProbablyReaderable
      };
    }
  });

  // elos-web/node_modules/moment/moment.js
  var require_moment = __commonJS({
    "elos-web/node_modules/moment/moment.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global2.moment = factory();
      })(exports, function() {
        "use strict";
        var hookCallback;
        function hooks() {
          return hookCallback.apply(null, arguments);
        }
        function setHookCallback(callback) {
          hookCallback = callback;
        }
        function isArray(input) {
          return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
        }
        function isObject(input) {
          return input != null && Object.prototype.toString.call(input) === "[object Object]";
        }
        function hasOwnProp(a, b) {
          return Object.prototype.hasOwnProperty.call(a, b);
        }
        function isObjectEmpty(obj) {
          if (Object.getOwnPropertyNames) {
            return Object.getOwnPropertyNames(obj).length === 0;
          } else {
            var k;
            for (k in obj) {
              if (hasOwnProp(obj, k)) {
                return false;
              }
            }
            return true;
          }
        }
        function isUndefined(input) {
          return input === void 0;
        }
        function isNumber(input) {
          return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
        }
        function isDate(input) {
          return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
        }
        function map(arr, fn) {
          var res = [], i;
          for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
          }
          return res;
        }
        function extend(a, b) {
          for (var i in b) {
            if (hasOwnProp(b, i)) {
              a[i] = b[i];
            }
          }
          if (hasOwnProp(b, "toString")) {
            a.toString = b.toString;
          }
          if (hasOwnProp(b, "valueOf")) {
            a.valueOf = b.valueOf;
          }
          return a;
        }
        function createUTC(input, format2, locale2, strict) {
          return createLocalOrUTC(input, format2, locale2, strict, true).utc();
        }
        function defaultParsingFlags() {
          return {
            empty: false,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: false,
            invalidEra: null,
            invalidMonth: null,
            invalidFormat: false,
            userInvalidated: false,
            iso: false,
            parsedDateParts: [],
            era: null,
            meridiem: null,
            rfc2822: false,
            weekdayMismatch: false
          };
        }
        function getParsingFlags(m) {
          if (m._pf == null) {
            m._pf = defaultParsingFlags();
          }
          return m._pf;
        }
        var some;
        if (Array.prototype.some) {
          some = Array.prototype.some;
        } else {
          some = function(fun) {
            var t = Object(this), len = t.length >>> 0, i;
            for (i = 0; i < len; i++) {
              if (i in t && fun.call(this, t[i], i, t)) {
                return true;
              }
            }
            return false;
          };
        }
        function isValid(m) {
          if (m._isValid == null) {
            var flags = getParsingFlags(m), parsedParts = some.call(flags.parsedDateParts, function(i) {
              return i != null;
            }), isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
            if (m._strict) {
              isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
            }
            if (Object.isFrozen == null || !Object.isFrozen(m)) {
              m._isValid = isNowValid;
            } else {
              return isNowValid;
            }
          }
          return m._isValid;
        }
        function createInvalid(flags) {
          var m = createUTC(NaN);
          if (flags != null) {
            extend(getParsingFlags(m), flags);
          } else {
            getParsingFlags(m).userInvalidated = true;
          }
          return m;
        }
        var momentProperties = hooks.momentProperties = [], updateInProgress = false;
        function copyConfig(to2, from2) {
          var i, prop, val;
          if (!isUndefined(from2._isAMomentObject)) {
            to2._isAMomentObject = from2._isAMomentObject;
          }
          if (!isUndefined(from2._i)) {
            to2._i = from2._i;
          }
          if (!isUndefined(from2._f)) {
            to2._f = from2._f;
          }
          if (!isUndefined(from2._l)) {
            to2._l = from2._l;
          }
          if (!isUndefined(from2._strict)) {
            to2._strict = from2._strict;
          }
          if (!isUndefined(from2._tzm)) {
            to2._tzm = from2._tzm;
          }
          if (!isUndefined(from2._isUTC)) {
            to2._isUTC = from2._isUTC;
          }
          if (!isUndefined(from2._offset)) {
            to2._offset = from2._offset;
          }
          if (!isUndefined(from2._pf)) {
            to2._pf = getParsingFlags(from2);
          }
          if (!isUndefined(from2._locale)) {
            to2._locale = from2._locale;
          }
          if (momentProperties.length > 0) {
            for (i = 0; i < momentProperties.length; i++) {
              prop = momentProperties[i];
              val = from2[prop];
              if (!isUndefined(val)) {
                to2[prop] = val;
              }
            }
          }
          return to2;
        }
        function Moment(config) {
          copyConfig(this, config);
          this._d = new Date(config._d != null ? config._d.getTime() : NaN);
          if (!this.isValid()) {
            this._d = new Date(NaN);
          }
          if (updateInProgress === false) {
            updateInProgress = true;
            hooks.updateOffset(this);
            updateInProgress = false;
          }
        }
        function isMoment(obj) {
          return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
        }
        function warn(msg) {
          if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
            console.warn("Deprecation warning: " + msg);
          }
        }
        function deprecate(msg, fn) {
          var firstTime = true;
          return extend(function() {
            if (hooks.deprecationHandler != null) {
              hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
              var args = [], arg, i, key;
              for (i = 0; i < arguments.length; i++) {
                arg = "";
                if (typeof arguments[i] === "object") {
                  arg += "\n[" + i + "] ";
                  for (key in arguments[0]) {
                    if (hasOwnProp(arguments[0], key)) {
                      arg += key + ": " + arguments[0][key] + ", ";
                    }
                  }
                  arg = arg.slice(0, -2);
                } else {
                  arg = arguments[i];
                }
                args.push(arg);
              }
              warn(msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack);
              firstTime = false;
            }
            return fn.apply(this, arguments);
          }, fn);
        }
        var deprecations = {};
        function deprecateSimple(name, msg) {
          if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(name, msg);
          }
          if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
          }
        }
        hooks.suppressDeprecationWarnings = false;
        hooks.deprecationHandler = null;
        function isFunction(input) {
          return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
        }
        function set(config) {
          var prop, i;
          for (i in config) {
            if (hasOwnProp(config, i)) {
              prop = config[i];
              if (isFunction(prop)) {
                this[i] = prop;
              } else {
                this["_" + i] = prop;
              }
            }
          }
          this._config = config;
          this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source);
        }
        function mergeConfigs(parentConfig, childConfig) {
          var res = extend({}, parentConfig), prop;
          for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
              if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                res[prop] = {};
                extend(res[prop], parentConfig[prop]);
                extend(res[prop], childConfig[prop]);
              } else if (childConfig[prop] != null) {
                res[prop] = childConfig[prop];
              } else {
                delete res[prop];
              }
            }
          }
          for (prop in parentConfig) {
            if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
              res[prop] = extend({}, res[prop]);
            }
          }
          return res;
        }
        function Locale(config) {
          if (config != null) {
            this.set(config);
          }
        }
        var keys;
        if (Object.keys) {
          keys = Object.keys;
        } else {
          keys = function(obj) {
            var i, res = [];
            for (i in obj) {
              if (hasOwnProp(obj, i)) {
                res.push(i);
              }
            }
            return res;
          };
        }
        var defaultCalendar = {
          sameDay: "[Today at] LT",
          nextDay: "[Tomorrow at] LT",
          nextWeek: "dddd [at] LT",
          lastDay: "[Yesterday at] LT",
          lastWeek: "[Last] dddd [at] LT",
          sameElse: "L"
        };
        function calendar(key, mom, now2) {
          var output = this._calendar[key] || this._calendar["sameElse"];
          return isFunction(output) ? output.call(mom, now2) : output;
        }
        function zeroFill(number, targetLength, forceSign) {
          var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
          return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
        }
        var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
        function addFormatToken(token3, padded, ordinal2, callback) {
          var func = callback;
          if (typeof callback === "string") {
            func = function() {
              return this[callback]();
            };
          }
          if (token3) {
            formatTokenFunctions[token3] = func;
          }
          if (padded) {
            formatTokenFunctions[padded[0]] = function() {
              return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
          }
          if (ordinal2) {
            formatTokenFunctions[ordinal2] = function() {
              return this.localeData().ordinal(func.apply(this, arguments), token3);
            };
          }
        }
        function removeFormattingTokens(input) {
          if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, "");
          }
          return input.replace(/\\/g, "");
        }
        function makeFormatFunction(format2) {
          var array = format2.match(formattingTokens), i, length;
          for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
              array[i] = formatTokenFunctions[array[i]];
            } else {
              array[i] = removeFormattingTokens(array[i]);
            }
          }
          return function(mom) {
            var output = "", i2;
            for (i2 = 0; i2 < length; i2++) {
              output += isFunction(array[i2]) ? array[i2].call(mom, format2) : array[i2];
            }
            return output;
          };
        }
        function formatMoment(m, format2) {
          if (!m.isValid()) {
            return m.localeData().invalidDate();
          }
          format2 = expandFormat(format2, m.localeData());
          formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
          return formatFunctions[format2](m);
        }
        function expandFormat(format2, locale2) {
          var i = 5;
          function replaceLongDateFormatTokens(input) {
            return locale2.longDateFormat(input) || input;
          }
          localFormattingTokens.lastIndex = 0;
          while (i >= 0 && localFormattingTokens.test(format2)) {
            format2 = format2.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
          }
          return format2;
        }
        var defaultLongDateFormat = {
          LTS: "h:mm:ss A",
          LT: "h:mm A",
          L: "MM/DD/YYYY",
          LL: "MMMM D, YYYY",
          LLL: "MMMM D, YYYY h:mm A",
          LLLL: "dddd, MMMM D, YYYY h:mm A"
        };
        function longDateFormat(key) {
          var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
          if (format2 || !formatUpper) {
            return format2;
          }
          this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
            if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
              return tok.slice(1);
            }
            return tok;
          }).join("");
          return this._longDateFormat[key];
        }
        var defaultInvalidDate = "Invalid date";
        function invalidDate() {
          return this._invalidDate;
        }
        var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
        function ordinal(number) {
          return this._ordinal.replace("%d", number);
        }
        var defaultRelativeTime = {
          future: "in %s",
          past: "%s ago",
          s: "a few seconds",
          ss: "%d seconds",
          m: "a minute",
          mm: "%d minutes",
          h: "an hour",
          hh: "%d hours",
          d: "a day",
          dd: "%d days",
          w: "a week",
          ww: "%d weeks",
          M: "a month",
          MM: "%d months",
          y: "a year",
          yy: "%d years"
        };
        function relativeTime(number, withoutSuffix, string, isFuture) {
          var output = this._relativeTime[string];
          return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
        }
        function pastFuture(diff2, output) {
          var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
          return isFunction(format2) ? format2(output) : format2.replace(/%s/i, output);
        }
        var aliases = {};
        function addUnitAlias(unit, shorthand) {
          var lowerCase = unit.toLowerCase();
          aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
        }
        function normalizeUnits(units) {
          return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
        }
        function normalizeObjectUnits(inputObject) {
          var normalizedInput = {}, normalizedProp, prop;
          for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
              normalizedProp = normalizeUnits(prop);
              if (normalizedProp) {
                normalizedInput[normalizedProp] = inputObject[prop];
              }
            }
          }
          return normalizedInput;
        }
        var priorities = {};
        function addUnitPriority(unit, priority) {
          priorities[unit] = priority;
        }
        function getPrioritizedUnits(unitsObj) {
          var units = [], u;
          for (u in unitsObj) {
            if (hasOwnProp(unitsObj, u)) {
              units.push({ unit: u, priority: priorities[u] });
            }
          }
          units.sort(function(a, b) {
            return a.priority - b.priority;
          });
          return units;
        }
        function isLeapYear(year) {
          return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
        }
        function absFloor(number) {
          if (number < 0) {
            return Math.ceil(number) || 0;
          } else {
            return Math.floor(number);
          }
        }
        function toInt(argumentForCoercion) {
          var coercedNumber = +argumentForCoercion, value = 0;
          if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
          }
          return value;
        }
        function makeGetSet(unit, keepTime) {
          return function(value) {
            if (value != null) {
              set$1(this, unit, value);
              hooks.updateOffset(this, keepTime);
              return this;
            } else {
              return get(this, unit);
            }
          };
        }
        function get(mom, unit) {
          return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
        }
        function set$1(mom, unit, value) {
          if (mom.isValid() && !isNaN(value)) {
            if (unit === "FullYear" && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
              value = toInt(value);
              mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value, mom.month(), daysInMonth(value, mom.month()));
            } else {
              mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
            }
          }
        }
        function stringGet(units) {
          units = normalizeUnits(units);
          if (isFunction(this[units])) {
            return this[units]();
          }
          return this;
        }
        function stringSet(units, value) {
          if (typeof units === "object") {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units), i;
            for (i = 0; i < prioritized.length; i++) {
              this[prioritized[i].unit](units[prioritized[i].unit]);
            }
          } else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
              return this[units](value);
            }
          }
          return this;
        }
        var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, regexes;
        regexes = {};
        function addRegexToken(token3, regex, strictRegex) {
          regexes[token3] = isFunction(regex) ? regex : function(isStrict, localeData2) {
            return isStrict && strictRegex ? strictRegex : regex;
          };
        }
        function getParseRegexForToken(token3, config) {
          if (!hasOwnProp(regexes, token3)) {
            return new RegExp(unescapeFormat(token3));
          }
          return regexes[token3](config._strict, config._locale);
        }
        function unescapeFormat(s) {
          return regexEscape(s.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
          }));
        }
        function regexEscape(s) {
          return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
        }
        var tokens = {};
        function addParseToken(token3, callback) {
          var i, func = callback;
          if (typeof token3 === "string") {
            token3 = [token3];
          }
          if (isNumber(callback)) {
            func = function(input, array) {
              array[callback] = toInt(input);
            };
          }
          for (i = 0; i < token3.length; i++) {
            tokens[token3[i]] = func;
          }
        }
        function addWeekParseToken(token3, callback) {
          addParseToken(token3, function(input, array, config, token4) {
            config._w = config._w || {};
            callback(input, config._w, config, token4);
          });
        }
        function addTimeToArrayFromToken(token3, input, config) {
          if (input != null && hasOwnProp(tokens, token3)) {
            tokens[token3](input, config._a, config, token3);
          }
        }
        var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
        function mod(n, x) {
          return (n % x + x) % x;
        }
        var indexOf;
        if (Array.prototype.indexOf) {
          indexOf = Array.prototype.indexOf;
        } else {
          indexOf = function(o) {
            var i;
            for (i = 0; i < this.length; ++i) {
              if (this[i] === o) {
                return i;
              }
            }
            return -1;
          };
        }
        function daysInMonth(year, month) {
          if (isNaN(year) || isNaN(month)) {
            return NaN;
          }
          var modMonth = mod(month, 12);
          year += (month - modMonth) / 12;
          return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
        }
        addFormatToken("M", ["MM", 2], "Mo", function() {
          return this.month() + 1;
        });
        addFormatToken("MMM", 0, 0, function(format2) {
          return this.localeData().monthsShort(this, format2);
        });
        addFormatToken("MMMM", 0, 0, function(format2) {
          return this.localeData().months(this, format2);
        });
        addUnitAlias("month", "M");
        addUnitPriority("month", 8);
        addRegexToken("M", match1to2);
        addRegexToken("MM", match1to2, match2);
        addRegexToken("MMM", function(isStrict, locale2) {
          return locale2.monthsShortRegex(isStrict);
        });
        addRegexToken("MMMM", function(isStrict, locale2) {
          return locale2.monthsRegex(isStrict);
        });
        addParseToken(["M", "MM"], function(input, array) {
          array[MONTH] = toInt(input) - 1;
        });
        addParseToken(["MMM", "MMMM"], function(input, array, config, token3) {
          var month = config._locale.monthsParse(input, token3, config._strict);
          if (month != null) {
            array[MONTH] = month;
          } else {
            getParsingFlags(config).invalidMonth = input;
          }
        });
        var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
        function localeMonths(m, format2) {
          if (!m) {
            return isArray(this._months) ? this._months : this._months["standalone"];
          }
          return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m.month()];
        }
        function localeMonthsShort(m, format2) {
          if (!m) {
            return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
          }
          return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m.month()];
        }
        function handleStrictParse(monthName, format2, strict) {
          var i, ii, mom, llc = monthName.toLocaleLowerCase();
          if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
              mom = createUTC([2e3, i]);
              this._shortMonthsParse[i] = this.monthsShort(mom, "").toLocaleLowerCase();
              this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
            }
          }
          if (strict) {
            if (format2 === "MMM") {
              ii = indexOf.call(this._shortMonthsParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf.call(this._longMonthsParse, llc);
              return ii !== -1 ? ii : null;
            }
          } else {
            if (format2 === "MMM") {
              ii = indexOf.call(this._shortMonthsParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._longMonthsParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf.call(this._longMonthsParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._shortMonthsParse, llc);
              return ii !== -1 ? ii : null;
            }
          }
        }
        function localeMonthsParse(monthName, format2, strict) {
          var i, mom, regex;
          if (this._monthsParseExact) {
            return handleStrictParse.call(this, monthName, format2, strict);
          }
          if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
          }
          for (i = 0; i < 12; i++) {
            mom = createUTC([2e3, i]);
            if (strict && !this._longMonthsParse[i]) {
              this._longMonthsParse[i] = new RegExp("^" + this.months(mom, "").replace(".", "") + "$", "i");
              this._shortMonthsParse[i] = new RegExp("^" + this.monthsShort(mom, "").replace(".", "") + "$", "i");
            }
            if (!strict && !this._monthsParse[i]) {
              regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
              this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
            }
            if (strict && format2 === "MMMM" && this._longMonthsParse[i].test(monthName)) {
              return i;
            } else if (strict && format2 === "MMM" && this._shortMonthsParse[i].test(monthName)) {
              return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
              return i;
            }
          }
        }
        function setMonth(mom, value) {
          var dayOfMonth;
          if (!mom.isValid()) {
            return mom;
          }
          if (typeof value === "string") {
            if (/^\d+$/.test(value)) {
              value = toInt(value);
            } else {
              value = mom.localeData().monthsParse(value);
              if (!isNumber(value)) {
                return mom;
              }
            }
          }
          dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
          mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
          return mom;
        }
        function getSetMonth(value) {
          if (value != null) {
            setMonth(this, value);
            hooks.updateOffset(this, true);
            return this;
          } else {
            return get(this, "Month");
          }
        }
        function getDaysInMonth() {
          return daysInMonth(this.year(), this.month());
        }
        function monthsShortRegex(isStrict) {
          if (this._monthsParseExact) {
            if (!hasOwnProp(this, "_monthsRegex")) {
              computeMonthsParse.call(this);
            }
            if (isStrict) {
              return this._monthsShortStrictRegex;
            } else {
              return this._monthsShortRegex;
            }
          } else {
            if (!hasOwnProp(this, "_monthsShortRegex")) {
              this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
          }
        }
        function monthsRegex(isStrict) {
          if (this._monthsParseExact) {
            if (!hasOwnProp(this, "_monthsRegex")) {
              computeMonthsParse.call(this);
            }
            if (isStrict) {
              return this._monthsStrictRegex;
            } else {
              return this._monthsRegex;
            }
          } else {
            if (!hasOwnProp(this, "_monthsRegex")) {
              this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
          }
        }
        function computeMonthsParse() {
          function cmpLenRev(a, b) {
            return b.length - a.length;
          }
          var shortPieces = [], longPieces = [], mixedPieces = [], i, mom;
          for (i = 0; i < 12; i++) {
            mom = createUTC([2e3, i]);
            shortPieces.push(this.monthsShort(mom, ""));
            longPieces.push(this.months(mom, ""));
            mixedPieces.push(this.months(mom, ""));
            mixedPieces.push(this.monthsShort(mom, ""));
          }
          shortPieces.sort(cmpLenRev);
          longPieces.sort(cmpLenRev);
          mixedPieces.sort(cmpLenRev);
          for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
          }
          for (i = 0; i < 24; i++) {
            mixedPieces[i] = regexEscape(mixedPieces[i]);
          }
          this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
          this._monthsShortRegex = this._monthsRegex;
          this._monthsStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
          this._monthsShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
        }
        addFormatToken("Y", 0, 0, function() {
          var y = this.year();
          return y <= 9999 ? zeroFill(y, 4) : "+" + y;
        });
        addFormatToken(0, ["YY", 2], 0, function() {
          return this.year() % 100;
        });
        addFormatToken(0, ["YYYY", 4], 0, "year");
        addFormatToken(0, ["YYYYY", 5], 0, "year");
        addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
        addUnitAlias("year", "y");
        addUnitPriority("year", 1);
        addRegexToken("Y", matchSigned);
        addRegexToken("YY", match1to2, match2);
        addRegexToken("YYYY", match1to4, match4);
        addRegexToken("YYYYY", match1to6, match6);
        addRegexToken("YYYYYY", match1to6, match6);
        addParseToken(["YYYYY", "YYYYYY"], YEAR);
        addParseToken("YYYY", function(input, array) {
          array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
        });
        addParseToken("YY", function(input, array) {
          array[YEAR] = hooks.parseTwoDigitYear(input);
        });
        addParseToken("Y", function(input, array) {
          array[YEAR] = parseInt(input, 10);
        });
        function daysInYear(year) {
          return isLeapYear(year) ? 366 : 365;
        }
        hooks.parseTwoDigitYear = function(input) {
          return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
        };
        var getSetYear = makeGetSet("FullYear", true);
        function getIsLeapYear() {
          return isLeapYear(this.year());
        }
        function createDate(y, m, d, h, M, s, ms) {
          var date;
          if (y < 100 && y >= 0) {
            date = new Date(y + 400, m, d, h, M, s, ms);
            if (isFinite(date.getFullYear())) {
              date.setFullYear(y);
            }
          } else {
            date = new Date(y, m, d, h, M, s, ms);
          }
          return date;
        }
        function createUTCDate(y) {
          var date, args;
          if (y < 100 && y >= 0) {
            args = Array.prototype.slice.call(arguments);
            args[0] = y + 400;
            date = new Date(Date.UTC.apply(null, args));
            if (isFinite(date.getUTCFullYear())) {
              date.setUTCFullYear(y);
            }
          } else {
            date = new Date(Date.UTC.apply(null, arguments));
          }
          return date;
        }
        function firstWeekOffset(year, dow, doy) {
          var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
          return -fwdlw + fwd - 1;
        }
        function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
          var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
          if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
          } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
          } else {
            resYear = year;
            resDayOfYear = dayOfYear;
          }
          return {
            year: resYear,
            dayOfYear: resDayOfYear
          };
        }
        function weekOfYear(mom, dow, doy) {
          var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
          if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
          } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
          } else {
            resYear = mom.year();
            resWeek = week;
          }
          return {
            week: resWeek,
            year: resYear
          };
        }
        function weeksInYear(year, dow, doy) {
          var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
          return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
        }
        addFormatToken("w", ["ww", 2], "wo", "week");
        addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
        addUnitAlias("week", "w");
        addUnitAlias("isoWeek", "W");
        addUnitPriority("week", 5);
        addUnitPriority("isoWeek", 5);
        addRegexToken("w", match1to2);
        addRegexToken("ww", match1to2, match2);
        addRegexToken("W", match1to2);
        addRegexToken("WW", match1to2, match2);
        addWeekParseToken(["w", "ww", "W", "WW"], function(input, week, config, token3) {
          week[token3.substr(0, 1)] = toInt(input);
        });
        function localeWeek(mom) {
          return weekOfYear(mom, this._week.dow, this._week.doy).week;
        }
        var defaultLocaleWeek = {
          dow: 0,
          doy: 6
        };
        function localeFirstDayOfWeek() {
          return this._week.dow;
        }
        function localeFirstDayOfYear() {
          return this._week.doy;
        }
        function getSetWeek(input) {
          var week = this.localeData().week(this);
          return input == null ? week : this.add((input - week) * 7, "d");
        }
        function getSetISOWeek(input) {
          var week = weekOfYear(this, 1, 4).week;
          return input == null ? week : this.add((input - week) * 7, "d");
        }
        addFormatToken("d", 0, "do", "day");
        addFormatToken("dd", 0, 0, function(format2) {
          return this.localeData().weekdaysMin(this, format2);
        });
        addFormatToken("ddd", 0, 0, function(format2) {
          return this.localeData().weekdaysShort(this, format2);
        });
        addFormatToken("dddd", 0, 0, function(format2) {
          return this.localeData().weekdays(this, format2);
        });
        addFormatToken("e", 0, 0, "weekday");
        addFormatToken("E", 0, 0, "isoWeekday");
        addUnitAlias("day", "d");
        addUnitAlias("weekday", "e");
        addUnitAlias("isoWeekday", "E");
        addUnitPriority("day", 11);
        addUnitPriority("weekday", 11);
        addUnitPriority("isoWeekday", 11);
        addRegexToken("d", match1to2);
        addRegexToken("e", match1to2);
        addRegexToken("E", match1to2);
        addRegexToken("dd", function(isStrict, locale2) {
          return locale2.weekdaysMinRegex(isStrict);
        });
        addRegexToken("ddd", function(isStrict, locale2) {
          return locale2.weekdaysShortRegex(isStrict);
        });
        addRegexToken("dddd", function(isStrict, locale2) {
          return locale2.weekdaysRegex(isStrict);
        });
        addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token3) {
          var weekday = config._locale.weekdaysParse(input, token3, config._strict);
          if (weekday != null) {
            week.d = weekday;
          } else {
            getParsingFlags(config).invalidWeekday = input;
          }
        });
        addWeekParseToken(["d", "e", "E"], function(input, week, config, token3) {
          week[token3] = toInt(input);
        });
        function parseWeekday(input, locale2) {
          if (typeof input !== "string") {
            return input;
          }
          if (!isNaN(input)) {
            return parseInt(input, 10);
          }
          input = locale2.weekdaysParse(input);
          if (typeof input === "number") {
            return input;
          }
          return null;
        }
        function parseIsoWeekday(input, locale2) {
          if (typeof input === "string") {
            return locale2.weekdaysParse(input) % 7 || 7;
          }
          return isNaN(input) ? null : input;
        }
        function shiftWeekdays(ws, n) {
          return ws.slice(n, 7).concat(ws.slice(0, n));
        }
        var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
        function localeWeekdays(m, format2) {
          var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
          return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
        }
        function localeWeekdaysShort(m) {
          return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
        }
        function localeWeekdaysMin(m) {
          return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
        }
        function handleStrictParse$1(weekdayName, format2, strict) {
          var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
          if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];
            for (i = 0; i < 7; ++i) {
              mom = createUTC([2e3, 1]).day(i);
              this._minWeekdaysParse[i] = this.weekdaysMin(mom, "").toLocaleLowerCase();
              this._shortWeekdaysParse[i] = this.weekdaysShort(mom, "").toLocaleLowerCase();
              this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
            }
          }
          if (strict) {
            if (format2 === "dddd") {
              ii = indexOf.call(this._weekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else if (format2 === "ddd") {
              ii = indexOf.call(this._shortWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf.call(this._minWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            }
          } else {
            if (format2 === "dddd") {
              ii = indexOf.call(this._weekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._shortWeekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._minWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else if (format2 === "ddd") {
              ii = indexOf.call(this._shortWeekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._weekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._minWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf.call(this._minWeekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._weekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._shortWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            }
          }
        }
        function localeWeekdaysParse(weekdayName, format2, strict) {
          var i, mom, regex;
          if (this._weekdaysParseExact) {
            return handleStrictParse$1.call(this, weekdayName, format2, strict);
          }
          if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
          }
          for (i = 0; i < 7; i++) {
            mom = createUTC([2e3, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
              this._fullWeekdaysParse[i] = new RegExp("^" + this.weekdays(mom, "").replace(".", "\\.?") + "$", "i");
              this._shortWeekdaysParse[i] = new RegExp("^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$", "i");
              this._minWeekdaysParse[i] = new RegExp("^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$", "i");
            }
            if (!this._weekdaysParse[i]) {
              regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
              this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
            }
            if (strict && format2 === "dddd" && this._fullWeekdaysParse[i].test(weekdayName)) {
              return i;
            } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i].test(weekdayName)) {
              return i;
            } else if (strict && format2 === "dd" && this._minWeekdaysParse[i].test(weekdayName)) {
              return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
              return i;
            }
          }
        }
        function getSetDayOfWeek(input) {
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }
          var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
          if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, "d");
          } else {
            return day;
          }
        }
        function getSetLocaleDayOfWeek(input) {
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }
          var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
          return input == null ? weekday : this.add(input - weekday, "d");
        }
        function getSetISODayOfWeek(input) {
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }
          if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
          } else {
            return this.day() || 7;
          }
        }
        function weekdaysRegex(isStrict) {
          if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, "_weekdaysRegex")) {
              computeWeekdaysParse.call(this);
            }
            if (isStrict) {
              return this._weekdaysStrictRegex;
            } else {
              return this._weekdaysRegex;
            }
          } else {
            if (!hasOwnProp(this, "_weekdaysRegex")) {
              this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
          }
        }
        function weekdaysShortRegex(isStrict) {
          if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, "_weekdaysRegex")) {
              computeWeekdaysParse.call(this);
            }
            if (isStrict) {
              return this._weekdaysShortStrictRegex;
            } else {
              return this._weekdaysShortRegex;
            }
          } else {
            if (!hasOwnProp(this, "_weekdaysShortRegex")) {
              this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
          }
        }
        function weekdaysMinRegex(isStrict) {
          if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, "_weekdaysRegex")) {
              computeWeekdaysParse.call(this);
            }
            if (isStrict) {
              return this._weekdaysMinStrictRegex;
            } else {
              return this._weekdaysMinRegex;
            }
          } else {
            if (!hasOwnProp(this, "_weekdaysMinRegex")) {
              this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
          }
        }
        function computeWeekdaysParse() {
          function cmpLenRev(a, b) {
            return b.length - a.length;
          }
          var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
          for (i = 0; i < 7; i++) {
            mom = createUTC([2e3, 1]).day(i);
            minp = regexEscape(this.weekdaysMin(mom, ""));
            shortp = regexEscape(this.weekdaysShort(mom, ""));
            longp = regexEscape(this.weekdays(mom, ""));
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
          }
          minPieces.sort(cmpLenRev);
          shortPieces.sort(cmpLenRev);
          longPieces.sort(cmpLenRev);
          mixedPieces.sort(cmpLenRev);
          this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
          this._weekdaysShortRegex = this._weekdaysRegex;
          this._weekdaysMinRegex = this._weekdaysRegex;
          this._weekdaysStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
          this._weekdaysShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
          this._weekdaysMinStrictRegex = new RegExp("^(" + minPieces.join("|") + ")", "i");
        }
        function hFormat() {
          return this.hours() % 12 || 12;
        }
        function kFormat() {
          return this.hours() || 24;
        }
        addFormatToken("H", ["HH", 2], 0, "hour");
        addFormatToken("h", ["hh", 2], 0, hFormat);
        addFormatToken("k", ["kk", 2], 0, kFormat);
        addFormatToken("hmm", 0, 0, function() {
          return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
        });
        addFormatToken("hmmss", 0, 0, function() {
          return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
        });
        addFormatToken("Hmm", 0, 0, function() {
          return "" + this.hours() + zeroFill(this.minutes(), 2);
        });
        addFormatToken("Hmmss", 0, 0, function() {
          return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
        });
        function meridiem(token3, lowercase) {
          addFormatToken(token3, 0, 0, function() {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
          });
        }
        meridiem("a", true);
        meridiem("A", false);
        addUnitAlias("hour", "h");
        addUnitPriority("hour", 13);
        function matchMeridiem(isStrict, locale2) {
          return locale2._meridiemParse;
        }
        addRegexToken("a", matchMeridiem);
        addRegexToken("A", matchMeridiem);
        addRegexToken("H", match1to2);
        addRegexToken("h", match1to2);
        addRegexToken("k", match1to2);
        addRegexToken("HH", match1to2, match2);
        addRegexToken("hh", match1to2, match2);
        addRegexToken("kk", match1to2, match2);
        addRegexToken("hmm", match3to4);
        addRegexToken("hmmss", match5to6);
        addRegexToken("Hmm", match3to4);
        addRegexToken("Hmmss", match5to6);
        addParseToken(["H", "HH"], HOUR);
        addParseToken(["k", "kk"], function(input, array, config) {
          var kInput = toInt(input);
          array[HOUR] = kInput === 24 ? 0 : kInput;
        });
        addParseToken(["a", "A"], function(input, array, config) {
          config._isPm = config._locale.isPM(input);
          config._meridiem = input;
        });
        addParseToken(["h", "hh"], function(input, array, config) {
          array[HOUR] = toInt(input);
          getParsingFlags(config).bigHour = true;
        });
        addParseToken("hmm", function(input, array, config) {
          var pos = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos));
          array[MINUTE] = toInt(input.substr(pos));
          getParsingFlags(config).bigHour = true;
        });
        addParseToken("hmmss", function(input, array, config) {
          var pos1 = input.length - 4, pos2 = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos1));
          array[MINUTE] = toInt(input.substr(pos1, 2));
          array[SECOND] = toInt(input.substr(pos2));
          getParsingFlags(config).bigHour = true;
        });
        addParseToken("Hmm", function(input, array, config) {
          var pos = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos));
          array[MINUTE] = toInt(input.substr(pos));
        });
        addParseToken("Hmmss", function(input, array, config) {
          var pos1 = input.length - 4, pos2 = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos1));
          array[MINUTE] = toInt(input.substr(pos1, 2));
          array[SECOND] = toInt(input.substr(pos2));
        });
        function localeIsPM(input) {
          return (input + "").toLowerCase().charAt(0) === "p";
        }
        var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
        function localeMeridiem(hours2, minutes2, isLower) {
          if (hours2 > 11) {
            return isLower ? "pm" : "PM";
          } else {
            return isLower ? "am" : "AM";
          }
        }
        var baseConfig = {
          calendar: defaultCalendar,
          longDateFormat: defaultLongDateFormat,
          invalidDate: defaultInvalidDate,
          ordinal: defaultOrdinal,
          dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
          relativeTime: defaultRelativeTime,
          months: defaultLocaleMonths,
          monthsShort: defaultLocaleMonthsShort,
          week: defaultLocaleWeek,
          weekdays: defaultLocaleWeekdays,
          weekdaysMin: defaultLocaleWeekdaysMin,
          weekdaysShort: defaultLocaleWeekdaysShort,
          meridiemParse: defaultLocaleMeridiemParse
        };
        var locales = {}, localeFamilies = {}, globalLocale;
        function commonPrefix(arr1, arr2) {
          var i, minl = Math.min(arr1.length, arr2.length);
          for (i = 0; i < minl; i += 1) {
            if (arr1[i] !== arr2[i]) {
              return i;
            }
          }
          return minl;
        }
        function normalizeLocale(key) {
          return key ? key.toLowerCase().replace("_", "-") : key;
        }
        function chooseLocale(names) {
          var i = 0, j, next, locale2, split;
          while (i < names.length) {
            split = normalizeLocale(names[i]).split("-");
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split("-") : null;
            while (j > 0) {
              locale2 = loadLocale(split.slice(0, j).join("-"));
              if (locale2) {
                return locale2;
              }
              if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
                break;
              }
              j--;
            }
            i++;
          }
          return globalLocale;
        }
        function loadLocale(name) {
          var oldLocale = null, aliasedRequire;
          if (locales[name] === void 0 && typeof module !== "undefined" && module && module.exports) {
            try {
              oldLocale = globalLocale._abbr;
              aliasedRequire = __require;
              aliasedRequire("./locale/" + name);
              getSetGlobalLocale(oldLocale);
            } catch (e) {
              locales[name] = null;
            }
          }
          return locales[name];
        }
        function getSetGlobalLocale(key, values) {
          var data;
          if (key) {
            if (isUndefined(values)) {
              data = getLocale(key);
            } else {
              data = defineLocale(key, values);
            }
            if (data) {
              globalLocale = data;
            } else {
              if (typeof console !== "undefined" && console.warn) {
                console.warn("Locale " + key + " not found. Did you forget to load it?");
              }
            }
          }
          return globalLocale._abbr;
        }
        function defineLocale(name, config) {
          if (config !== null) {
            var locale2, parentConfig = baseConfig;
            config.abbr = name;
            if (locales[name] != null) {
              deprecateSimple("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info.");
              parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
              if (locales[config.parentLocale] != null) {
                parentConfig = locales[config.parentLocale]._config;
              } else {
                locale2 = loadLocale(config.parentLocale);
                if (locale2 != null) {
                  parentConfig = locale2._config;
                } else {
                  if (!localeFamilies[config.parentLocale]) {
                    localeFamilies[config.parentLocale] = [];
                  }
                  localeFamilies[config.parentLocale].push({
                    name,
                    config
                  });
                  return null;
                }
              }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config));
            if (localeFamilies[name]) {
              localeFamilies[name].forEach(function(x) {
                defineLocale(x.name, x.config);
              });
            }
            getSetGlobalLocale(name);
            return locales[name];
          } else {
            delete locales[name];
            return null;
          }
        }
        function updateLocale(name, config) {
          if (config != null) {
            var locale2, tmpLocale, parentConfig = baseConfig;
            if (locales[name] != null && locales[name].parentLocale != null) {
              locales[name].set(mergeConfigs(locales[name]._config, config));
            } else {
              tmpLocale = loadLocale(name);
              if (tmpLocale != null) {
                parentConfig = tmpLocale._config;
              }
              config = mergeConfigs(parentConfig, config);
              if (tmpLocale == null) {
                config.abbr = name;
              }
              locale2 = new Locale(config);
              locale2.parentLocale = locales[name];
              locales[name] = locale2;
            }
            getSetGlobalLocale(name);
          } else {
            if (locales[name] != null) {
              if (locales[name].parentLocale != null) {
                locales[name] = locales[name].parentLocale;
                if (name === getSetGlobalLocale()) {
                  getSetGlobalLocale(name);
                }
              } else if (locales[name] != null) {
                delete locales[name];
              }
            }
          }
          return locales[name];
        }
        function getLocale(key) {
          var locale2;
          if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
          }
          if (!key) {
            return globalLocale;
          }
          if (!isArray(key)) {
            locale2 = loadLocale(key);
            if (locale2) {
              return locale2;
            }
            key = [key];
          }
          return chooseLocale(key);
        }
        function listLocales() {
          return keys(locales);
        }
        function checkOverflow(m) {
          var overflow, a = m._a;
          if (a && getParsingFlags(m).overflow === -2) {
            overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
              overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
              overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
              overflow = WEEKDAY;
            }
            getParsingFlags(m).overflow = overflow;
          }
          return m;
        }
        var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
          ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
          ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
          ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
          ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
          ["YYYY-DDD", /\d{4}-\d{3}/],
          ["YYYY-MM", /\d{4}-\d\d/, false],
          ["YYYYYYMMDD", /[+-]\d{10}/],
          ["YYYYMMDD", /\d{8}/],
          ["GGGG[W]WWE", /\d{4}W\d{3}/],
          ["GGGG[W]WW", /\d{4}W\d{2}/, false],
          ["YYYYDDD", /\d{7}/],
          ["YYYYMM", /\d{6}/, false],
          ["YYYY", /\d{4}/, false]
        ], isoTimes = [
          ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
          ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
          ["HH:mm:ss", /\d\d:\d\d:\d\d/],
          ["HH:mm", /\d\d:\d\d/],
          ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
          ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
          ["HHmmss", /\d\d\d\d\d\d/],
          ["HHmm", /\d\d\d\d/],
          ["HH", /\d\d/]
        ], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
          UT: 0,
          GMT: 0,
          EDT: -4 * 60,
          EST: -5 * 60,
          CDT: -5 * 60,
          CST: -6 * 60,
          MDT: -6 * 60,
          MST: -7 * 60,
          PDT: -7 * 60,
          PST: -8 * 60
        };
        function configFromISO(config) {
          var i, l, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat;
          if (match) {
            getParsingFlags(config).iso = true;
            for (i = 0, l = isoDates.length; i < l; i++) {
              if (isoDates[i][1].exec(match[1])) {
                dateFormat = isoDates[i][0];
                allowTime = isoDates[i][2] !== false;
                break;
              }
            }
            if (dateFormat == null) {
              config._isValid = false;
              return;
            }
            if (match[3]) {
              for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(match[3])) {
                  timeFormat = (match[2] || " ") + isoTimes[i][0];
                  break;
                }
              }
              if (timeFormat == null) {
                config._isValid = false;
                return;
              }
            }
            if (!allowTime && timeFormat != null) {
              config._isValid = false;
              return;
            }
            if (match[4]) {
              if (tzRegex.exec(match[4])) {
                tzFormat = "Z";
              } else {
                config._isValid = false;
                return;
              }
            }
            config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
            configFromStringAndFormat(config);
          } else {
            config._isValid = false;
          }
        }
        function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
          var result = [
            untruncateYear(yearStr),
            defaultLocaleMonthsShort.indexOf(monthStr),
            parseInt(dayStr, 10),
            parseInt(hourStr, 10),
            parseInt(minuteStr, 10)
          ];
          if (secondStr) {
            result.push(parseInt(secondStr, 10));
          }
          return result;
        }
        function untruncateYear(yearStr) {
          var year = parseInt(yearStr, 10);
          if (year <= 49) {
            return 2e3 + year;
          } else if (year <= 999) {
            return 1900 + year;
          }
          return year;
        }
        function preprocessRFC2822(s) {
          return s.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
        }
        function checkWeekday(weekdayStr, parsedInput, config) {
          if (weekdayStr) {
            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
            if (weekdayProvided !== weekdayActual) {
              getParsingFlags(config).weekdayMismatch = true;
              config._isValid = false;
              return false;
            }
          }
          return true;
        }
        function calculateOffset(obsOffset, militaryOffset, numOffset) {
          if (obsOffset) {
            return obsOffsets[obsOffset];
          } else if (militaryOffset) {
            return 0;
          } else {
            var hm = parseInt(numOffset, 10), m = hm % 100, h = (hm - m) / 100;
            return h * 60 + m;
          }
        }
        function configFromRFC2822(config) {
          var match = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
          if (match) {
            parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
            if (!checkWeekday(match[1], parsedArray, config)) {
              return;
            }
            config._a = parsedArray;
            config._tzm = calculateOffset(match[8], match[9], match[10]);
            config._d = createUTCDate.apply(null, config._a);
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
            getParsingFlags(config).rfc2822 = true;
          } else {
            config._isValid = false;
          }
        }
        function configFromString(config) {
          var matched = aspNetJsonRegex.exec(config._i);
          if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
          }
          configFromISO(config);
          if (config._isValid === false) {
            delete config._isValid;
          } else {
            return;
          }
          configFromRFC2822(config);
          if (config._isValid === false) {
            delete config._isValid;
          } else {
            return;
          }
          if (config._strict) {
            config._isValid = false;
          } else {
            hooks.createFromInputFallback(config);
          }
        }
        hooks.createFromInputFallback = deprecate("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", function(config) {
          config._d = new Date(config._i + (config._useUTC ? " UTC" : ""));
        });
        function defaults(a, b, c) {
          if (a != null) {
            return a;
          }
          if (b != null) {
            return b;
          }
          return c;
        }
        function currentDateArray(config) {
          var nowValue = new Date(hooks.now());
          if (config._useUTC) {
            return [
              nowValue.getUTCFullYear(),
              nowValue.getUTCMonth(),
              nowValue.getUTCDate()
            ];
          }
          return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
        }
        function configFromArray(config) {
          var i, date, input = [], currentDate, expectedWeekday, yearToUse;
          if (config._d) {
            return;
          }
          currentDate = currentDateArray(config);
          if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
          }
          if (config._dayOfYear != null) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
            if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
              getParsingFlags(config)._overflowDayOfYear = true;
            }
            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
          }
          for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
          }
          for (; i < 7; i++) {
            config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
          }
          if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
          }
          config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
          expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
          if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
          }
          if (config._nextDay) {
            config._a[HOUR] = 24;
          }
          if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
            getParsingFlags(config).weekdayMismatch = true;
          }
        }
        function dayOfYearFromWeekInfo(config) {
          var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
          w = config._w;
          if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
              weekdayOverflow = true;
            }
          } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;
            curWeek = weekOfYear(createLocal(), dow, doy);
            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);
            week = defaults(w.w, curWeek.week);
            if (w.d != null) {
              weekday = w.d;
              if (weekday < 0 || weekday > 6) {
                weekdayOverflow = true;
              }
            } else if (w.e != null) {
              weekday = w.e + dow;
              if (w.e < 0 || w.e > 6) {
                weekdayOverflow = true;
              }
            } else {
              weekday = dow;
            }
          }
          if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
          } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
          } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
          }
        }
        hooks.ISO_8601 = function() {
        };
        hooks.RFC_2822 = function() {
        };
        function configFromStringAndFormat(config) {
          if (config._f === hooks.ISO_8601) {
            configFromISO(config);
            return;
          }
          if (config._f === hooks.RFC_2822) {
            configFromRFC2822(config);
            return;
          }
          config._a = [];
          getParsingFlags(config).empty = true;
          var string = "" + config._i, i, parsedInput, tokens2, token3, skipped, stringLength = string.length, totalParsedInputLength = 0, era;
          tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
          for (i = 0; i < tokens2.length; i++) {
            token3 = tokens2[i];
            parsedInput = (string.match(getParseRegexForToken(token3, config)) || [])[0];
            if (parsedInput) {
              skipped = string.substr(0, string.indexOf(parsedInput));
              if (skipped.length > 0) {
                getParsingFlags(config).unusedInput.push(skipped);
              }
              string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
              totalParsedInputLength += parsedInput.length;
            }
            if (formatTokenFunctions[token3]) {
              if (parsedInput) {
                getParsingFlags(config).empty = false;
              } else {
                getParsingFlags(config).unusedTokens.push(token3);
              }
              addTimeToArrayFromToken(token3, parsedInput, config);
            } else if (config._strict && !parsedInput) {
              getParsingFlags(config).unusedTokens.push(token3);
            }
          }
          getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
          if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
          }
          if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = void 0;
          }
          getParsingFlags(config).parsedDateParts = config._a.slice(0);
          getParsingFlags(config).meridiem = config._meridiem;
          config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
          era = getParsingFlags(config).era;
          if (era !== null) {
            config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
          }
          configFromArray(config);
          checkOverflow(config);
        }
        function meridiemFixWrap(locale2, hour, meridiem2) {
          var isPm;
          if (meridiem2 == null) {
            return hour;
          }
          if (locale2.meridiemHour != null) {
            return locale2.meridiemHour(hour, meridiem2);
          } else if (locale2.isPM != null) {
            isPm = locale2.isPM(meridiem2);
            if (isPm && hour < 12) {
              hour += 12;
            }
            if (!isPm && hour === 12) {
              hour = 0;
            }
            return hour;
          } else {
            return hour;
          }
        }
        function configFromStringAndArray(config) {
          var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = false;
          if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
          }
          for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            validFormatFound = false;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
              tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);
            if (isValid(tempConfig)) {
              validFormatFound = true;
            }
            currentScore += getParsingFlags(tempConfig).charsLeftOver;
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
            getParsingFlags(tempConfig).score = currentScore;
            if (!bestFormatIsValid) {
              if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
                if (validFormatFound) {
                  bestFormatIsValid = true;
                }
              }
            } else {
              if (currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
              }
            }
          }
          extend(config, bestMoment || tempConfig);
        }
        function configFromObject(config) {
          if (config._d) {
            return;
          }
          var i = normalizeObjectUnits(config._i), dayOrDate = i.day === void 0 ? i.date : i.day;
          config._a = map([i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond], function(obj) {
            return obj && parseInt(obj, 10);
          });
          configFromArray(config);
        }
        function createFromConfig(config) {
          var res = new Moment(checkOverflow(prepareConfig(config)));
          if (res._nextDay) {
            res.add(1, "d");
            res._nextDay = void 0;
          }
          return res;
        }
        function prepareConfig(config) {
          var input = config._i, format2 = config._f;
          config._locale = config._locale || getLocale(config._l);
          if (input === null || format2 === void 0 && input === "") {
            return createInvalid({ nullInput: true });
          }
          if (typeof input === "string") {
            config._i = input = config._locale.preparse(input);
          }
          if (isMoment(input)) {
            return new Moment(checkOverflow(input));
          } else if (isDate(input)) {
            config._d = input;
          } else if (isArray(format2)) {
            configFromStringAndArray(config);
          } else if (format2) {
            configFromStringAndFormat(config);
          } else {
            configFromInput(config);
          }
          if (!isValid(config)) {
            config._d = null;
          }
          return config;
        }
        function configFromInput(config) {
          var input = config._i;
          if (isUndefined(input)) {
            config._d = new Date(hooks.now());
          } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
          } else if (typeof input === "string") {
            configFromString(config);
          } else if (isArray(input)) {
            config._a = map(input.slice(0), function(obj) {
              return parseInt(obj, 10);
            });
            configFromArray(config);
          } else if (isObject(input)) {
            configFromObject(config);
          } else if (isNumber(input)) {
            config._d = new Date(input);
          } else {
            hooks.createFromInputFallback(config);
          }
        }
        function createLocalOrUTC(input, format2, locale2, strict, isUTC) {
          var c = {};
          if (format2 === true || format2 === false) {
            strict = format2;
            format2 = void 0;
          }
          if (locale2 === true || locale2 === false) {
            strict = locale2;
            locale2 = void 0;
          }
          if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
            input = void 0;
          }
          c._isAMomentObject = true;
          c._useUTC = c._isUTC = isUTC;
          c._l = locale2;
          c._i = input;
          c._f = format2;
          c._strict = strict;
          return createFromConfig(c);
        }
        function createLocal(input, format2, locale2, strict) {
          return createLocalOrUTC(input, format2, locale2, strict, false);
        }
        var prototypeMin = deprecate("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
          var other = createLocal.apply(null, arguments);
          if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
          } else {
            return createInvalid();
          }
        }), prototypeMax = deprecate("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
          var other = createLocal.apply(null, arguments);
          if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
          } else {
            return createInvalid();
          }
        });
        function pickBy(fn, moments) {
          var res, i;
          if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
          }
          if (!moments.length) {
            return createLocal();
          }
          res = moments[0];
          for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
              res = moments[i];
            }
          }
          return res;
        }
        function min() {
          var args = [].slice.call(arguments, 0);
          return pickBy("isBefore", args);
        }
        function max() {
          var args = [].slice.call(arguments, 0);
          return pickBy("isAfter", args);
        }
        var now = function() {
          return Date.now ? Date.now() : +new Date();
        };
        var ordering = [
          "year",
          "quarter",
          "month",
          "week",
          "day",
          "hour",
          "minute",
          "second",
          "millisecond"
        ];
        function isDurationValid(m) {
          var key, unitHasDecimal = false, i;
          for (key in m) {
            if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
              return false;
            }
          }
          for (i = 0; i < ordering.length; ++i) {
            if (m[ordering[i]]) {
              if (unitHasDecimal) {
                return false;
              }
              if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                unitHasDecimal = true;
              }
            }
          }
          return true;
        }
        function isValid$1() {
          return this._isValid;
        }
        function createInvalid$1() {
          return createDuration(NaN);
        }
        function Duration(duration) {
          var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
          this._isValid = isDurationValid(normalizedInput);
          this._milliseconds = +milliseconds2 + seconds2 * 1e3 + minutes2 * 6e4 + hours2 * 1e3 * 60 * 60;
          this._days = +days2 + weeks2 * 7;
          this._months = +months2 + quarters * 3 + years2 * 12;
          this._data = {};
          this._locale = getLocale();
          this._bubble();
        }
        function isDuration(obj) {
          return obj instanceof Duration;
        }
        function absRound(number) {
          if (number < 0) {
            return Math.round(-1 * number) * -1;
          } else {
            return Math.round(number);
          }
        }
        function compareArrays(array1, array2, dontConvert) {
          var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
          for (i = 0; i < len; i++) {
            if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
              diffs++;
            }
          }
          return diffs + lengthDiff;
        }
        function offset(token3, separator) {
          addFormatToken(token3, 0, 0, function() {
            var offset2 = this.utcOffset(), sign2 = "+";
            if (offset2 < 0) {
              offset2 = -offset2;
              sign2 = "-";
            }
            return sign2 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
          });
        }
        offset("Z", ":");
        offset("ZZ", "");
        addRegexToken("Z", matchShortOffset);
        addRegexToken("ZZ", matchShortOffset);
        addParseToken(["Z", "ZZ"], function(input, array, config) {
          config._useUTC = true;
          config._tzm = offsetFromString(matchShortOffset, input);
        });
        var chunkOffset = /([\+\-]|\d\d)/gi;
        function offsetFromString(matcher, string) {
          var matches = (string || "").match(matcher), chunk, parts, minutes2;
          if (matches === null) {
            return null;
          }
          chunk = matches[matches.length - 1] || [];
          parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
          minutes2 = +(parts[1] * 60) + toInt(parts[2]);
          return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
        }
        function cloneWithOffset(input, model) {
          var res, diff2;
          if (model._isUTC) {
            res = model.clone();
            diff2 = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
            res._d.setTime(res._d.valueOf() + diff2);
            hooks.updateOffset(res, false);
            return res;
          } else {
            return createLocal(input).local();
          }
        }
        function getDateOffset(m) {
          return -Math.round(m._d.getTimezoneOffset());
        }
        hooks.updateOffset = function() {
        };
        function getSetOffset(input, keepLocalTime, keepMinutes) {
          var offset2 = this._offset || 0, localAdjust;
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }
          if (input != null) {
            if (typeof input === "string") {
              input = offsetFromString(matchShortOffset, input);
              if (input === null) {
                return this;
              }
            } else if (Math.abs(input) < 16 && !keepMinutes) {
              input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
              localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
              this.add(localAdjust, "m");
            }
            if (offset2 !== input) {
              if (!keepLocalTime || this._changeInProgress) {
                addSubtract(this, createDuration(input - offset2, "m"), 1, false);
              } else if (!this._changeInProgress) {
                this._changeInProgress = true;
                hooks.updateOffset(this, true);
                this._changeInProgress = null;
              }
            }
            return this;
          } else {
            return this._isUTC ? offset2 : getDateOffset(this);
          }
        }
        function getSetZone(input, keepLocalTime) {
          if (input != null) {
            if (typeof input !== "string") {
              input = -input;
            }
            this.utcOffset(input, keepLocalTime);
            return this;
          } else {
            return -this.utcOffset();
          }
        }
        function setOffsetToUTC(keepLocalTime) {
          return this.utcOffset(0, keepLocalTime);
        }
        function setOffsetToLocal(keepLocalTime) {
          if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;
            if (keepLocalTime) {
              this.subtract(getDateOffset(this), "m");
            }
          }
          return this;
        }
        function setOffsetToParsedOffset() {
          if (this._tzm != null) {
            this.utcOffset(this._tzm, false, true);
          } else if (typeof this._i === "string") {
            var tZone = offsetFromString(matchOffset, this._i);
            if (tZone != null) {
              this.utcOffset(tZone);
            } else {
              this.utcOffset(0, true);
            }
          }
          return this;
        }
        function hasAlignedHourOffset(input) {
          if (!this.isValid()) {
            return false;
          }
          input = input ? createLocal(input).utcOffset() : 0;
          return (this.utcOffset() - input) % 60 === 0;
        }
        function isDaylightSavingTime() {
          return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
        }
        function isDaylightSavingTimeShifted() {
          if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
          }
          var c = {}, other;
          copyConfig(c, this);
          c = prepareConfig(c);
          if (c._a) {
            other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
            this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
          } else {
            this._isDSTShifted = false;
          }
          return this._isDSTShifted;
        }
        function isLocal() {
          return this.isValid() ? !this._isUTC : false;
        }
        function isUtcOffset() {
          return this.isValid() ? this._isUTC : false;
        }
        function isUtc() {
          return this.isValid() ? this._isUTC && this._offset === 0 : false;
        }
        var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
        function createDuration(input, key) {
          var duration = input, match = null, sign2, ret, diffRes;
          if (isDuration(input)) {
            duration = {
              ms: input._milliseconds,
              d: input._days,
              M: input._months
            };
          } else if (isNumber(input) || !isNaN(+input)) {
            duration = {};
            if (key) {
              duration[key] = +input;
            } else {
              duration.milliseconds = +input;
            }
          } else if (match = aspNetRegex.exec(input)) {
            sign2 = match[1] === "-" ? -1 : 1;
            duration = {
              y: 0,
              d: toInt(match[DATE]) * sign2,
              h: toInt(match[HOUR]) * sign2,
              m: toInt(match[MINUTE]) * sign2,
              s: toInt(match[SECOND]) * sign2,
              ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign2
            };
          } else if (match = isoRegex.exec(input)) {
            sign2 = match[1] === "-" ? -1 : 1;
            duration = {
              y: parseIso(match[2], sign2),
              M: parseIso(match[3], sign2),
              w: parseIso(match[4], sign2),
              d: parseIso(match[5], sign2),
              h: parseIso(match[6], sign2),
              m: parseIso(match[7], sign2),
              s: parseIso(match[8], sign2)
            };
          } else if (duration == null) {
            duration = {};
          } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
            diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
          }
          ret = new Duration(duration);
          if (isDuration(input) && hasOwnProp(input, "_locale")) {
            ret._locale = input._locale;
          }
          if (isDuration(input) && hasOwnProp(input, "_isValid")) {
            ret._isValid = input._isValid;
          }
          return ret;
        }
        createDuration.fn = Duration.prototype;
        createDuration.invalid = createInvalid$1;
        function parseIso(inp, sign2) {
          var res = inp && parseFloat(inp.replace(",", "."));
          return (isNaN(res) ? 0 : res) * sign2;
        }
        function positiveMomentsDifference(base, other) {
          var res = {};
          res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
          if (base.clone().add(res.months, "M").isAfter(other)) {
            --res.months;
          }
          res.milliseconds = +other - +base.clone().add(res.months, "M");
          return res;
        }
        function momentsDifference(base, other) {
          var res;
          if (!(base.isValid() && other.isValid())) {
            return { milliseconds: 0, months: 0 };
          }
          other = cloneWithOffset(other, base);
          if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
          } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
          }
          return res;
        }
        function createAdder(direction, name) {
          return function(val, period) {
            var dur, tmp;
            if (period !== null && !isNaN(+period)) {
              deprecateSimple(name, "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.");
              tmp = val;
              val = period;
              period = tmp;
            }
            dur = createDuration(val, period);
            addSubtract(this, dur, direction);
            return this;
          };
        }
        function addSubtract(mom, duration, isAdding, updateOffset) {
          var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
          if (!mom.isValid()) {
            return;
          }
          updateOffset = updateOffset == null ? true : updateOffset;
          if (months2) {
            setMonth(mom, get(mom, "Month") + months2 * isAdding);
          }
          if (days2) {
            set$1(mom, "Date", get(mom, "Date") + days2 * isAdding);
          }
          if (milliseconds2) {
            mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
          }
          if (updateOffset) {
            hooks.updateOffset(mom, days2 || months2);
          }
        }
        var add2 = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
        function isString(input) {
          return typeof input === "string" || input instanceof String;
        }
        function isMomentInput(input) {
          return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
        }
        function isMomentInputObject(input) {
          var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
            "years",
            "year",
            "y",
            "months",
            "month",
            "M",
            "days",
            "day",
            "d",
            "dates",
            "date",
            "D",
            "hours",
            "hour",
            "h",
            "minutes",
            "minute",
            "m",
            "seconds",
            "second",
            "s",
            "milliseconds",
            "millisecond",
            "ms"
          ], i, property;
          for (i = 0; i < properties.length; i += 1) {
            property = properties[i];
            propertyTest = propertyTest || hasOwnProp(input, property);
          }
          return objectTest && propertyTest;
        }
        function isNumberOrStringArray(input) {
          var arrayTest = isArray(input), dataTypeTest = false;
          if (arrayTest) {
            dataTypeTest = input.filter(function(item2) {
              return !isNumber(item2) && isString(input);
            }).length === 0;
          }
          return arrayTest && dataTypeTest;
        }
        function isCalendarSpec(input) {
          var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
            "sameDay",
            "nextDay",
            "lastDay",
            "nextWeek",
            "lastWeek",
            "sameElse"
          ], i, property;
          for (i = 0; i < properties.length; i += 1) {
            property = properties[i];
            propertyTest = propertyTest || hasOwnProp(input, property);
          }
          return objectTest && propertyTest;
        }
        function getCalendarFormat(myMoment, now2) {
          var diff2 = myMoment.diff(now2, "days", true);
          return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
        }
        function calendar$1(time, formats) {
          if (arguments.length === 1) {
            if (!arguments[0]) {
              time = void 0;
              formats = void 0;
            } else if (isMomentInput(arguments[0])) {
              time = arguments[0];
              formats = void 0;
            } else if (isCalendarSpec(arguments[0])) {
              formats = arguments[0];
              time = void 0;
            }
          }
          var now2 = time || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction(formats[format2]) ? formats[format2].call(this, now2) : formats[format2]);
          return this.format(output || this.localeData().calendar(format2, this, createLocal(now2)));
        }
        function clone() {
          return new Moment(this);
        }
        function isAfter(input, units) {
          var localInput = isMoment(input) ? input : createLocal(input);
          if (!(this.isValid() && localInput.isValid())) {
            return false;
          }
          units = normalizeUnits(units) || "millisecond";
          if (units === "millisecond") {
            return this.valueOf() > localInput.valueOf();
          } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
          }
        }
        function isBefore(input, units) {
          var localInput = isMoment(input) ? input : createLocal(input);
          if (!(this.isValid() && localInput.isValid())) {
            return false;
          }
          units = normalizeUnits(units) || "millisecond";
          if (units === "millisecond") {
            return this.valueOf() < localInput.valueOf();
          } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
          }
        }
        function isBetween(from2, to2, units, inclusivity) {
          var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
          if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
            return false;
          }
          inclusivity = inclusivity || "()";
          return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
        }
        function isSame(input, units) {
          var localInput = isMoment(input) ? input : createLocal(input), inputMs;
          if (!(this.isValid() && localInput.isValid())) {
            return false;
          }
          units = normalizeUnits(units) || "millisecond";
          if (units === "millisecond") {
            return this.valueOf() === localInput.valueOf();
          } else {
            inputMs = localInput.valueOf();
            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
          }
        }
        function isSameOrAfter(input, units) {
          return this.isSame(input, units) || this.isAfter(input, units);
        }
        function isSameOrBefore(input, units) {
          return this.isSame(input, units) || this.isBefore(input, units);
        }
        function diff(input, units, asFloat) {
          var that, zoneDelta, output;
          if (!this.isValid()) {
            return NaN;
          }
          that = cloneWithOffset(input, this);
          if (!that.isValid()) {
            return NaN;
          }
          zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
          units = normalizeUnits(units);
          switch (units) {
            case "year":
              output = monthDiff(this, that) / 12;
              break;
            case "month":
              output = monthDiff(this, that);
              break;
            case "quarter":
              output = monthDiff(this, that) / 3;
              break;
            case "second":
              output = (this - that) / 1e3;
              break;
            case "minute":
              output = (this - that) / 6e4;
              break;
            case "hour":
              output = (this - that) / 36e5;
              break;
            case "day":
              output = (this - that - zoneDelta) / 864e5;
              break;
            case "week":
              output = (this - that - zoneDelta) / 6048e5;
              break;
            default:
              output = this - that;
          }
          return asFloat ? output : absFloor(output);
        }
        function monthDiff(a, b) {
          if (a.date() < b.date()) {
            return -monthDiff(b, a);
          }
          var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust2;
          if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
            adjust2 = (b - anchor) / (anchor - anchor2);
          } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
            adjust2 = (b - anchor) / (anchor2 - anchor);
          }
          return -(wholeMonthDiff + adjust2) || 0;
        }
        hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
        hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
        function toString() {
          return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
        }
        function toISOString(keepOffset) {
          if (!this.isValid()) {
            return null;
          }
          var utc = keepOffset !== true, m = utc ? this.clone().utc() : this;
          if (m.year() < 0 || m.year() > 9999) {
            return formatMoment(m, utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ");
          }
          if (isFunction(Date.prototype.toISOString)) {
            if (utc) {
              return this.toDate().toISOString();
            } else {
              return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m, "Z"));
            }
          }
          return formatMoment(m, utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ");
        }
        function inspect() {
          if (!this.isValid()) {
            return "moment.invalid(/* " + this._i + " */)";
          }
          var func = "moment", zone = "", prefix, year, datetime, suffix;
          if (!this.isLocal()) {
            func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
            zone = "Z";
          }
          prefix = "[" + func + '("]';
          year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
          datetime = "-MM-DD[T]HH:mm:ss.SSS";
          suffix = zone + '[")]';
          return this.format(prefix + year + datetime + suffix);
        }
        function format(inputString) {
          if (!inputString) {
            inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
          }
          var output = formatMoment(this, inputString);
          return this.localeData().postformat(output);
        }
        function from(time, withoutSuffix) {
          if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
            return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
          } else {
            return this.localeData().invalidDate();
          }
        }
        function fromNow(withoutSuffix) {
          return this.from(createLocal(), withoutSuffix);
        }
        function to(time, withoutSuffix) {
          if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
            return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
          } else {
            return this.localeData().invalidDate();
          }
        }
        function toNow(withoutSuffix) {
          return this.to(createLocal(), withoutSuffix);
        }
        function locale(key) {
          var newLocaleData;
          if (key === void 0) {
            return this._locale._abbr;
          } else {
            newLocaleData = getLocale(key);
            if (newLocaleData != null) {
              this._locale = newLocaleData;
            }
            return this;
          }
        }
        var lang = deprecate("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function(key) {
          if (key === void 0) {
            return this.localeData();
          } else {
            return this.locale(key);
          }
        });
        function localeData() {
          return this._locale;
        }
        var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
        function mod$1(dividend, divisor) {
          return (dividend % divisor + divisor) % divisor;
        }
        function localStartOfDate(y, m, d) {
          if (y < 100 && y >= 0) {
            return new Date(y + 400, m, d) - MS_PER_400_YEARS;
          } else {
            return new Date(y, m, d).valueOf();
          }
        }
        function utcStartOfDate(y, m, d) {
          if (y < 100 && y >= 0) {
            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
          } else {
            return Date.UTC(y, m, d);
          }
        }
        function startOf(units) {
          var time, startOfDate;
          units = normalizeUnits(units);
          if (units === void 0 || units === "millisecond" || !this.isValid()) {
            return this;
          }
          startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
          switch (units) {
            case "year":
              time = startOfDate(this.year(), 0, 1);
              break;
            case "quarter":
              time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
              break;
            case "month":
              time = startOfDate(this.year(), this.month(), 1);
              break;
            case "week":
              time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
              break;
            case "isoWeek":
              time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
              break;
            case "day":
            case "date":
              time = startOfDate(this.year(), this.month(), this.date());
              break;
            case "hour":
              time = this._d.valueOf();
              time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
              break;
            case "minute":
              time = this._d.valueOf();
              time -= mod$1(time, MS_PER_MINUTE);
              break;
            case "second":
              time = this._d.valueOf();
              time -= mod$1(time, MS_PER_SECOND);
              break;
          }
          this._d.setTime(time);
          hooks.updateOffset(this, true);
          return this;
        }
        function endOf(units) {
          var time, startOfDate;
          units = normalizeUnits(units);
          if (units === void 0 || units === "millisecond" || !this.isValid()) {
            return this;
          }
          startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
          switch (units) {
            case "year":
              time = startOfDate(this.year() + 1, 0, 1) - 1;
              break;
            case "quarter":
              time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
              break;
            case "month":
              time = startOfDate(this.year(), this.month() + 1, 1) - 1;
              break;
            case "week":
              time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
              break;
            case "isoWeek":
              time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
              break;
            case "day":
            case "date":
              time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
              break;
            case "hour":
              time = this._d.valueOf();
              time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
              break;
            case "minute":
              time = this._d.valueOf();
              time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
              break;
            case "second":
              time = this._d.valueOf();
              time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
              break;
          }
          this._d.setTime(time);
          hooks.updateOffset(this, true);
          return this;
        }
        function valueOf() {
          return this._d.valueOf() - (this._offset || 0) * 6e4;
        }
        function unix() {
          return Math.floor(this.valueOf() / 1e3);
        }
        function toDate() {
          return new Date(this.valueOf());
        }
        function toArray() {
          var m = this;
          return [
            m.year(),
            m.month(),
            m.date(),
            m.hour(),
            m.minute(),
            m.second(),
            m.millisecond()
          ];
        }
        function toObject() {
          var m = this;
          return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
          };
        }
        function toJSON() {
          return this.isValid() ? this.toISOString() : null;
        }
        function isValid$2() {
          return isValid(this);
        }
        function parsingFlags() {
          return extend({}, getParsingFlags(this));
        }
        function invalidAt() {
          return getParsingFlags(this).overflow;
        }
        function creationData() {
          return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
          };
        }
        addFormatToken("N", 0, 0, "eraAbbr");
        addFormatToken("NN", 0, 0, "eraAbbr");
        addFormatToken("NNN", 0, 0, "eraAbbr");
        addFormatToken("NNNN", 0, 0, "eraName");
        addFormatToken("NNNNN", 0, 0, "eraNarrow");
        addFormatToken("y", ["y", 1], "yo", "eraYear");
        addFormatToken("y", ["yy", 2], 0, "eraYear");
        addFormatToken("y", ["yyy", 3], 0, "eraYear");
        addFormatToken("y", ["yyyy", 4], 0, "eraYear");
        addRegexToken("N", matchEraAbbr);
        addRegexToken("NN", matchEraAbbr);
        addRegexToken("NNN", matchEraAbbr);
        addRegexToken("NNNN", matchEraName);
        addRegexToken("NNNNN", matchEraNarrow);
        addParseToken(["N", "NN", "NNN", "NNNN", "NNNNN"], function(input, array, config, token3) {
          var era = config._locale.erasParse(input, token3, config._strict);
          if (era) {
            getParsingFlags(config).era = era;
          } else {
            getParsingFlags(config).invalidEra = input;
          }
        });
        addRegexToken("y", matchUnsigned);
        addRegexToken("yy", matchUnsigned);
        addRegexToken("yyy", matchUnsigned);
        addRegexToken("yyyy", matchUnsigned);
        addRegexToken("yo", matchEraYearOrdinal);
        addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
        addParseToken(["yo"], function(input, array, config, token3) {
          var match;
          if (config._locale._eraYearOrdinalRegex) {
            match = input.match(config._locale._eraYearOrdinalRegex);
          }
          if (config._locale.eraYearOrdinalParse) {
            array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
          } else {
            array[YEAR] = parseInt(input, 10);
          }
        });
        function localeEras(m, format2) {
          var i, l, date, eras = this._eras || getLocale("en")._eras;
          for (i = 0, l = eras.length; i < l; ++i) {
            switch (typeof eras[i].since) {
              case "string":
                date = hooks(eras[i].since).startOf("day");
                eras[i].since = date.valueOf();
                break;
            }
            switch (typeof eras[i].until) {
              case "undefined":
                eras[i].until = Infinity;
                break;
              case "string":
                date = hooks(eras[i].until).startOf("day").valueOf();
                eras[i].until = date.valueOf();
                break;
            }
          }
          return eras;
        }
        function localeErasParse(eraName, format2, strict) {
          var i, l, eras = this.eras(), name, abbr, narrow;
          eraName = eraName.toUpperCase();
          for (i = 0, l = eras.length; i < l; ++i) {
            name = eras[i].name.toUpperCase();
            abbr = eras[i].abbr.toUpperCase();
            narrow = eras[i].narrow.toUpperCase();
            if (strict) {
              switch (format2) {
                case "N":
                case "NN":
                case "NNN":
                  if (abbr === eraName) {
                    return eras[i];
                  }
                  break;
                case "NNNN":
                  if (name === eraName) {
                    return eras[i];
                  }
                  break;
                case "NNNNN":
                  if (narrow === eraName) {
                    return eras[i];
                  }
                  break;
              }
            } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
              return eras[i];
            }
          }
        }
        function localeErasConvertYear(era, year) {
          var dir = era.since <= era.until ? 1 : -1;
          if (year === void 0) {
            return hooks(era.since).year();
          } else {
            return hooks(era.since).year() + (year - era.offset) * dir;
          }
        }
        function getEraName() {
          var i, l, val, eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
            val = this.clone().startOf("day").valueOf();
            if (eras[i].since <= val && val <= eras[i].until) {
              return eras[i].name;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
              return eras[i].name;
            }
          }
          return "";
        }
        function getEraNarrow() {
          var i, l, val, eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
            val = this.clone().startOf("day").valueOf();
            if (eras[i].since <= val && val <= eras[i].until) {
              return eras[i].narrow;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
              return eras[i].narrow;
            }
          }
          return "";
        }
        function getEraAbbr() {
          var i, l, val, eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
            val = this.clone().startOf("day").valueOf();
            if (eras[i].since <= val && val <= eras[i].until) {
              return eras[i].abbr;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
              return eras[i].abbr;
            }
          }
          return "";
        }
        function getEraYear() {
          var i, l, dir, val, eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
            dir = eras[i].since <= eras[i].until ? 1 : -1;
            val = this.clone().startOf("day").valueOf();
            if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
              return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
            }
          }
          return this.year();
        }
        function erasNameRegex(isStrict) {
          if (!hasOwnProp(this, "_erasNameRegex")) {
            computeErasParse.call(this);
          }
          return isStrict ? this._erasNameRegex : this._erasRegex;
        }
        function erasAbbrRegex(isStrict) {
          if (!hasOwnProp(this, "_erasAbbrRegex")) {
            computeErasParse.call(this);
          }
          return isStrict ? this._erasAbbrRegex : this._erasRegex;
        }
        function erasNarrowRegex(isStrict) {
          if (!hasOwnProp(this, "_erasNarrowRegex")) {
            computeErasParse.call(this);
          }
          return isStrict ? this._erasNarrowRegex : this._erasRegex;
        }
        function matchEraAbbr(isStrict, locale2) {
          return locale2.erasAbbrRegex(isStrict);
        }
        function matchEraName(isStrict, locale2) {
          return locale2.erasNameRegex(isStrict);
        }
        function matchEraNarrow(isStrict, locale2) {
          return locale2.erasNarrowRegex(isStrict);
        }
        function matchEraYearOrdinal(isStrict, locale2) {
          return locale2._eraYearOrdinalRegex || matchUnsigned;
        }
        function computeErasParse() {
          var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i, l, eras = this.eras();
          for (i = 0, l = eras.length; i < l; ++i) {
            namePieces.push(regexEscape(eras[i].name));
            abbrPieces.push(regexEscape(eras[i].abbr));
            narrowPieces.push(regexEscape(eras[i].narrow));
            mixedPieces.push(regexEscape(eras[i].name));
            mixedPieces.push(regexEscape(eras[i].abbr));
            mixedPieces.push(regexEscape(eras[i].narrow));
          }
          this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
          this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
          this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
          this._erasNarrowRegex = new RegExp("^(" + narrowPieces.join("|") + ")", "i");
        }
        addFormatToken(0, ["gg", 2], 0, function() {
          return this.weekYear() % 100;
        });
        addFormatToken(0, ["GG", 2], 0, function() {
          return this.isoWeekYear() % 100;
        });
        function addWeekYearFormatToken(token3, getter) {
          addFormatToken(0, [token3, token3.length], 0, getter);
        }
        addWeekYearFormatToken("gggg", "weekYear");
        addWeekYearFormatToken("ggggg", "weekYear");
        addWeekYearFormatToken("GGGG", "isoWeekYear");
        addWeekYearFormatToken("GGGGG", "isoWeekYear");
        addUnitAlias("weekYear", "gg");
        addUnitAlias("isoWeekYear", "GG");
        addUnitPriority("weekYear", 1);
        addUnitPriority("isoWeekYear", 1);
        addRegexToken("G", matchSigned);
        addRegexToken("g", matchSigned);
        addRegexToken("GG", match1to2, match2);
        addRegexToken("gg", match1to2, match2);
        addRegexToken("GGGG", match1to4, match4);
        addRegexToken("gggg", match1to4, match4);
        addRegexToken("GGGGG", match1to6, match6);
        addRegexToken("ggggg", match1to6, match6);
        addWeekParseToken(["gggg", "ggggg", "GGGG", "GGGGG"], function(input, week, config, token3) {
          week[token3.substr(0, 2)] = toInt(input);
        });
        addWeekParseToken(["gg", "GG"], function(input, week, config, token3) {
          week[token3] = hooks.parseTwoDigitYear(input);
        });
        function getSetWeekYear(input) {
          return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
        }
        function getSetISOWeekYear(input) {
          return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
        }
        function getISOWeeksInYear() {
          return weeksInYear(this.year(), 1, 4);
        }
        function getISOWeeksInISOWeekYear() {
          return weeksInYear(this.isoWeekYear(), 1, 4);
        }
        function getWeeksInYear() {
          var weekInfo = this.localeData()._week;
          return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
        }
        function getWeeksInWeekYear() {
          var weekInfo = this.localeData()._week;
          return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
        }
        function getSetWeekYearHelper(input, week, weekday, dow, doy) {
          var weeksTarget;
          if (input == null) {
            return weekOfYear(this, dow, doy).year;
          } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
              week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
          }
        }
        function setWeekAll(weekYear, week, weekday, dow, doy) {
          var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
          this.year(date.getUTCFullYear());
          this.month(date.getUTCMonth());
          this.date(date.getUTCDate());
          return this;
        }
        addFormatToken("Q", 0, "Qo", "quarter");
        addUnitAlias("quarter", "Q");
        addUnitPriority("quarter", 7);
        addRegexToken("Q", match1);
        addParseToken("Q", function(input, array) {
          array[MONTH] = (toInt(input) - 1) * 3;
        });
        function getSetQuarter(input) {
          return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
        }
        addFormatToken("D", ["DD", 2], "Do", "date");
        addUnitAlias("date", "D");
        addUnitPriority("date", 9);
        addRegexToken("D", match1to2);
        addRegexToken("DD", match1to2, match2);
        addRegexToken("Do", function(isStrict, locale2) {
          return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
        });
        addParseToken(["D", "DD"], DATE);
        addParseToken("Do", function(input, array) {
          array[DATE] = toInt(input.match(match1to2)[0]);
        });
        var getSetDayOfMonth = makeGetSet("Date", true);
        addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
        addUnitAlias("dayOfYear", "DDD");
        addUnitPriority("dayOfYear", 4);
        addRegexToken("DDD", match1to3);
        addRegexToken("DDDD", match3);
        addParseToken(["DDD", "DDDD"], function(input, array, config) {
          config._dayOfYear = toInt(input);
        });
        function getSetDayOfYear(input) {
          var dayOfYear = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
          return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
        }
        addFormatToken("m", ["mm", 2], 0, "minute");
        addUnitAlias("minute", "m");
        addUnitPriority("minute", 14);
        addRegexToken("m", match1to2);
        addRegexToken("mm", match1to2, match2);
        addParseToken(["m", "mm"], MINUTE);
        var getSetMinute = makeGetSet("Minutes", false);
        addFormatToken("s", ["ss", 2], 0, "second");
        addUnitAlias("second", "s");
        addUnitPriority("second", 15);
        addRegexToken("s", match1to2);
        addRegexToken("ss", match1to2, match2);
        addParseToken(["s", "ss"], SECOND);
        var getSetSecond = makeGetSet("Seconds", false);
        addFormatToken("S", 0, 0, function() {
          return ~~(this.millisecond() / 100);
        });
        addFormatToken(0, ["SS", 2], 0, function() {
          return ~~(this.millisecond() / 10);
        });
        addFormatToken(0, ["SSS", 3], 0, "millisecond");
        addFormatToken(0, ["SSSS", 4], 0, function() {
          return this.millisecond() * 10;
        });
        addFormatToken(0, ["SSSSS", 5], 0, function() {
          return this.millisecond() * 100;
        });
        addFormatToken(0, ["SSSSSS", 6], 0, function() {
          return this.millisecond() * 1e3;
        });
        addFormatToken(0, ["SSSSSSS", 7], 0, function() {
          return this.millisecond() * 1e4;
        });
        addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
          return this.millisecond() * 1e5;
        });
        addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
          return this.millisecond() * 1e6;
        });
        addUnitAlias("millisecond", "ms");
        addUnitPriority("millisecond", 16);
        addRegexToken("S", match1to3, match1);
        addRegexToken("SS", match1to3, match2);
        addRegexToken("SSS", match1to3, match3);
        var token2, getSetMillisecond;
        for (token2 = "SSSS"; token2.length <= 9; token2 += "S") {
          addRegexToken(token2, matchUnsigned);
        }
        function parseMs(input, array) {
          array[MILLISECOND] = toInt(("0." + input) * 1e3);
        }
        for (token2 = "S"; token2.length <= 9; token2 += "S") {
          addParseToken(token2, parseMs);
        }
        getSetMillisecond = makeGetSet("Milliseconds", false);
        addFormatToken("z", 0, 0, "zoneAbbr");
        addFormatToken("zz", 0, 0, "zoneName");
        function getZoneAbbr() {
          return this._isUTC ? "UTC" : "";
        }
        function getZoneName() {
          return this._isUTC ? "Coordinated Universal Time" : "";
        }
        var proto = Moment.prototype;
        proto.add = add2;
        proto.calendar = calendar$1;
        proto.clone = clone;
        proto.diff = diff;
        proto.endOf = endOf;
        proto.format = format;
        proto.from = from;
        proto.fromNow = fromNow;
        proto.to = to;
        proto.toNow = toNow;
        proto.get = stringGet;
        proto.invalidAt = invalidAt;
        proto.isAfter = isAfter;
        proto.isBefore = isBefore;
        proto.isBetween = isBetween;
        proto.isSame = isSame;
        proto.isSameOrAfter = isSameOrAfter;
        proto.isSameOrBefore = isSameOrBefore;
        proto.isValid = isValid$2;
        proto.lang = lang;
        proto.locale = locale;
        proto.localeData = localeData;
        proto.max = prototypeMax;
        proto.min = prototypeMin;
        proto.parsingFlags = parsingFlags;
        proto.set = stringSet;
        proto.startOf = startOf;
        proto.subtract = subtract;
        proto.toArray = toArray;
        proto.toObject = toObject;
        proto.toDate = toDate;
        proto.toISOString = toISOString;
        proto.inspect = inspect;
        if (typeof Symbol !== "undefined" && Symbol.for != null) {
          proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
            return "Moment<" + this.format() + ">";
          };
        }
        proto.toJSON = toJSON;
        proto.toString = toString;
        proto.unix = unix;
        proto.valueOf = valueOf;
        proto.creationData = creationData;
        proto.eraName = getEraName;
        proto.eraNarrow = getEraNarrow;
        proto.eraAbbr = getEraAbbr;
        proto.eraYear = getEraYear;
        proto.year = getSetYear;
        proto.isLeapYear = getIsLeapYear;
        proto.weekYear = getSetWeekYear;
        proto.isoWeekYear = getSetISOWeekYear;
        proto.quarter = proto.quarters = getSetQuarter;
        proto.month = getSetMonth;
        proto.daysInMonth = getDaysInMonth;
        proto.week = proto.weeks = getSetWeek;
        proto.isoWeek = proto.isoWeeks = getSetISOWeek;
        proto.weeksInYear = getWeeksInYear;
        proto.weeksInWeekYear = getWeeksInWeekYear;
        proto.isoWeeksInYear = getISOWeeksInYear;
        proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
        proto.date = getSetDayOfMonth;
        proto.day = proto.days = getSetDayOfWeek;
        proto.weekday = getSetLocaleDayOfWeek;
        proto.isoWeekday = getSetISODayOfWeek;
        proto.dayOfYear = getSetDayOfYear;
        proto.hour = proto.hours = getSetHour;
        proto.minute = proto.minutes = getSetMinute;
        proto.second = proto.seconds = getSetSecond;
        proto.millisecond = proto.milliseconds = getSetMillisecond;
        proto.utcOffset = getSetOffset;
        proto.utc = setOffsetToUTC;
        proto.local = setOffsetToLocal;
        proto.parseZone = setOffsetToParsedOffset;
        proto.hasAlignedHourOffset = hasAlignedHourOffset;
        proto.isDST = isDaylightSavingTime;
        proto.isLocal = isLocal;
        proto.isUtcOffset = isUtcOffset;
        proto.isUtc = isUtc;
        proto.isUTC = isUtc;
        proto.zoneAbbr = getZoneAbbr;
        proto.zoneName = getZoneName;
        proto.dates = deprecate("dates accessor is deprecated. Use date instead.", getSetDayOfMonth);
        proto.months = deprecate("months accessor is deprecated. Use month instead", getSetMonth);
        proto.years = deprecate("years accessor is deprecated. Use year instead", getSetYear);
        proto.zone = deprecate("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", getSetZone);
        proto.isDSTShifted = deprecate("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", isDaylightSavingTimeShifted);
        function createUnix(input) {
          return createLocal(input * 1e3);
        }
        function createInZone() {
          return createLocal.apply(null, arguments).parseZone();
        }
        function preParsePostFormat(string) {
          return string;
        }
        var proto$1 = Locale.prototype;
        proto$1.calendar = calendar;
        proto$1.longDateFormat = longDateFormat;
        proto$1.invalidDate = invalidDate;
        proto$1.ordinal = ordinal;
        proto$1.preparse = preParsePostFormat;
        proto$1.postformat = preParsePostFormat;
        proto$1.relativeTime = relativeTime;
        proto$1.pastFuture = pastFuture;
        proto$1.set = set;
        proto$1.eras = localeEras;
        proto$1.erasParse = localeErasParse;
        proto$1.erasConvertYear = localeErasConvertYear;
        proto$1.erasAbbrRegex = erasAbbrRegex;
        proto$1.erasNameRegex = erasNameRegex;
        proto$1.erasNarrowRegex = erasNarrowRegex;
        proto$1.months = localeMonths;
        proto$1.monthsShort = localeMonthsShort;
        proto$1.monthsParse = localeMonthsParse;
        proto$1.monthsRegex = monthsRegex;
        proto$1.monthsShortRegex = monthsShortRegex;
        proto$1.week = localeWeek;
        proto$1.firstDayOfYear = localeFirstDayOfYear;
        proto$1.firstDayOfWeek = localeFirstDayOfWeek;
        proto$1.weekdays = localeWeekdays;
        proto$1.weekdaysMin = localeWeekdaysMin;
        proto$1.weekdaysShort = localeWeekdaysShort;
        proto$1.weekdaysParse = localeWeekdaysParse;
        proto$1.weekdaysRegex = weekdaysRegex;
        proto$1.weekdaysShortRegex = weekdaysShortRegex;
        proto$1.weekdaysMinRegex = weekdaysMinRegex;
        proto$1.isPM = localeIsPM;
        proto$1.meridiem = localeMeridiem;
        function get$1(format2, index, field, setter) {
          var locale2 = getLocale(), utc = createUTC().set(setter, index);
          return locale2[field](utc, format2);
        }
        function listMonthsImpl(format2, index, field) {
          if (isNumber(format2)) {
            index = format2;
            format2 = void 0;
          }
          format2 = format2 || "";
          if (index != null) {
            return get$1(format2, index, field, "month");
          }
          var i, out = [];
          for (i = 0; i < 12; i++) {
            out[i] = get$1(format2, i, field, "month");
          }
          return out;
        }
        function listWeekdaysImpl(localeSorted, format2, index, field) {
          if (typeof localeSorted === "boolean") {
            if (isNumber(format2)) {
              index = format2;
              format2 = void 0;
            }
            format2 = format2 || "";
          } else {
            format2 = localeSorted;
            index = format2;
            localeSorted = false;
            if (isNumber(format2)) {
              index = format2;
              format2 = void 0;
            }
            format2 = format2 || "";
          }
          var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i, out = [];
          if (index != null) {
            return get$1(format2, (index + shift) % 7, field, "day");
          }
          for (i = 0; i < 7; i++) {
            out[i] = get$1(format2, (i + shift) % 7, field, "day");
          }
          return out;
        }
        function listMonths(format2, index) {
          return listMonthsImpl(format2, index, "months");
        }
        function listMonthsShort(format2, index) {
          return listMonthsImpl(format2, index, "monthsShort");
        }
        function listWeekdays(localeSorted, format2, index) {
          return listWeekdaysImpl(localeSorted, format2, index, "weekdays");
        }
        function listWeekdaysShort(localeSorted, format2, index) {
          return listWeekdaysImpl(localeSorted, format2, index, "weekdaysShort");
        }
        function listWeekdaysMin(localeSorted, format2, index) {
          return listWeekdaysImpl(localeSorted, format2, index, "weekdaysMin");
        }
        getSetGlobalLocale("en", {
          eras: [
            {
              since: "0001-01-01",
              until: Infinity,
              offset: 1,
              name: "Anno Domini",
              narrow: "AD",
              abbr: "AD"
            },
            {
              since: "0000-12-31",
              until: -Infinity,
              offset: 1,
              name: "Before Christ",
              narrow: "BC",
              abbr: "BC"
            }
          ],
          dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
          ordinal: function(number) {
            var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
            return number + output;
          }
        });
        hooks.lang = deprecate("moment.lang is deprecated. Use moment.locale instead.", getSetGlobalLocale);
        hooks.langData = deprecate("moment.langData is deprecated. Use moment.localeData instead.", getLocale);
        var mathAbs = Math.abs;
        function abs() {
          var data = this._data;
          this._milliseconds = mathAbs(this._milliseconds);
          this._days = mathAbs(this._days);
          this._months = mathAbs(this._months);
          data.milliseconds = mathAbs(data.milliseconds);
          data.seconds = mathAbs(data.seconds);
          data.minutes = mathAbs(data.minutes);
          data.hours = mathAbs(data.hours);
          data.months = mathAbs(data.months);
          data.years = mathAbs(data.years);
          return this;
        }
        function addSubtract$1(duration, input, value, direction) {
          var other = createDuration(input, value);
          duration._milliseconds += direction * other._milliseconds;
          duration._days += direction * other._days;
          duration._months += direction * other._months;
          return duration._bubble();
        }
        function add$1(input, value) {
          return addSubtract$1(this, input, value, 1);
        }
        function subtract$1(input, value) {
          return addSubtract$1(this, input, value, -1);
        }
        function absCeil(number) {
          if (number < 0) {
            return Math.floor(number);
          } else {
            return Math.ceil(number);
          }
        }
        function bubble2() {
          var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
          if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
            milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
            days2 = 0;
            months2 = 0;
          }
          data.milliseconds = milliseconds2 % 1e3;
          seconds2 = absFloor(milliseconds2 / 1e3);
          data.seconds = seconds2 % 60;
          minutes2 = absFloor(seconds2 / 60);
          data.minutes = minutes2 % 60;
          hours2 = absFloor(minutes2 / 60);
          data.hours = hours2 % 24;
          days2 += absFloor(hours2 / 24);
          monthsFromDays = absFloor(daysToMonths(days2));
          months2 += monthsFromDays;
          days2 -= absCeil(monthsToDays(monthsFromDays));
          years2 = absFloor(months2 / 12);
          months2 %= 12;
          data.days = days2;
          data.months = months2;
          data.years = years2;
          return this;
        }
        function daysToMonths(days2) {
          return days2 * 4800 / 146097;
        }
        function monthsToDays(months2) {
          return months2 * 146097 / 4800;
        }
        function as(units) {
          if (!this.isValid()) {
            return NaN;
          }
          var days2, months2, milliseconds2 = this._milliseconds;
          units = normalizeUnits(units);
          if (units === "month" || units === "quarter" || units === "year") {
            days2 = this._days + milliseconds2 / 864e5;
            months2 = this._months + daysToMonths(days2);
            switch (units) {
              case "month":
                return months2;
              case "quarter":
                return months2 / 3;
              case "year":
                return months2 / 12;
            }
          } else {
            days2 = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
              case "week":
                return days2 / 7 + milliseconds2 / 6048e5;
              case "day":
                return days2 + milliseconds2 / 864e5;
              case "hour":
                return days2 * 24 + milliseconds2 / 36e5;
              case "minute":
                return days2 * 1440 + milliseconds2 / 6e4;
              case "second":
                return days2 * 86400 + milliseconds2 / 1e3;
              case "millisecond":
                return Math.floor(days2 * 864e5) + milliseconds2;
              default:
                throw new Error("Unknown unit " + units);
            }
          }
        }
        function valueOf$1() {
          if (!this.isValid()) {
            return NaN;
          }
          return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
        }
        function makeAs(alias) {
          return function() {
            return this.as(alias);
          };
        }
        var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y");
        function clone$1() {
          return createDuration(this);
        }
        function get$2(units) {
          units = normalizeUnits(units);
          return this.isValid() ? this[units + "s"]() : NaN;
        }
        function makeGetter(name) {
          return function() {
            return this.isValid() ? this._data[name] : NaN;
          };
        }
        var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
        function weeks() {
          return absFloor(this.days() / 7);
        }
        var round = Math.round, thresholds = {
          ss: 44,
          s: 45,
          m: 45,
          h: 22,
          d: 26,
          w: null,
          M: 11
        };
        function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale2) {
          return locale2.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
        }
        function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
          var duration = createDuration(posNegDuration).abs(), seconds2 = round(duration.as("s")), minutes2 = round(duration.as("m")), hours2 = round(duration.as("h")), days2 = round(duration.as("d")), months2 = round(duration.as("M")), weeks2 = round(duration.as("w")), years2 = round(duration.as("y")), a = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
          if (thresholds2.w != null) {
            a = a || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
          }
          a = a || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
          a[2] = withoutSuffix;
          a[3] = +posNegDuration > 0;
          a[4] = locale2;
          return substituteTimeAgo.apply(null, a);
        }
        function getSetRelativeTimeRounding(roundingFunction) {
          if (roundingFunction === void 0) {
            return round;
          }
          if (typeof roundingFunction === "function") {
            round = roundingFunction;
            return true;
          }
          return false;
        }
        function getSetRelativeTimeThreshold(threshold, limit) {
          if (thresholds[threshold] === void 0) {
            return false;
          }
          if (limit === void 0) {
            return thresholds[threshold];
          }
          thresholds[threshold] = limit;
          if (threshold === "s") {
            thresholds.ss = limit - 1;
          }
          return true;
        }
        function humanize(argWithSuffix, argThresholds) {
          if (!this.isValid()) {
            return this.localeData().invalidDate();
          }
          var withSuffix = false, th = thresholds, locale2, output;
          if (typeof argWithSuffix === "object") {
            argThresholds = argWithSuffix;
            argWithSuffix = false;
          }
          if (typeof argWithSuffix === "boolean") {
            withSuffix = argWithSuffix;
          }
          if (typeof argThresholds === "object") {
            th = Object.assign({}, thresholds, argThresholds);
            if (argThresholds.s != null && argThresholds.ss == null) {
              th.ss = argThresholds.s - 1;
            }
          }
          locale2 = this.localeData();
          output = relativeTime$1(this, !withSuffix, th, locale2);
          if (withSuffix) {
            output = locale2.pastFuture(+this, output);
          }
          return locale2.postformat(output);
        }
        var abs$1 = Math.abs;
        function sign(x) {
          return (x > 0) - (x < 0) || +x;
        }
        function toISOString$1() {
          if (!this.isValid()) {
            return this.localeData().invalidDate();
          }
          var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
          if (!total) {
            return "P0D";
          }
          minutes2 = absFloor(seconds2 / 60);
          hours2 = absFloor(minutes2 / 60);
          seconds2 %= 60;
          minutes2 %= 60;
          years2 = absFloor(months2 / 12);
          months2 %= 12;
          s = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
          totalSign = total < 0 ? "-" : "";
          ymSign = sign(this._months) !== sign(total) ? "-" : "";
          daysSign = sign(this._days) !== sign(total) ? "-" : "";
          hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
          return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s + "S" : "");
        }
        var proto$2 = Duration.prototype;
        proto$2.isValid = isValid$1;
        proto$2.abs = abs;
        proto$2.add = add$1;
        proto$2.subtract = subtract$1;
        proto$2.as = as;
        proto$2.asMilliseconds = asMilliseconds;
        proto$2.asSeconds = asSeconds;
        proto$2.asMinutes = asMinutes;
        proto$2.asHours = asHours;
        proto$2.asDays = asDays;
        proto$2.asWeeks = asWeeks;
        proto$2.asMonths = asMonths;
        proto$2.asQuarters = asQuarters;
        proto$2.asYears = asYears;
        proto$2.valueOf = valueOf$1;
        proto$2._bubble = bubble2;
        proto$2.clone = clone$1;
        proto$2.get = get$2;
        proto$2.milliseconds = milliseconds;
        proto$2.seconds = seconds;
        proto$2.minutes = minutes;
        proto$2.hours = hours;
        proto$2.days = days;
        proto$2.weeks = weeks;
        proto$2.months = months;
        proto$2.years = years;
        proto$2.humanize = humanize;
        proto$2.toISOString = toISOString$1;
        proto$2.toString = toISOString$1;
        proto$2.toJSON = toISOString$1;
        proto$2.locale = locale;
        proto$2.localeData = localeData;
        proto$2.toIsoString = deprecate("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", toISOString$1);
        proto$2.lang = lang;
        addFormatToken("X", 0, 0, "unix");
        addFormatToken("x", 0, 0, "valueOf");
        addRegexToken("x", matchSigned);
        addRegexToken("X", matchTimestamp);
        addParseToken("X", function(input, array, config) {
          config._d = new Date(parseFloat(input) * 1e3);
        });
        addParseToken("x", function(input, array, config) {
          config._d = new Date(toInt(input));
        });
        hooks.version = "2.29.1";
        setHookCallback(createLocal);
        hooks.fn = proto;
        hooks.min = min;
        hooks.max = max;
        hooks.now = now;
        hooks.utc = createUTC;
        hooks.unix = createUnix;
        hooks.months = listMonths;
        hooks.isDate = isDate;
        hooks.locale = getSetGlobalLocale;
        hooks.invalid = createInvalid;
        hooks.duration = createDuration;
        hooks.isMoment = isMoment;
        hooks.weekdays = listWeekdays;
        hooks.parseZone = createInZone;
        hooks.localeData = getLocale;
        hooks.isDuration = isDuration;
        hooks.monthsShort = listMonthsShort;
        hooks.weekdaysMin = listWeekdaysMin;
        hooks.defineLocale = defineLocale;
        hooks.updateLocale = updateLocale;
        hooks.locales = listLocales;
        hooks.weekdaysShort = listWeekdaysShort;
        hooks.normalizeUnits = normalizeUnits;
        hooks.relativeTimeRounding = getSetRelativeTimeRounding;
        hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
        hooks.calendarFormat = getCalendarFormat;
        hooks.prototype = proto;
        hooks.HTML5_FMT = {
          DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
          DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
          DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
          DATE: "YYYY-MM-DD",
          TIME: "HH:mm",
          TIME_SECONDS: "HH:mm:ss",
          TIME_MS: "HH:mm:ss.SSS",
          WEEK: "GGGG-[W]WW",
          MONTH: "YYYY-MM"
        };
        return hooks;
      });
    }
  });

  // elos-web/node_modules/chart.js/dist/Chart.js
  var require_Chart = __commonJS({
    "elos-web/node_modules/chart.js/dist/Chart.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory(function() {
          try {
            return require_moment();
          } catch (e) {
          }
        }()) : typeof define === "function" && define.amd ? define(["require"], function(require2) {
          return factory(function() {
            try {
              return require2("moment");
            } catch (e) {
            }
          }());
        }) : (global2 = global2 || self, global2.Chart = factory(global2.moment));
      })(exports, function(moment) {
        "use strict";
        moment = moment && moment.hasOwnProperty("default") ? moment["default"] : moment;
        function createCommonjsModule(fn, module2) {
          return module2 = { exports: {} }, fn(module2, module2.exports), module2.exports;
        }
        function getCjsExportFromNamespace(n) {
          return n && n["default"] || n;
        }
        var colorName = {
          "aliceblue": [240, 248, 255],
          "antiquewhite": [250, 235, 215],
          "aqua": [0, 255, 255],
          "aquamarine": [127, 255, 212],
          "azure": [240, 255, 255],
          "beige": [245, 245, 220],
          "bisque": [255, 228, 196],
          "black": [0, 0, 0],
          "blanchedalmond": [255, 235, 205],
          "blue": [0, 0, 255],
          "blueviolet": [138, 43, 226],
          "brown": [165, 42, 42],
          "burlywood": [222, 184, 135],
          "cadetblue": [95, 158, 160],
          "chartreuse": [127, 255, 0],
          "chocolate": [210, 105, 30],
          "coral": [255, 127, 80],
          "cornflowerblue": [100, 149, 237],
          "cornsilk": [255, 248, 220],
          "crimson": [220, 20, 60],
          "cyan": [0, 255, 255],
          "darkblue": [0, 0, 139],
          "darkcyan": [0, 139, 139],
          "darkgoldenrod": [184, 134, 11],
          "darkgray": [169, 169, 169],
          "darkgreen": [0, 100, 0],
          "darkgrey": [169, 169, 169],
          "darkkhaki": [189, 183, 107],
          "darkmagenta": [139, 0, 139],
          "darkolivegreen": [85, 107, 47],
          "darkorange": [255, 140, 0],
          "darkorchid": [153, 50, 204],
          "darkred": [139, 0, 0],
          "darksalmon": [233, 150, 122],
          "darkseagreen": [143, 188, 143],
          "darkslateblue": [72, 61, 139],
          "darkslategray": [47, 79, 79],
          "darkslategrey": [47, 79, 79],
          "darkturquoise": [0, 206, 209],
          "darkviolet": [148, 0, 211],
          "deeppink": [255, 20, 147],
          "deepskyblue": [0, 191, 255],
          "dimgray": [105, 105, 105],
          "dimgrey": [105, 105, 105],
          "dodgerblue": [30, 144, 255],
          "firebrick": [178, 34, 34],
          "floralwhite": [255, 250, 240],
          "forestgreen": [34, 139, 34],
          "fuchsia": [255, 0, 255],
          "gainsboro": [220, 220, 220],
          "ghostwhite": [248, 248, 255],
          "gold": [255, 215, 0],
          "goldenrod": [218, 165, 32],
          "gray": [128, 128, 128],
          "green": [0, 128, 0],
          "greenyellow": [173, 255, 47],
          "grey": [128, 128, 128],
          "honeydew": [240, 255, 240],
          "hotpink": [255, 105, 180],
          "indianred": [205, 92, 92],
          "indigo": [75, 0, 130],
          "ivory": [255, 255, 240],
          "khaki": [240, 230, 140],
          "lavender": [230, 230, 250],
          "lavenderblush": [255, 240, 245],
          "lawngreen": [124, 252, 0],
          "lemonchiffon": [255, 250, 205],
          "lightblue": [173, 216, 230],
          "lightcoral": [240, 128, 128],
          "lightcyan": [224, 255, 255],
          "lightgoldenrodyellow": [250, 250, 210],
          "lightgray": [211, 211, 211],
          "lightgreen": [144, 238, 144],
          "lightgrey": [211, 211, 211],
          "lightpink": [255, 182, 193],
          "lightsalmon": [255, 160, 122],
          "lightseagreen": [32, 178, 170],
          "lightskyblue": [135, 206, 250],
          "lightslategray": [119, 136, 153],
          "lightslategrey": [119, 136, 153],
          "lightsteelblue": [176, 196, 222],
          "lightyellow": [255, 255, 224],
          "lime": [0, 255, 0],
          "limegreen": [50, 205, 50],
          "linen": [250, 240, 230],
          "magenta": [255, 0, 255],
          "maroon": [128, 0, 0],
          "mediumaquamarine": [102, 205, 170],
          "mediumblue": [0, 0, 205],
          "mediumorchid": [186, 85, 211],
          "mediumpurple": [147, 112, 219],
          "mediumseagreen": [60, 179, 113],
          "mediumslateblue": [123, 104, 238],
          "mediumspringgreen": [0, 250, 154],
          "mediumturquoise": [72, 209, 204],
          "mediumvioletred": [199, 21, 133],
          "midnightblue": [25, 25, 112],
          "mintcream": [245, 255, 250],
          "mistyrose": [255, 228, 225],
          "moccasin": [255, 228, 181],
          "navajowhite": [255, 222, 173],
          "navy": [0, 0, 128],
          "oldlace": [253, 245, 230],
          "olive": [128, 128, 0],
          "olivedrab": [107, 142, 35],
          "orange": [255, 165, 0],
          "orangered": [255, 69, 0],
          "orchid": [218, 112, 214],
          "palegoldenrod": [238, 232, 170],
          "palegreen": [152, 251, 152],
          "paleturquoise": [175, 238, 238],
          "palevioletred": [219, 112, 147],
          "papayawhip": [255, 239, 213],
          "peachpuff": [255, 218, 185],
          "peru": [205, 133, 63],
          "pink": [255, 192, 203],
          "plum": [221, 160, 221],
          "powderblue": [176, 224, 230],
          "purple": [128, 0, 128],
          "rebeccapurple": [102, 51, 153],
          "red": [255, 0, 0],
          "rosybrown": [188, 143, 143],
          "royalblue": [65, 105, 225],
          "saddlebrown": [139, 69, 19],
          "salmon": [250, 128, 114],
          "sandybrown": [244, 164, 96],
          "seagreen": [46, 139, 87],
          "seashell": [255, 245, 238],
          "sienna": [160, 82, 45],
          "silver": [192, 192, 192],
          "skyblue": [135, 206, 235],
          "slateblue": [106, 90, 205],
          "slategray": [112, 128, 144],
          "slategrey": [112, 128, 144],
          "snow": [255, 250, 250],
          "springgreen": [0, 255, 127],
          "steelblue": [70, 130, 180],
          "tan": [210, 180, 140],
          "teal": [0, 128, 128],
          "thistle": [216, 191, 216],
          "tomato": [255, 99, 71],
          "turquoise": [64, 224, 208],
          "violet": [238, 130, 238],
          "wheat": [245, 222, 179],
          "white": [255, 255, 255],
          "whitesmoke": [245, 245, 245],
          "yellow": [255, 255, 0],
          "yellowgreen": [154, 205, 50]
        };
        var conversions = createCommonjsModule(function(module2) {
          var reverseKeywords = {};
          for (var key in colorName) {
            if (colorName.hasOwnProperty(key)) {
              reverseKeywords[colorName[key]] = key;
            }
          }
          var convert2 = module2.exports = {
            rgb: { channels: 3, labels: "rgb" },
            hsl: { channels: 3, labels: "hsl" },
            hsv: { channels: 3, labels: "hsv" },
            hwb: { channels: 3, labels: "hwb" },
            cmyk: { channels: 4, labels: "cmyk" },
            xyz: { channels: 3, labels: "xyz" },
            lab: { channels: 3, labels: "lab" },
            lch: { channels: 3, labels: "lch" },
            hex: { channels: 1, labels: ["hex"] },
            keyword: { channels: 1, labels: ["keyword"] },
            ansi16: { channels: 1, labels: ["ansi16"] },
            ansi256: { channels: 1, labels: ["ansi256"] },
            hcg: { channels: 3, labels: ["h", "c", "g"] },
            apple: { channels: 3, labels: ["r16", "g16", "b16"] },
            gray: { channels: 1, labels: ["gray"] }
          };
          for (var model in convert2) {
            if (convert2.hasOwnProperty(model)) {
              if (!("channels" in convert2[model])) {
                throw new Error("missing channels property: " + model);
              }
              if (!("labels" in convert2[model])) {
                throw new Error("missing channel labels property: " + model);
              }
              if (convert2[model].labels.length !== convert2[model].channels) {
                throw new Error("channel and label counts mismatch: " + model);
              }
              var channels = convert2[model].channels;
              var labels = convert2[model].labels;
              delete convert2[model].channels;
              delete convert2[model].labels;
              Object.defineProperty(convert2[model], "channels", { value: channels });
              Object.defineProperty(convert2[model], "labels", { value: labels });
            }
          }
          convert2.rgb.hsl = function(rgb) {
            var r = rgb[0] / 255;
            var g = rgb[1] / 255;
            var b = rgb[2] / 255;
            var min = Math.min(r, g, b);
            var max = Math.max(r, g, b);
            var delta = max - min;
            var h;
            var s;
            var l;
            if (max === min) {
              h = 0;
            } else if (r === max) {
              h = (g - b) / delta;
            } else if (g === max) {
              h = 2 + (b - r) / delta;
            } else if (b === max) {
              h = 4 + (r - g) / delta;
            }
            h = Math.min(h * 60, 360);
            if (h < 0) {
              h += 360;
            }
            l = (min + max) / 2;
            if (max === min) {
              s = 0;
            } else if (l <= 0.5) {
              s = delta / (max + min);
            } else {
              s = delta / (2 - max - min);
            }
            return [h, s * 100, l * 100];
          };
          convert2.rgb.hsv = function(rgb) {
            var rdif;
            var gdif;
            var bdif;
            var h;
            var s;
            var r = rgb[0] / 255;
            var g = rgb[1] / 255;
            var b = rgb[2] / 255;
            var v = Math.max(r, g, b);
            var diff = v - Math.min(r, g, b);
            var diffc = function(c) {
              return (v - c) / 6 / diff + 1 / 2;
            };
            if (diff === 0) {
              h = s = 0;
            } else {
              s = diff / v;
              rdif = diffc(r);
              gdif = diffc(g);
              bdif = diffc(b);
              if (r === v) {
                h = bdif - gdif;
              } else if (g === v) {
                h = 1 / 3 + rdif - bdif;
              } else if (b === v) {
                h = 2 / 3 + gdif - rdif;
              }
              if (h < 0) {
                h += 1;
              } else if (h > 1) {
                h -= 1;
              }
            }
            return [
              h * 360,
              s * 100,
              v * 100
            ];
          };
          convert2.rgb.hwb = function(rgb) {
            var r = rgb[0];
            var g = rgb[1];
            var b = rgb[2];
            var h = convert2.rgb.hsl(rgb)[0];
            var w = 1 / 255 * Math.min(r, Math.min(g, b));
            b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
            return [h, w * 100, b * 100];
          };
          convert2.rgb.cmyk = function(rgb) {
            var r = rgb[0] / 255;
            var g = rgb[1] / 255;
            var b = rgb[2] / 255;
            var c;
            var m;
            var y;
            var k2;
            k2 = Math.min(1 - r, 1 - g, 1 - b);
            c = (1 - r - k2) / (1 - k2) || 0;
            m = (1 - g - k2) / (1 - k2) || 0;
            y = (1 - b - k2) / (1 - k2) || 0;
            return [c * 100, m * 100, y * 100, k2 * 100];
          };
          function comparativeDistance(x, y) {
            return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
          }
          convert2.rgb.keyword = function(rgb) {
            var reversed = reverseKeywords[rgb];
            if (reversed) {
              return reversed;
            }
            var currentClosestDistance = Infinity;
            var currentClosestKeyword;
            for (var keyword2 in colorName) {
              if (colorName.hasOwnProperty(keyword2)) {
                var value = colorName[keyword2];
                var distance = comparativeDistance(rgb, value);
                if (distance < currentClosestDistance) {
                  currentClosestDistance = distance;
                  currentClosestKeyword = keyword2;
                }
              }
            }
            return currentClosestKeyword;
          };
          convert2.keyword.rgb = function(keyword2) {
            return colorName[keyword2];
          };
          convert2.rgb.xyz = function(rgb) {
            var r = rgb[0] / 255;
            var g = rgb[1] / 255;
            var b = rgb[2] / 255;
            r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
            g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
            b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
            var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
            var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
            var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
            return [x * 100, y * 100, z * 100];
          };
          convert2.rgb.lab = function(rgb) {
            var xyz = convert2.rgb.xyz(rgb);
            var x = xyz[0];
            var y = xyz[1];
            var z = xyz[2];
            var l;
            var a;
            var b;
            x /= 95.047;
            y /= 100;
            z /= 108.883;
            x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
            y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
            z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
            l = 116 * y - 16;
            a = 500 * (x - y);
            b = 200 * (y - z);
            return [l, a, b];
          };
          convert2.hsl.rgb = function(hsl) {
            var h = hsl[0] / 360;
            var s = hsl[1] / 100;
            var l = hsl[2] / 100;
            var t1;
            var t2;
            var t3;
            var rgb;
            var val;
            if (s === 0) {
              val = l * 255;
              return [val, val, val];
            }
            if (l < 0.5) {
              t2 = l * (1 + s);
            } else {
              t2 = l + s - l * s;
            }
            t1 = 2 * l - t2;
            rgb = [0, 0, 0];
            for (var i = 0; i < 3; i++) {
              t3 = h + 1 / 3 * -(i - 1);
              if (t3 < 0) {
                t3++;
              }
              if (t3 > 1) {
                t3--;
              }
              if (6 * t3 < 1) {
                val = t1 + (t2 - t1) * 6 * t3;
              } else if (2 * t3 < 1) {
                val = t2;
              } else if (3 * t3 < 2) {
                val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
              } else {
                val = t1;
              }
              rgb[i] = val * 255;
            }
            return rgb;
          };
          convert2.hsl.hsv = function(hsl) {
            var h = hsl[0];
            var s = hsl[1] / 100;
            var l = hsl[2] / 100;
            var smin = s;
            var lmin = Math.max(l, 0.01);
            var sv;
            var v;
            l *= 2;
            s *= l <= 1 ? l : 2 - l;
            smin *= lmin <= 1 ? lmin : 2 - lmin;
            v = (l + s) / 2;
            sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
            return [h, sv * 100, v * 100];
          };
          convert2.hsv.rgb = function(hsv) {
            var h = hsv[0] / 60;
            var s = hsv[1] / 100;
            var v = hsv[2] / 100;
            var hi = Math.floor(h) % 6;
            var f = h - Math.floor(h);
            var p = 255 * v * (1 - s);
            var q = 255 * v * (1 - s * f);
            var t = 255 * v * (1 - s * (1 - f));
            v *= 255;
            switch (hi) {
              case 0:
                return [v, t, p];
              case 1:
                return [q, v, p];
              case 2:
                return [p, v, t];
              case 3:
                return [p, q, v];
              case 4:
                return [t, p, v];
              case 5:
                return [v, p, q];
            }
          };
          convert2.hsv.hsl = function(hsv) {
            var h = hsv[0];
            var s = hsv[1] / 100;
            var v = hsv[2] / 100;
            var vmin = Math.max(v, 0.01);
            var lmin;
            var sl;
            var l;
            l = (2 - s) * v;
            lmin = (2 - s) * vmin;
            sl = s * vmin;
            sl /= lmin <= 1 ? lmin : 2 - lmin;
            sl = sl || 0;
            l /= 2;
            return [h, sl * 100, l * 100];
          };
          convert2.hwb.rgb = function(hwb) {
            var h = hwb[0] / 360;
            var wh = hwb[1] / 100;
            var bl = hwb[2] / 100;
            var ratio = wh + bl;
            var i;
            var v;
            var f;
            var n;
            if (ratio > 1) {
              wh /= ratio;
              bl /= ratio;
            }
            i = Math.floor(6 * h);
            v = 1 - bl;
            f = 6 * h - i;
            if ((i & 1) !== 0) {
              f = 1 - f;
            }
            n = wh + f * (v - wh);
            var r;
            var g;
            var b;
            switch (i) {
              default:
              case 6:
              case 0:
                r = v;
                g = n;
                b = wh;
                break;
              case 1:
                r = n;
                g = v;
                b = wh;
                break;
              case 2:
                r = wh;
                g = v;
                b = n;
                break;
              case 3:
                r = wh;
                g = n;
                b = v;
                break;
              case 4:
                r = n;
                g = wh;
                b = v;
                break;
              case 5:
                r = v;
                g = wh;
                b = n;
                break;
            }
            return [r * 255, g * 255, b * 255];
          };
          convert2.cmyk.rgb = function(cmyk) {
            var c = cmyk[0] / 100;
            var m = cmyk[1] / 100;
            var y = cmyk[2] / 100;
            var k2 = cmyk[3] / 100;
            var r;
            var g;
            var b;
            r = 1 - Math.min(1, c * (1 - k2) + k2);
            g = 1 - Math.min(1, m * (1 - k2) + k2);
            b = 1 - Math.min(1, y * (1 - k2) + k2);
            return [r * 255, g * 255, b * 255];
          };
          convert2.xyz.rgb = function(xyz) {
            var x = xyz[0] / 100;
            var y = xyz[1] / 100;
            var z = xyz[2] / 100;
            var r;
            var g;
            var b;
            r = x * 3.2406 + y * -1.5372 + z * -0.4986;
            g = x * -0.9689 + y * 1.8758 + z * 0.0415;
            b = x * 0.0557 + y * -0.204 + z * 1.057;
            r = r > 31308e-7 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r * 12.92;
            g = g > 31308e-7 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92;
            b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92;
            r = Math.min(Math.max(0, r), 1);
            g = Math.min(Math.max(0, g), 1);
            b = Math.min(Math.max(0, b), 1);
            return [r * 255, g * 255, b * 255];
          };
          convert2.xyz.lab = function(xyz) {
            var x = xyz[0];
            var y = xyz[1];
            var z = xyz[2];
            var l;
            var a;
            var b;
            x /= 95.047;
            y /= 100;
            z /= 108.883;
            x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
            y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
            z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
            l = 116 * y - 16;
            a = 500 * (x - y);
            b = 200 * (y - z);
            return [l, a, b];
          };
          convert2.lab.xyz = function(lab) {
            var l = lab[0];
            var a = lab[1];
            var b = lab[2];
            var x;
            var y;
            var z;
            y = (l + 16) / 116;
            x = a / 500 + y;
            z = y - b / 200;
            var y2 = Math.pow(y, 3);
            var x2 = Math.pow(x, 3);
            var z2 = Math.pow(z, 3);
            y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
            x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
            z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
            x *= 95.047;
            y *= 100;
            z *= 108.883;
            return [x, y, z];
          };
          convert2.lab.lch = function(lab) {
            var l = lab[0];
            var a = lab[1];
            var b = lab[2];
            var hr;
            var h;
            var c;
            hr = Math.atan2(b, a);
            h = hr * 360 / 2 / Math.PI;
            if (h < 0) {
              h += 360;
            }
            c = Math.sqrt(a * a + b * b);
            return [l, c, h];
          };
          convert2.lch.lab = function(lch) {
            var l = lch[0];
            var c = lch[1];
            var h = lch[2];
            var a;
            var b;
            var hr;
            hr = h / 360 * 2 * Math.PI;
            a = c * Math.cos(hr);
            b = c * Math.sin(hr);
            return [l, a, b];
          };
          convert2.rgb.ansi16 = function(args) {
            var r = args[0];
            var g = args[1];
            var b = args[2];
            var value = 1 in arguments ? arguments[1] : convert2.rgb.hsv(args)[2];
            value = Math.round(value / 50);
            if (value === 0) {
              return 30;
            }
            var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
            if (value === 2) {
              ansi += 60;
            }
            return ansi;
          };
          convert2.hsv.ansi16 = function(args) {
            return convert2.rgb.ansi16(convert2.hsv.rgb(args), args[2]);
          };
          convert2.rgb.ansi256 = function(args) {
            var r = args[0];
            var g = args[1];
            var b = args[2];
            if (r === g && g === b) {
              if (r < 8) {
                return 16;
              }
              if (r > 248) {
                return 231;
              }
              return Math.round((r - 8) / 247 * 24) + 232;
            }
            var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
            return ansi;
          };
          convert2.ansi16.rgb = function(args) {
            var color = args % 10;
            if (color === 0 || color === 7) {
              if (args > 50) {
                color += 3.5;
              }
              color = color / 10.5 * 255;
              return [color, color, color];
            }
            var mult = (~~(args > 50) + 1) * 0.5;
            var r = (color & 1) * mult * 255;
            var g = (color >> 1 & 1) * mult * 255;
            var b = (color >> 2 & 1) * mult * 255;
            return [r, g, b];
          };
          convert2.ansi256.rgb = function(args) {
            if (args >= 232) {
              var c = (args - 232) * 10 + 8;
              return [c, c, c];
            }
            args -= 16;
            var rem;
            var r = Math.floor(args / 36) / 5 * 255;
            var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
            var b = rem % 6 / 5 * 255;
            return [r, g, b];
          };
          convert2.rgb.hex = function(args) {
            var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
            var string = integer.toString(16).toUpperCase();
            return "000000".substring(string.length) + string;
          };
          convert2.hex.rgb = function(args) {
            var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
            if (!match) {
              return [0, 0, 0];
            }
            var colorString2 = match[0];
            if (match[0].length === 3) {
              colorString2 = colorString2.split("").map(function(char) {
                return char + char;
              }).join("");
            }
            var integer = parseInt(colorString2, 16);
            var r = integer >> 16 & 255;
            var g = integer >> 8 & 255;
            var b = integer & 255;
            return [r, g, b];
          };
          convert2.rgb.hcg = function(rgb) {
            var r = rgb[0] / 255;
            var g = rgb[1] / 255;
            var b = rgb[2] / 255;
            var max = Math.max(Math.max(r, g), b);
            var min = Math.min(Math.min(r, g), b);
            var chroma = max - min;
            var grayscale;
            var hue;
            if (chroma < 1) {
              grayscale = min / (1 - chroma);
            } else {
              grayscale = 0;
            }
            if (chroma <= 0) {
              hue = 0;
            } else if (max === r) {
              hue = (g - b) / chroma % 6;
            } else if (max === g) {
              hue = 2 + (b - r) / chroma;
            } else {
              hue = 4 + (r - g) / chroma + 4;
            }
            hue /= 6;
            hue %= 1;
            return [hue * 360, chroma * 100, grayscale * 100];
          };
          convert2.hsl.hcg = function(hsl) {
            var s = hsl[1] / 100;
            var l = hsl[2] / 100;
            var c = 1;
            var f = 0;
            if (l < 0.5) {
              c = 2 * s * l;
            } else {
              c = 2 * s * (1 - l);
            }
            if (c < 1) {
              f = (l - 0.5 * c) / (1 - c);
            }
            return [hsl[0], c * 100, f * 100];
          };
          convert2.hsv.hcg = function(hsv) {
            var s = hsv[1] / 100;
            var v = hsv[2] / 100;
            var c = s * v;
            var f = 0;
            if (c < 1) {
              f = (v - c) / (1 - c);
            }
            return [hsv[0], c * 100, f * 100];
          };
          convert2.hcg.rgb = function(hcg) {
            var h = hcg[0] / 360;
            var c = hcg[1] / 100;
            var g = hcg[2] / 100;
            if (c === 0) {
              return [g * 255, g * 255, g * 255];
            }
            var pure = [0, 0, 0];
            var hi = h % 1 * 6;
            var v = hi % 1;
            var w = 1 - v;
            var mg = 0;
            switch (Math.floor(hi)) {
              case 0:
                pure[0] = 1;
                pure[1] = v;
                pure[2] = 0;
                break;
              case 1:
                pure[0] = w;
                pure[1] = 1;
                pure[2] = 0;
                break;
              case 2:
                pure[0] = 0;
                pure[1] = 1;
                pure[2] = v;
                break;
              case 3:
                pure[0] = 0;
                pure[1] = w;
                pure[2] = 1;
                break;
              case 4:
                pure[0] = v;
                pure[1] = 0;
                pure[2] = 1;
                break;
              default:
                pure[0] = 1;
                pure[1] = 0;
                pure[2] = w;
            }
            mg = (1 - c) * g;
            return [
              (c * pure[0] + mg) * 255,
              (c * pure[1] + mg) * 255,
              (c * pure[2] + mg) * 255
            ];
          };
          convert2.hcg.hsv = function(hcg) {
            var c = hcg[1] / 100;
            var g = hcg[2] / 100;
            var v = c + g * (1 - c);
            var f = 0;
            if (v > 0) {
              f = c / v;
            }
            return [hcg[0], f * 100, v * 100];
          };
          convert2.hcg.hsl = function(hcg) {
            var c = hcg[1] / 100;
            var g = hcg[2] / 100;
            var l = g * (1 - c) + 0.5 * c;
            var s = 0;
            if (l > 0 && l < 0.5) {
              s = c / (2 * l);
            } else if (l >= 0.5 && l < 1) {
              s = c / (2 * (1 - l));
            }
            return [hcg[0], s * 100, l * 100];
          };
          convert2.hcg.hwb = function(hcg) {
            var c = hcg[1] / 100;
            var g = hcg[2] / 100;
            var v = c + g * (1 - c);
            return [hcg[0], (v - c) * 100, (1 - v) * 100];
          };
          convert2.hwb.hcg = function(hwb) {
            var w = hwb[1] / 100;
            var b = hwb[2] / 100;
            var v = 1 - b;
            var c = v - w;
            var g = 0;
            if (c < 1) {
              g = (v - c) / (1 - c);
            }
            return [hwb[0], c * 100, g * 100];
          };
          convert2.apple.rgb = function(apple) {
            return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
          };
          convert2.rgb.apple = function(rgb) {
            return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
          };
          convert2.gray.rgb = function(args) {
            return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
          };
          convert2.gray.hsl = convert2.gray.hsv = function(args) {
            return [0, 0, args[0]];
          };
          convert2.gray.hwb = function(gray) {
            return [0, 100, gray[0]];
          };
          convert2.gray.cmyk = function(gray) {
            return [0, 0, 0, gray[0]];
          };
          convert2.gray.lab = function(gray) {
            return [gray[0], 0, 0];
          };
          convert2.gray.hex = function(gray) {
            var val = Math.round(gray[0] / 100 * 255) & 255;
            var integer = (val << 16) + (val << 8) + val;
            var string = integer.toString(16).toUpperCase();
            return "000000".substring(string.length) + string;
          };
          convert2.rgb.gray = function(rgb) {
            var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
            return [val / 255 * 100];
          };
        });
        var conversions_1 = conversions.rgb;
        var conversions_2 = conversions.hsl;
        var conversions_3 = conversions.hsv;
        var conversions_4 = conversions.hwb;
        var conversions_5 = conversions.cmyk;
        var conversions_6 = conversions.xyz;
        var conversions_7 = conversions.lab;
        var conversions_8 = conversions.lch;
        var conversions_9 = conversions.hex;
        var conversions_10 = conversions.keyword;
        var conversions_11 = conversions.ansi16;
        var conversions_12 = conversions.ansi256;
        var conversions_13 = conversions.hcg;
        var conversions_14 = conversions.apple;
        var conversions_15 = conversions.gray;
        function buildGraph() {
          var graph = {};
          var models2 = Object.keys(conversions);
          for (var len = models2.length, i = 0; i < len; i++) {
            graph[models2[i]] = {
              distance: -1,
              parent: null
            };
          }
          return graph;
        }
        function deriveBFS(fromModel) {
          var graph = buildGraph();
          var queue = [fromModel];
          graph[fromModel].distance = 0;
          while (queue.length) {
            var current = queue.pop();
            var adjacents = Object.keys(conversions[current]);
            for (var len = adjacents.length, i = 0; i < len; i++) {
              var adjacent = adjacents[i];
              var node = graph[adjacent];
              if (node.distance === -1) {
                node.distance = graph[current].distance + 1;
                node.parent = current;
                queue.unshift(adjacent);
              }
            }
          }
          return graph;
        }
        function link(from, to) {
          return function(args) {
            return to(from(args));
          };
        }
        function wrapConversion(toModel, graph) {
          var path = [graph[toModel].parent, toModel];
          var fn = conversions[graph[toModel].parent][toModel];
          var cur = graph[toModel].parent;
          while (graph[cur].parent) {
            path.unshift(graph[cur].parent);
            fn = link(conversions[graph[cur].parent][cur], fn);
            cur = graph[cur].parent;
          }
          fn.conversion = path;
          return fn;
        }
        var route = function(fromModel) {
          var graph = deriveBFS(fromModel);
          var conversion = {};
          var models2 = Object.keys(graph);
          for (var len = models2.length, i = 0; i < len; i++) {
            var toModel = models2[i];
            var node = graph[toModel];
            if (node.parent === null) {
              continue;
            }
            conversion[toModel] = wrapConversion(toModel, graph);
          }
          return conversion;
        };
        var convert = {};
        var models = Object.keys(conversions);
        function wrapRaw(fn) {
          var wrappedFn = function(args) {
            if (args === void 0 || args === null) {
              return args;
            }
            if (arguments.length > 1) {
              args = Array.prototype.slice.call(arguments);
            }
            return fn(args);
          };
          if ("conversion" in fn) {
            wrappedFn.conversion = fn.conversion;
          }
          return wrappedFn;
        }
        function wrapRounded(fn) {
          var wrappedFn = function(args) {
            if (args === void 0 || args === null) {
              return args;
            }
            if (arguments.length > 1) {
              args = Array.prototype.slice.call(arguments);
            }
            var result = fn(args);
            if (typeof result === "object") {
              for (var len = result.length, i = 0; i < len; i++) {
                result[i] = Math.round(result[i]);
              }
            }
            return result;
          };
          if ("conversion" in fn) {
            wrappedFn.conversion = fn.conversion;
          }
          return wrappedFn;
        }
        models.forEach(function(fromModel) {
          convert[fromModel] = {};
          Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
          Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
          var routes = route(fromModel);
          var routeModels = Object.keys(routes);
          routeModels.forEach(function(toModel) {
            var fn = routes[toModel];
            convert[fromModel][toModel] = wrapRounded(fn);
            convert[fromModel][toModel].raw = wrapRaw(fn);
          });
        });
        var colorConvert = convert;
        var colorName$1 = {
          "aliceblue": [240, 248, 255],
          "antiquewhite": [250, 235, 215],
          "aqua": [0, 255, 255],
          "aquamarine": [127, 255, 212],
          "azure": [240, 255, 255],
          "beige": [245, 245, 220],
          "bisque": [255, 228, 196],
          "black": [0, 0, 0],
          "blanchedalmond": [255, 235, 205],
          "blue": [0, 0, 255],
          "blueviolet": [138, 43, 226],
          "brown": [165, 42, 42],
          "burlywood": [222, 184, 135],
          "cadetblue": [95, 158, 160],
          "chartreuse": [127, 255, 0],
          "chocolate": [210, 105, 30],
          "coral": [255, 127, 80],
          "cornflowerblue": [100, 149, 237],
          "cornsilk": [255, 248, 220],
          "crimson": [220, 20, 60],
          "cyan": [0, 255, 255],
          "darkblue": [0, 0, 139],
          "darkcyan": [0, 139, 139],
          "darkgoldenrod": [184, 134, 11],
          "darkgray": [169, 169, 169],
          "darkgreen": [0, 100, 0],
          "darkgrey": [169, 169, 169],
          "darkkhaki": [189, 183, 107],
          "darkmagenta": [139, 0, 139],
          "darkolivegreen": [85, 107, 47],
          "darkorange": [255, 140, 0],
          "darkorchid": [153, 50, 204],
          "darkred": [139, 0, 0],
          "darksalmon": [233, 150, 122],
          "darkseagreen": [143, 188, 143],
          "darkslateblue": [72, 61, 139],
          "darkslategray": [47, 79, 79],
          "darkslategrey": [47, 79, 79],
          "darkturquoise": [0, 206, 209],
          "darkviolet": [148, 0, 211],
          "deeppink": [255, 20, 147],
          "deepskyblue": [0, 191, 255],
          "dimgray": [105, 105, 105],
          "dimgrey": [105, 105, 105],
          "dodgerblue": [30, 144, 255],
          "firebrick": [178, 34, 34],
          "floralwhite": [255, 250, 240],
          "forestgreen": [34, 139, 34],
          "fuchsia": [255, 0, 255],
          "gainsboro": [220, 220, 220],
          "ghostwhite": [248, 248, 255],
          "gold": [255, 215, 0],
          "goldenrod": [218, 165, 32],
          "gray": [128, 128, 128],
          "green": [0, 128, 0],
          "greenyellow": [173, 255, 47],
          "grey": [128, 128, 128],
          "honeydew": [240, 255, 240],
          "hotpink": [255, 105, 180],
          "indianred": [205, 92, 92],
          "indigo": [75, 0, 130],
          "ivory": [255, 255, 240],
          "khaki": [240, 230, 140],
          "lavender": [230, 230, 250],
          "lavenderblush": [255, 240, 245],
          "lawngreen": [124, 252, 0],
          "lemonchiffon": [255, 250, 205],
          "lightblue": [173, 216, 230],
          "lightcoral": [240, 128, 128],
          "lightcyan": [224, 255, 255],
          "lightgoldenrodyellow": [250, 250, 210],
          "lightgray": [211, 211, 211],
          "lightgreen": [144, 238, 144],
          "lightgrey": [211, 211, 211],
          "lightpink": [255, 182, 193],
          "lightsalmon": [255, 160, 122],
          "lightseagreen": [32, 178, 170],
          "lightskyblue": [135, 206, 250],
          "lightslategray": [119, 136, 153],
          "lightslategrey": [119, 136, 153],
          "lightsteelblue": [176, 196, 222],
          "lightyellow": [255, 255, 224],
          "lime": [0, 255, 0],
          "limegreen": [50, 205, 50],
          "linen": [250, 240, 230],
          "magenta": [255, 0, 255],
          "maroon": [128, 0, 0],
          "mediumaquamarine": [102, 205, 170],
          "mediumblue": [0, 0, 205],
          "mediumorchid": [186, 85, 211],
          "mediumpurple": [147, 112, 219],
          "mediumseagreen": [60, 179, 113],
          "mediumslateblue": [123, 104, 238],
          "mediumspringgreen": [0, 250, 154],
          "mediumturquoise": [72, 209, 204],
          "mediumvioletred": [199, 21, 133],
          "midnightblue": [25, 25, 112],
          "mintcream": [245, 255, 250],
          "mistyrose": [255, 228, 225],
          "moccasin": [255, 228, 181],
          "navajowhite": [255, 222, 173],
          "navy": [0, 0, 128],
          "oldlace": [253, 245, 230],
          "olive": [128, 128, 0],
          "olivedrab": [107, 142, 35],
          "orange": [255, 165, 0],
          "orangered": [255, 69, 0],
          "orchid": [218, 112, 214],
          "palegoldenrod": [238, 232, 170],
          "palegreen": [152, 251, 152],
          "paleturquoise": [175, 238, 238],
          "palevioletred": [219, 112, 147],
          "papayawhip": [255, 239, 213],
          "peachpuff": [255, 218, 185],
          "peru": [205, 133, 63],
          "pink": [255, 192, 203],
          "plum": [221, 160, 221],
          "powderblue": [176, 224, 230],
          "purple": [128, 0, 128],
          "rebeccapurple": [102, 51, 153],
          "red": [255, 0, 0],
          "rosybrown": [188, 143, 143],
          "royalblue": [65, 105, 225],
          "saddlebrown": [139, 69, 19],
          "salmon": [250, 128, 114],
          "sandybrown": [244, 164, 96],
          "seagreen": [46, 139, 87],
          "seashell": [255, 245, 238],
          "sienna": [160, 82, 45],
          "silver": [192, 192, 192],
          "skyblue": [135, 206, 235],
          "slateblue": [106, 90, 205],
          "slategray": [112, 128, 144],
          "slategrey": [112, 128, 144],
          "snow": [255, 250, 250],
          "springgreen": [0, 255, 127],
          "steelblue": [70, 130, 180],
          "tan": [210, 180, 140],
          "teal": [0, 128, 128],
          "thistle": [216, 191, 216],
          "tomato": [255, 99, 71],
          "turquoise": [64, 224, 208],
          "violet": [238, 130, 238],
          "wheat": [245, 222, 179],
          "white": [255, 255, 255],
          "whitesmoke": [245, 245, 245],
          "yellow": [255, 255, 0],
          "yellowgreen": [154, 205, 50]
        };
        var colorString = {
          getRgba,
          getHsla,
          getRgb,
          getHsl,
          getHwb,
          getAlpha,
          hexString,
          rgbString,
          rgbaString,
          percentString,
          percentaString,
          hslString,
          hslaString,
          hwbString,
          keyword
        };
        function getRgba(string) {
          if (!string) {
            return;
          }
          var abbr = /^#([a-fA-F0-9]{3,4})$/i, hex = /^#([a-fA-F0-9]{6}([a-fA-F0-9]{2})?)$/i, rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i, per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i, keyword2 = /(\w+)/;
          var rgb = [0, 0, 0], a = 1, match = string.match(abbr), hexAlpha = "";
          if (match) {
            match = match[1];
            hexAlpha = match[3];
            for (var i = 0; i < rgb.length; i++) {
              rgb[i] = parseInt(match[i] + match[i], 16);
            }
            if (hexAlpha) {
              a = Math.round(parseInt(hexAlpha + hexAlpha, 16) / 255 * 100) / 100;
            }
          } else if (match = string.match(hex)) {
            hexAlpha = match[2];
            match = match[1];
            for (var i = 0; i < rgb.length; i++) {
              rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);
            }
            if (hexAlpha) {
              a = Math.round(parseInt(hexAlpha, 16) / 255 * 100) / 100;
            }
          } else if (match = string.match(rgba)) {
            for (var i = 0; i < rgb.length; i++) {
              rgb[i] = parseInt(match[i + 1]);
            }
            a = parseFloat(match[4]);
          } else if (match = string.match(per)) {
            for (var i = 0; i < rgb.length; i++) {
              rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
            }
            a = parseFloat(match[4]);
          } else if (match = string.match(keyword2)) {
            if (match[1] == "transparent") {
              return [0, 0, 0, 0];
            }
            rgb = colorName$1[match[1]];
            if (!rgb) {
              return;
            }
          }
          for (var i = 0; i < rgb.length; i++) {
            rgb[i] = scale(rgb[i], 0, 255);
          }
          if (!a && a != 0) {
            a = 1;
          } else {
            a = scale(a, 0, 1);
          }
          rgb[3] = a;
          return rgb;
        }
        function getHsla(string) {
          if (!string) {
            return;
          }
          var hsl = /^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
          var match = string.match(hsl);
          if (match) {
            var alpha = parseFloat(match[4]);
            var h = scale(parseInt(match[1]), 0, 360), s = scale(parseFloat(match[2]), 0, 100), l = scale(parseFloat(match[3]), 0, 100), a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
            return [h, s, l, a];
          }
        }
        function getHwb(string) {
          if (!string) {
            return;
          }
          var hwb = /^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
          var match = string.match(hwb);
          if (match) {
            var alpha = parseFloat(match[4]);
            var h = scale(parseInt(match[1]), 0, 360), w = scale(parseFloat(match[2]), 0, 100), b = scale(parseFloat(match[3]), 0, 100), a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
            return [h, w, b, a];
          }
        }
        function getRgb(string) {
          var rgba = getRgba(string);
          return rgba && rgba.slice(0, 3);
        }
        function getHsl(string) {
          var hsla = getHsla(string);
          return hsla && hsla.slice(0, 3);
        }
        function getAlpha(string) {
          var vals = getRgba(string);
          if (vals) {
            return vals[3];
          } else if (vals = getHsla(string)) {
            return vals[3];
          } else if (vals = getHwb(string)) {
            return vals[3];
          }
        }
        function hexString(rgba, a) {
          var a = a !== void 0 && rgba.length === 3 ? a : rgba[3];
          return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (a >= 0 && a < 1 ? hexDouble(Math.round(a * 255)) : "");
        }
        function rgbString(rgba, alpha) {
          if (alpha < 1 || rgba[3] && rgba[3] < 1) {
            return rgbaString(rgba, alpha);
          }
          return "rgb(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ")";
        }
        function rgbaString(rgba, alpha) {
          if (alpha === void 0) {
            alpha = rgba[3] !== void 0 ? rgba[3] : 1;
          }
          return "rgba(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ", " + alpha + ")";
        }
        function percentString(rgba, alpha) {
          if (alpha < 1 || rgba[3] && rgba[3] < 1) {
            return percentaString(rgba, alpha);
          }
          var r = Math.round(rgba[0] / 255 * 100), g = Math.round(rgba[1] / 255 * 100), b = Math.round(rgba[2] / 255 * 100);
          return "rgb(" + r + "%, " + g + "%, " + b + "%)";
        }
        function percentaString(rgba, alpha) {
          var r = Math.round(rgba[0] / 255 * 100), g = Math.round(rgba[1] / 255 * 100), b = Math.round(rgba[2] / 255 * 100);
          return "rgba(" + r + "%, " + g + "%, " + b + "%, " + (alpha || rgba[3] || 1) + ")";
        }
        function hslString(hsla, alpha) {
          if (alpha < 1 || hsla[3] && hsla[3] < 1) {
            return hslaString(hsla, alpha);
          }
          return "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)";
        }
        function hslaString(hsla, alpha) {
          if (alpha === void 0) {
            alpha = hsla[3] !== void 0 ? hsla[3] : 1;
          }
          return "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + alpha + ")";
        }
        function hwbString(hwb, alpha) {
          if (alpha === void 0) {
            alpha = hwb[3] !== void 0 ? hwb[3] : 1;
          }
          return "hwb(" + hwb[0] + ", " + hwb[1] + "%, " + hwb[2] + "%" + (alpha !== void 0 && alpha !== 1 ? ", " + alpha : "") + ")";
        }
        function keyword(rgb) {
          return reverseNames[rgb.slice(0, 3)];
        }
        function scale(num, min, max) {
          return Math.min(Math.max(min, num), max);
        }
        function hexDouble(num) {
          var str = num.toString(16).toUpperCase();
          return str.length < 2 ? "0" + str : str;
        }
        var reverseNames = {};
        for (var name in colorName$1) {
          reverseNames[colorName$1[name]] = name;
        }
        var Color = function(obj) {
          if (obj instanceof Color) {
            return obj;
          }
          if (!(this instanceof Color)) {
            return new Color(obj);
          }
          this.valid = false;
          this.values = {
            rgb: [0, 0, 0],
            hsl: [0, 0, 0],
            hsv: [0, 0, 0],
            hwb: [0, 0, 0],
            cmyk: [0, 0, 0, 0],
            alpha: 1
          };
          var vals;
          if (typeof obj === "string") {
            vals = colorString.getRgba(obj);
            if (vals) {
              this.setValues("rgb", vals);
            } else if (vals = colorString.getHsla(obj)) {
              this.setValues("hsl", vals);
            } else if (vals = colorString.getHwb(obj)) {
              this.setValues("hwb", vals);
            }
          } else if (typeof obj === "object") {
            vals = obj;
            if (vals.r !== void 0 || vals.red !== void 0) {
              this.setValues("rgb", vals);
            } else if (vals.l !== void 0 || vals.lightness !== void 0) {
              this.setValues("hsl", vals);
            } else if (vals.v !== void 0 || vals.value !== void 0) {
              this.setValues("hsv", vals);
            } else if (vals.w !== void 0 || vals.whiteness !== void 0) {
              this.setValues("hwb", vals);
            } else if (vals.c !== void 0 || vals.cyan !== void 0) {
              this.setValues("cmyk", vals);
            }
          }
        };
        Color.prototype = {
          isValid: function() {
            return this.valid;
          },
          rgb: function() {
            return this.setSpace("rgb", arguments);
          },
          hsl: function() {
            return this.setSpace("hsl", arguments);
          },
          hsv: function() {
            return this.setSpace("hsv", arguments);
          },
          hwb: function() {
            return this.setSpace("hwb", arguments);
          },
          cmyk: function() {
            return this.setSpace("cmyk", arguments);
          },
          rgbArray: function() {
            return this.values.rgb;
          },
          hslArray: function() {
            return this.values.hsl;
          },
          hsvArray: function() {
            return this.values.hsv;
          },
          hwbArray: function() {
            var values = this.values;
            if (values.alpha !== 1) {
              return values.hwb.concat([values.alpha]);
            }
            return values.hwb;
          },
          cmykArray: function() {
            return this.values.cmyk;
          },
          rgbaArray: function() {
            var values = this.values;
            return values.rgb.concat([values.alpha]);
          },
          hslaArray: function() {
            var values = this.values;
            return values.hsl.concat([values.alpha]);
          },
          alpha: function(val) {
            if (val === void 0) {
              return this.values.alpha;
            }
            this.setValues("alpha", val);
            return this;
          },
          red: function(val) {
            return this.setChannel("rgb", 0, val);
          },
          green: function(val) {
            return this.setChannel("rgb", 1, val);
          },
          blue: function(val) {
            return this.setChannel("rgb", 2, val);
          },
          hue: function(val) {
            if (val) {
              val %= 360;
              val = val < 0 ? 360 + val : val;
            }
            return this.setChannel("hsl", 0, val);
          },
          saturation: function(val) {
            return this.setChannel("hsl", 1, val);
          },
          lightness: function(val) {
            return this.setChannel("hsl", 2, val);
          },
          saturationv: function(val) {
            return this.setChannel("hsv", 1, val);
          },
          whiteness: function(val) {
            return this.setChannel("hwb", 1, val);
          },
          blackness: function(val) {
            return this.setChannel("hwb", 2, val);
          },
          value: function(val) {
            return this.setChannel("hsv", 2, val);
          },
          cyan: function(val) {
            return this.setChannel("cmyk", 0, val);
          },
          magenta: function(val) {
            return this.setChannel("cmyk", 1, val);
          },
          yellow: function(val) {
            return this.setChannel("cmyk", 2, val);
          },
          black: function(val) {
            return this.setChannel("cmyk", 3, val);
          },
          hexString: function() {
            return colorString.hexString(this.values.rgb);
          },
          rgbString: function() {
            return colorString.rgbString(this.values.rgb, this.values.alpha);
          },
          rgbaString: function() {
            return colorString.rgbaString(this.values.rgb, this.values.alpha);
          },
          percentString: function() {
            return colorString.percentString(this.values.rgb, this.values.alpha);
          },
          hslString: function() {
            return colorString.hslString(this.values.hsl, this.values.alpha);
          },
          hslaString: function() {
            return colorString.hslaString(this.values.hsl, this.values.alpha);
          },
          hwbString: function() {
            return colorString.hwbString(this.values.hwb, this.values.alpha);
          },
          keyword: function() {
            return colorString.keyword(this.values.rgb, this.values.alpha);
          },
          rgbNumber: function() {
            var rgb = this.values.rgb;
            return rgb[0] << 16 | rgb[1] << 8 | rgb[2];
          },
          luminosity: function() {
            var rgb = this.values.rgb;
            var lum = [];
            for (var i = 0; i < rgb.length; i++) {
              var chan = rgb[i] / 255;
              lum[i] = chan <= 0.03928 ? chan / 12.92 : Math.pow((chan + 0.055) / 1.055, 2.4);
            }
            return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
          },
          contrast: function(color2) {
            var lum1 = this.luminosity();
            var lum2 = color2.luminosity();
            if (lum1 > lum2) {
              return (lum1 + 0.05) / (lum2 + 0.05);
            }
            return (lum2 + 0.05) / (lum1 + 0.05);
          },
          level: function(color2) {
            var contrastRatio = this.contrast(color2);
            if (contrastRatio >= 7.1) {
              return "AAA";
            }
            return contrastRatio >= 4.5 ? "AA" : "";
          },
          dark: function() {
            var rgb = this.values.rgb;
            var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1e3;
            return yiq < 128;
          },
          light: function() {
            return !this.dark();
          },
          negate: function() {
            var rgb = [];
            for (var i = 0; i < 3; i++) {
              rgb[i] = 255 - this.values.rgb[i];
            }
            this.setValues("rgb", rgb);
            return this;
          },
          lighten: function(ratio) {
            var hsl = this.values.hsl;
            hsl[2] += hsl[2] * ratio;
            this.setValues("hsl", hsl);
            return this;
          },
          darken: function(ratio) {
            var hsl = this.values.hsl;
            hsl[2] -= hsl[2] * ratio;
            this.setValues("hsl", hsl);
            return this;
          },
          saturate: function(ratio) {
            var hsl = this.values.hsl;
            hsl[1] += hsl[1] * ratio;
            this.setValues("hsl", hsl);
            return this;
          },
          desaturate: function(ratio) {
            var hsl = this.values.hsl;
            hsl[1] -= hsl[1] * ratio;
            this.setValues("hsl", hsl);
            return this;
          },
          whiten: function(ratio) {
            var hwb = this.values.hwb;
            hwb[1] += hwb[1] * ratio;
            this.setValues("hwb", hwb);
            return this;
          },
          blacken: function(ratio) {
            var hwb = this.values.hwb;
            hwb[2] += hwb[2] * ratio;
            this.setValues("hwb", hwb);
            return this;
          },
          greyscale: function() {
            var rgb = this.values.rgb;
            var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
            this.setValues("rgb", [val, val, val]);
            return this;
          },
          clearer: function(ratio) {
            var alpha = this.values.alpha;
            this.setValues("alpha", alpha - alpha * ratio);
            return this;
          },
          opaquer: function(ratio) {
            var alpha = this.values.alpha;
            this.setValues("alpha", alpha + alpha * ratio);
            return this;
          },
          rotate: function(degrees) {
            var hsl = this.values.hsl;
            var hue = (hsl[0] + degrees) % 360;
            hsl[0] = hue < 0 ? 360 + hue : hue;
            this.setValues("hsl", hsl);
            return this;
          },
          mix: function(mixinColor, weight) {
            var color1 = this;
            var color2 = mixinColor;
            var p = weight === void 0 ? 0.5 : weight;
            var w = 2 * p - 1;
            var a = color1.alpha() - color2.alpha();
            var w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
            var w2 = 1 - w1;
            return this.rgb(w1 * color1.red() + w2 * color2.red(), w1 * color1.green() + w2 * color2.green(), w1 * color1.blue() + w2 * color2.blue()).alpha(color1.alpha() * p + color2.alpha() * (1 - p));
          },
          toJSON: function() {
            return this.rgb();
          },
          clone: function() {
            var result = new Color();
            var source = this.values;
            var target = result.values;
            var value, type;
            for (var prop in source) {
              if (source.hasOwnProperty(prop)) {
                value = source[prop];
                type = {}.toString.call(value);
                if (type === "[object Array]") {
                  target[prop] = value.slice(0);
                } else if (type === "[object Number]") {
                  target[prop] = value;
                } else {
                  console.error("unexpected color value:", value);
                }
              }
            }
            return result;
          }
        };
        Color.prototype.spaces = {
          rgb: ["red", "green", "blue"],
          hsl: ["hue", "saturation", "lightness"],
          hsv: ["hue", "saturation", "value"],
          hwb: ["hue", "whiteness", "blackness"],
          cmyk: ["cyan", "magenta", "yellow", "black"]
        };
        Color.prototype.maxes = {
          rgb: [255, 255, 255],
          hsl: [360, 100, 100],
          hsv: [360, 100, 100],
          hwb: [360, 100, 100],
          cmyk: [100, 100, 100, 100]
        };
        Color.prototype.getValues = function(space2) {
          var values = this.values;
          var vals = {};
          for (var i = 0; i < space2.length; i++) {
            vals[space2.charAt(i)] = values[space2][i];
          }
          if (values.alpha !== 1) {
            vals.a = values.alpha;
          }
          return vals;
        };
        Color.prototype.setValues = function(space2, vals) {
          var values = this.values;
          var spaces = this.spaces;
          var maxes = this.maxes;
          var alpha = 1;
          var i;
          this.valid = true;
          if (space2 === "alpha") {
            alpha = vals;
          } else if (vals.length) {
            values[space2] = vals.slice(0, space2.length);
            alpha = vals[space2.length];
          } else if (vals[space2.charAt(0)] !== void 0) {
            for (i = 0; i < space2.length; i++) {
              values[space2][i] = vals[space2.charAt(i)];
            }
            alpha = vals.a;
          } else if (vals[spaces[space2][0]] !== void 0) {
            var chans = spaces[space2];
            for (i = 0; i < space2.length; i++) {
              values[space2][i] = vals[chans[i]];
            }
            alpha = vals.alpha;
          }
          values.alpha = Math.max(0, Math.min(1, alpha === void 0 ? values.alpha : alpha));
          if (space2 === "alpha") {
            return false;
          }
          var capped;
          for (i = 0; i < space2.length; i++) {
            capped = Math.max(0, Math.min(maxes[space2][i], values[space2][i]));
            values[space2][i] = Math.round(capped);
          }
          for (var sname in spaces) {
            if (sname !== space2) {
              values[sname] = colorConvert[space2][sname](values[space2]);
            }
          }
          return true;
        };
        Color.prototype.setSpace = function(space2, args) {
          var vals = args[0];
          if (vals === void 0) {
            return this.getValues(space2);
          }
          if (typeof vals === "number") {
            vals = Array.prototype.slice.call(args);
          }
          this.setValues(space2, vals);
          return this;
        };
        Color.prototype.setChannel = function(space2, index, val) {
          var svalues = this.values[space2];
          if (val === void 0) {
            return svalues[index];
          } else if (val === svalues[index]) {
            return this;
          }
          svalues[index] = val;
          this.setValues(space2, svalues);
          return this;
        };
        if (typeof window !== "undefined") {
          window.Color = Color;
        }
        var chartjsColor = Color;
        function isValidKey(key) {
          return ["__proto__", "prototype", "constructor"].indexOf(key) === -1;
        }
        var helpers = {
          noop: function() {
          },
          uid: function() {
            var id = 0;
            return function() {
              return id++;
            };
          }(),
          isNullOrUndef: function(value) {
            return value === null || typeof value === "undefined";
          },
          isArray: function(value) {
            if (Array.isArray && Array.isArray(value)) {
              return true;
            }
            var type = Object.prototype.toString.call(value);
            if (type.substr(0, 7) === "[object" && type.substr(-6) === "Array]") {
              return true;
            }
            return false;
          },
          isObject: function(value) {
            return value !== null && Object.prototype.toString.call(value) === "[object Object]";
          },
          isFinite: function(value) {
            return (typeof value === "number" || value instanceof Number) && isFinite(value);
          },
          valueOrDefault: function(value, defaultValue) {
            return typeof value === "undefined" ? defaultValue : value;
          },
          valueAtIndexOrDefault: function(value, index, defaultValue) {
            return helpers.valueOrDefault(helpers.isArray(value) ? value[index] : value, defaultValue);
          },
          callback: function(fn, args, thisArg) {
            if (fn && typeof fn.call === "function") {
              return fn.apply(thisArg, args);
            }
          },
          each: function(loopable, fn, thisArg, reverse) {
            var i, len, keys;
            if (helpers.isArray(loopable)) {
              len = loopable.length;
              if (reverse) {
                for (i = len - 1; i >= 0; i--) {
                  fn.call(thisArg, loopable[i], i);
                }
              } else {
                for (i = 0; i < len; i++) {
                  fn.call(thisArg, loopable[i], i);
                }
              }
            } else if (helpers.isObject(loopable)) {
              keys = Object.keys(loopable);
              len = keys.length;
              for (i = 0; i < len; i++) {
                fn.call(thisArg, loopable[keys[i]], keys[i]);
              }
            }
          },
          arrayEquals: function(a0, a1) {
            var i, ilen, v0, v1;
            if (!a0 || !a1 || a0.length !== a1.length) {
              return false;
            }
            for (i = 0, ilen = a0.length; i < ilen; ++i) {
              v0 = a0[i];
              v1 = a1[i];
              if (v0 instanceof Array && v1 instanceof Array) {
                if (!helpers.arrayEquals(v0, v1)) {
                  return false;
                }
              } else if (v0 !== v1) {
                return false;
              }
            }
            return true;
          },
          clone: function(source) {
            if (helpers.isArray(source)) {
              return source.map(helpers.clone);
            }
            if (helpers.isObject(source)) {
              var target = Object.create(source);
              var keys = Object.keys(source);
              var klen = keys.length;
              var k2 = 0;
              for (; k2 < klen; ++k2) {
                target[keys[k2]] = helpers.clone(source[keys[k2]]);
              }
              return target;
            }
            return source;
          },
          _merger: function(key, target, source, options2) {
            if (!isValidKey(key)) {
              return;
            }
            var tval = target[key];
            var sval = source[key];
            if (helpers.isObject(tval) && helpers.isObject(sval)) {
              helpers.merge(tval, sval, options2);
            } else {
              target[key] = helpers.clone(sval);
            }
          },
          _mergerIf: function(key, target, source) {
            if (!isValidKey(key)) {
              return;
            }
            var tval = target[key];
            var sval = source[key];
            if (helpers.isObject(tval) && helpers.isObject(sval)) {
              helpers.mergeIf(tval, sval);
            } else if (!target.hasOwnProperty(key)) {
              target[key] = helpers.clone(sval);
            }
          },
          merge: function(target, source, options2) {
            var sources = helpers.isArray(source) ? source : [source];
            var ilen = sources.length;
            var merge, i, keys, klen, k2;
            if (!helpers.isObject(target)) {
              return target;
            }
            options2 = options2 || {};
            merge = options2.merger || helpers._merger;
            for (i = 0; i < ilen; ++i) {
              source = sources[i];
              if (!helpers.isObject(source)) {
                continue;
              }
              keys = Object.keys(source);
              for (k2 = 0, klen = keys.length; k2 < klen; ++k2) {
                merge(keys[k2], target, source, options2);
              }
            }
            return target;
          },
          mergeIf: function(target, source) {
            return helpers.merge(target, source, { merger: helpers._mergerIf });
          },
          extend: Object.assign || function(target) {
            return helpers.merge(target, [].slice.call(arguments, 1), {
              merger: function(key, dst, src2) {
                dst[key] = src2[key];
              }
            });
          },
          inherits: function(extensions) {
            var me = this;
            var ChartElement = extensions && extensions.hasOwnProperty("constructor") ? extensions.constructor : function() {
              return me.apply(this, arguments);
            };
            var Surrogate = function() {
              this.constructor = ChartElement;
            };
            Surrogate.prototype = me.prototype;
            ChartElement.prototype = new Surrogate();
            ChartElement.extend = helpers.inherits;
            if (extensions) {
              helpers.extend(ChartElement.prototype, extensions);
            }
            ChartElement.__super__ = me.prototype;
            return ChartElement;
          },
          _deprecated: function(scope, value, previous, current) {
            if (value !== void 0) {
              console.warn(scope + ': "' + previous + '" is deprecated. Please use "' + current + '" instead');
            }
          }
        };
        var helpers_core = helpers;
        helpers.callCallback = helpers.callback;
        helpers.indexOf = function(array, item2, fromIndex) {
          return Array.prototype.indexOf.call(array, item2, fromIndex);
        };
        helpers.getValueOrDefault = helpers.valueOrDefault;
        helpers.getValueAtIndexOrDefault = helpers.valueAtIndexOrDefault;
        var effects = {
          linear: function(t) {
            return t;
          },
          easeInQuad: function(t) {
            return t * t;
          },
          easeOutQuad: function(t) {
            return -t * (t - 2);
          },
          easeInOutQuad: function(t) {
            if ((t /= 0.5) < 1) {
              return 0.5 * t * t;
            }
            return -0.5 * (--t * (t - 2) - 1);
          },
          easeInCubic: function(t) {
            return t * t * t;
          },
          easeOutCubic: function(t) {
            return (t = t - 1) * t * t + 1;
          },
          easeInOutCubic: function(t) {
            if ((t /= 0.5) < 1) {
              return 0.5 * t * t * t;
            }
            return 0.5 * ((t -= 2) * t * t + 2);
          },
          easeInQuart: function(t) {
            return t * t * t * t;
          },
          easeOutQuart: function(t) {
            return -((t = t - 1) * t * t * t - 1);
          },
          easeInOutQuart: function(t) {
            if ((t /= 0.5) < 1) {
              return 0.5 * t * t * t * t;
            }
            return -0.5 * ((t -= 2) * t * t * t - 2);
          },
          easeInQuint: function(t) {
            return t * t * t * t * t;
          },
          easeOutQuint: function(t) {
            return (t = t - 1) * t * t * t * t + 1;
          },
          easeInOutQuint: function(t) {
            if ((t /= 0.5) < 1) {
              return 0.5 * t * t * t * t * t;
            }
            return 0.5 * ((t -= 2) * t * t * t * t + 2);
          },
          easeInSine: function(t) {
            return -Math.cos(t * (Math.PI / 2)) + 1;
          },
          easeOutSine: function(t) {
            return Math.sin(t * (Math.PI / 2));
          },
          easeInOutSine: function(t) {
            return -0.5 * (Math.cos(Math.PI * t) - 1);
          },
          easeInExpo: function(t) {
            return t === 0 ? 0 : Math.pow(2, 10 * (t - 1));
          },
          easeOutExpo: function(t) {
            return t === 1 ? 1 : -Math.pow(2, -10 * t) + 1;
          },
          easeInOutExpo: function(t) {
            if (t === 0) {
              return 0;
            }
            if (t === 1) {
              return 1;
            }
            if ((t /= 0.5) < 1) {
              return 0.5 * Math.pow(2, 10 * (t - 1));
            }
            return 0.5 * (-Math.pow(2, -10 * --t) + 2);
          },
          easeInCirc: function(t) {
            if (t >= 1) {
              return t;
            }
            return -(Math.sqrt(1 - t * t) - 1);
          },
          easeOutCirc: function(t) {
            return Math.sqrt(1 - (t = t - 1) * t);
          },
          easeInOutCirc: function(t) {
            if ((t /= 0.5) < 1) {
              return -0.5 * (Math.sqrt(1 - t * t) - 1);
            }
            return 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
          },
          easeInElastic: function(t) {
            var s = 1.70158;
            var p = 0;
            var a = 1;
            if (t === 0) {
              return 0;
            }
            if (t === 1) {
              return 1;
            }
            if (!p) {
              p = 0.3;
            }
            if (a < 1) {
              a = 1;
              s = p / 4;
            } else {
              s = p / (2 * Math.PI) * Math.asin(1 / a);
            }
            return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
          },
          easeOutElastic: function(t) {
            var s = 1.70158;
            var p = 0;
            var a = 1;
            if (t === 0) {
              return 0;
            }
            if (t === 1) {
              return 1;
            }
            if (!p) {
              p = 0.3;
            }
            if (a < 1) {
              a = 1;
              s = p / 4;
            } else {
              s = p / (2 * Math.PI) * Math.asin(1 / a);
            }
            return a * Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) + 1;
          },
          easeInOutElastic: function(t) {
            var s = 1.70158;
            var p = 0;
            var a = 1;
            if (t === 0) {
              return 0;
            }
            if ((t /= 0.5) === 2) {
              return 1;
            }
            if (!p) {
              p = 0.45;
            }
            if (a < 1) {
              a = 1;
              s = p / 4;
            } else {
              s = p / (2 * Math.PI) * Math.asin(1 / a);
            }
            if (t < 1) {
              return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
            }
            return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p) * 0.5 + 1;
          },
          easeInBack: function(t) {
            var s = 1.70158;
            return t * t * ((s + 1) * t - s);
          },
          easeOutBack: function(t) {
            var s = 1.70158;
            return (t = t - 1) * t * ((s + 1) * t + s) + 1;
          },
          easeInOutBack: function(t) {
            var s = 1.70158;
            if ((t /= 0.5) < 1) {
              return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
            }
            return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
          },
          easeInBounce: function(t) {
            return 1 - effects.easeOutBounce(1 - t);
          },
          easeOutBounce: function(t) {
            if (t < 1 / 2.75) {
              return 7.5625 * t * t;
            }
            if (t < 2 / 2.75) {
              return 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;
            }
            if (t < 2.5 / 2.75) {
              return 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;
            }
            return 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
          },
          easeInOutBounce: function(t) {
            if (t < 0.5) {
              return effects.easeInBounce(t * 2) * 0.5;
            }
            return effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5;
          }
        };
        var helpers_easing = {
          effects
        };
        helpers_core.easingEffects = effects;
        var PI = Math.PI;
        var RAD_PER_DEG = PI / 180;
        var DOUBLE_PI = PI * 2;
        var HALF_PI = PI / 2;
        var QUARTER_PI = PI / 4;
        var TWO_THIRDS_PI = PI * 2 / 3;
        var exports$1 = {
          clear: function(chart) {
            chart.ctx.clearRect(0, 0, chart.width, chart.height);
          },
          roundedRect: function(ctx, x, y, width, height, radius) {
            if (radius) {
              var r = Math.min(radius, height / 2, width / 2);
              var left = x + r;
              var top = y + r;
              var right = x + width - r;
              var bottom = y + height - r;
              ctx.moveTo(x, top);
              if (left < right && top < bottom) {
                ctx.arc(left, top, r, -PI, -HALF_PI);
                ctx.arc(right, top, r, -HALF_PI, 0);
                ctx.arc(right, bottom, r, 0, HALF_PI);
                ctx.arc(left, bottom, r, HALF_PI, PI);
              } else if (left < right) {
                ctx.moveTo(left, y);
                ctx.arc(right, top, r, -HALF_PI, HALF_PI);
                ctx.arc(left, top, r, HALF_PI, PI + HALF_PI);
              } else if (top < bottom) {
                ctx.arc(left, top, r, -PI, 0);
                ctx.arc(left, bottom, r, 0, PI);
              } else {
                ctx.arc(left, top, r, -PI, PI);
              }
              ctx.closePath();
              ctx.moveTo(x, y);
            } else {
              ctx.rect(x, y, width, height);
            }
          },
          drawPoint: function(ctx, style, radius, x, y, rotation) {
            var type, xOffset, yOffset, size, cornerRadius;
            var rad = (rotation || 0) * RAD_PER_DEG;
            if (style && typeof style === "object") {
              type = style.toString();
              if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rad);
                ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
                ctx.restore();
                return;
              }
            }
            if (isNaN(radius) || radius <= 0) {
              return;
            }
            ctx.beginPath();
            switch (style) {
              default:
                ctx.arc(x, y, radius, 0, DOUBLE_PI);
                ctx.closePath();
                break;
              case "triangle":
                ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
                rad += TWO_THIRDS_PI;
                ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
                rad += TWO_THIRDS_PI;
                ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
                ctx.closePath();
                break;
              case "rectRounded":
                cornerRadius = radius * 0.516;
                size = radius - cornerRadius;
                xOffset = Math.cos(rad + QUARTER_PI) * size;
                yOffset = Math.sin(rad + QUARTER_PI) * size;
                ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
                ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);
                ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);
                ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
                ctx.closePath();
                break;
              case "rect":
                if (!rotation) {
                  size = Math.SQRT1_2 * radius;
                  ctx.rect(x - size, y - size, 2 * size, 2 * size);
                  break;
                }
                rad += QUARTER_PI;
              case "rectRot":
                xOffset = Math.cos(rad) * radius;
                yOffset = Math.sin(rad) * radius;
                ctx.moveTo(x - xOffset, y - yOffset);
                ctx.lineTo(x + yOffset, y - xOffset);
                ctx.lineTo(x + xOffset, y + yOffset);
                ctx.lineTo(x - yOffset, y + xOffset);
                ctx.closePath();
                break;
              case "crossRot":
                rad += QUARTER_PI;
              case "cross":
                xOffset = Math.cos(rad) * radius;
                yOffset = Math.sin(rad) * radius;
                ctx.moveTo(x - xOffset, y - yOffset);
                ctx.lineTo(x + xOffset, y + yOffset);
                ctx.moveTo(x + yOffset, y - xOffset);
                ctx.lineTo(x - yOffset, y + xOffset);
                break;
              case "star":
                xOffset = Math.cos(rad) * radius;
                yOffset = Math.sin(rad) * radius;
                ctx.moveTo(x - xOffset, y - yOffset);
                ctx.lineTo(x + xOffset, y + yOffset);
                ctx.moveTo(x + yOffset, y - xOffset);
                ctx.lineTo(x - yOffset, y + xOffset);
                rad += QUARTER_PI;
                xOffset = Math.cos(rad) * radius;
                yOffset = Math.sin(rad) * radius;
                ctx.moveTo(x - xOffset, y - yOffset);
                ctx.lineTo(x + xOffset, y + yOffset);
                ctx.moveTo(x + yOffset, y - xOffset);
                ctx.lineTo(x - yOffset, y + xOffset);
                break;
              case "line":
                xOffset = Math.cos(rad) * radius;
                yOffset = Math.sin(rad) * radius;
                ctx.moveTo(x - xOffset, y - yOffset);
                ctx.lineTo(x + xOffset, y + yOffset);
                break;
              case "dash":
                ctx.moveTo(x, y);
                ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);
                break;
            }
            ctx.fill();
            ctx.stroke();
          },
          _isPointInArea: function(point, area) {
            var epsilon = 1e-6;
            return point.x > area.left - epsilon && point.x < area.right + epsilon && point.y > area.top - epsilon && point.y < area.bottom + epsilon;
          },
          clipArea: function(ctx, area) {
            ctx.save();
            ctx.beginPath();
            ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
            ctx.clip();
          },
          unclipArea: function(ctx) {
            ctx.restore();
          },
          lineTo: function(ctx, previous, target, flip) {
            var stepped = target.steppedLine;
            if (stepped) {
              if (stepped === "middle") {
                var midpoint = (previous.x + target.x) / 2;
                ctx.lineTo(midpoint, flip ? target.y : previous.y);
                ctx.lineTo(midpoint, flip ? previous.y : target.y);
              } else if (stepped === "after" && !flip || stepped !== "after" && flip) {
                ctx.lineTo(previous.x, target.y);
              } else {
                ctx.lineTo(target.x, previous.y);
              }
              ctx.lineTo(target.x, target.y);
              return;
            }
            if (!target.tension) {
              ctx.lineTo(target.x, target.y);
              return;
            }
            ctx.bezierCurveTo(flip ? previous.controlPointPreviousX : previous.controlPointNextX, flip ? previous.controlPointPreviousY : previous.controlPointNextY, flip ? target.controlPointNextX : target.controlPointPreviousX, flip ? target.controlPointNextY : target.controlPointPreviousY, target.x, target.y);
          }
        };
        var helpers_canvas = exports$1;
        helpers_core.clear = exports$1.clear;
        helpers_core.drawRoundedRectangle = function(ctx) {
          ctx.beginPath();
          exports$1.roundedRect.apply(exports$1, arguments);
        };
        var defaults = {
          _set: function(scope, values) {
            return helpers_core.merge(this[scope] || (this[scope] = {}), values);
          }
        };
        defaults._set("global", {
          defaultColor: "rgba(0,0,0,0.1)",
          defaultFontColor: "#666",
          defaultFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
          defaultFontSize: 12,
          defaultFontStyle: "normal",
          defaultLineHeight: 1.2,
          showLines: true
        });
        var core_defaults = defaults;
        var valueOrDefault = helpers_core.valueOrDefault;
        function toFontString(font) {
          if (!font || helpers_core.isNullOrUndef(font.size) || helpers_core.isNullOrUndef(font.family)) {
            return null;
          }
          return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
        }
        var helpers_options = {
          toLineHeight: function(value, size) {
            var matches = ("" + value).match(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
            if (!matches || matches[1] === "normal") {
              return size * 1.2;
            }
            value = +matches[2];
            switch (matches[3]) {
              case "px":
                return value;
              case "%":
                value /= 100;
                break;
            }
            return size * value;
          },
          toPadding: function(value) {
            var t, r, b, l;
            if (helpers_core.isObject(value)) {
              t = +value.top || 0;
              r = +value.right || 0;
              b = +value.bottom || 0;
              l = +value.left || 0;
            } else {
              t = r = b = l = +value || 0;
            }
            return {
              top: t,
              right: r,
              bottom: b,
              left: l,
              height: t + b,
              width: l + r
            };
          },
          _parseFont: function(options2) {
            var globalDefaults = core_defaults.global;
            var size = valueOrDefault(options2.fontSize, globalDefaults.defaultFontSize);
            var font = {
              family: valueOrDefault(options2.fontFamily, globalDefaults.defaultFontFamily),
              lineHeight: helpers_core.options.toLineHeight(valueOrDefault(options2.lineHeight, globalDefaults.defaultLineHeight), size),
              size,
              style: valueOrDefault(options2.fontStyle, globalDefaults.defaultFontStyle),
              weight: null,
              string: ""
            };
            font.string = toFontString(font);
            return font;
          },
          resolve: function(inputs, context, index, info) {
            var cacheable = true;
            var i, ilen, value;
            for (i = 0, ilen = inputs.length; i < ilen; ++i) {
              value = inputs[i];
              if (value === void 0) {
                continue;
              }
              if (context !== void 0 && typeof value === "function") {
                value = value(context);
                cacheable = false;
              }
              if (index !== void 0 && helpers_core.isArray(value)) {
                value = value[index];
                cacheable = false;
              }
              if (value !== void 0) {
                if (info && !cacheable) {
                  info.cacheable = false;
                }
                return value;
              }
            }
          }
        };
        var exports$2 = {
          _factorize: function(value) {
            var result = [];
            var sqrt = Math.sqrt(value);
            var i;
            for (i = 1; i < sqrt; i++) {
              if (value % i === 0) {
                result.push(i);
                result.push(value / i);
              }
            }
            if (sqrt === (sqrt | 0)) {
              result.push(sqrt);
            }
            result.sort(function(a, b) {
              return a - b;
            }).pop();
            return result;
          },
          log10: Math.log10 || function(x) {
            var exponent = Math.log(x) * Math.LOG10E;
            var powerOf10 = Math.round(exponent);
            var isPowerOf10 = x === Math.pow(10, powerOf10);
            return isPowerOf10 ? powerOf10 : exponent;
          }
        };
        var helpers_math = exports$2;
        helpers_core.log10 = exports$2.log10;
        var getRtlAdapter = function(rectX, width) {
          return {
            x: function(x) {
              return rectX + rectX + width - x;
            },
            setWidth: function(w) {
              width = w;
            },
            textAlign: function(align) {
              if (align === "center") {
                return align;
              }
              return align === "right" ? "left" : "right";
            },
            xPlus: function(x, value) {
              return x - value;
            },
            leftForLtr: function(x, itemWidth) {
              return x - itemWidth;
            }
          };
        };
        var getLtrAdapter = function() {
          return {
            x: function(x) {
              return x;
            },
            setWidth: function(w) {
            },
            textAlign: function(align) {
              return align;
            },
            xPlus: function(x, value) {
              return x + value;
            },
            leftForLtr: function(x, _itemWidth) {
              return x;
            }
          };
        };
        var getAdapter = function(rtl2, rectX, width) {
          return rtl2 ? getRtlAdapter(rectX, width) : getLtrAdapter();
        };
        var overrideTextDirection = function(ctx, direction) {
          var style, original;
          if (direction === "ltr" || direction === "rtl") {
            style = ctx.canvas.style;
            original = [
              style.getPropertyValue("direction"),
              style.getPropertyPriority("direction")
            ];
            style.setProperty("direction", direction, "important");
            ctx.prevTextDirection = original;
          }
        };
        var restoreTextDirection = function(ctx) {
          var original = ctx.prevTextDirection;
          if (original !== void 0) {
            delete ctx.prevTextDirection;
            ctx.canvas.style.setProperty("direction", original[0], original[1]);
          }
        };
        var helpers_rtl = {
          getRtlAdapter: getAdapter,
          overrideTextDirection,
          restoreTextDirection
        };
        var helpers$1 = helpers_core;
        var easing = helpers_easing;
        var canvas = helpers_canvas;
        var options = helpers_options;
        var math = helpers_math;
        var rtl = helpers_rtl;
        helpers$1.easing = easing;
        helpers$1.canvas = canvas;
        helpers$1.options = options;
        helpers$1.math = math;
        helpers$1.rtl = rtl;
        function interpolate(start2, view, model, ease) {
          var keys = Object.keys(model);
          var i, ilen, key, actual, origin, target, type, c0, c1;
          for (i = 0, ilen = keys.length; i < ilen; ++i) {
            key = keys[i];
            target = model[key];
            if (!view.hasOwnProperty(key)) {
              view[key] = target;
            }
            actual = view[key];
            if (actual === target || key[0] === "_") {
              continue;
            }
            if (!start2.hasOwnProperty(key)) {
              start2[key] = actual;
            }
            origin = start2[key];
            type = typeof target;
            if (type === typeof origin) {
              if (type === "string") {
                c0 = chartjsColor(origin);
                if (c0.valid) {
                  c1 = chartjsColor(target);
                  if (c1.valid) {
                    view[key] = c1.mix(c0, ease).rgbString();
                    continue;
                  }
                }
              } else if (helpers$1.isFinite(origin) && helpers$1.isFinite(target)) {
                view[key] = origin + (target - origin) * ease;
                continue;
              }
            }
            view[key] = target;
          }
        }
        var Element = function(configuration) {
          helpers$1.extend(this, configuration);
          this.initialize.apply(this, arguments);
        };
        helpers$1.extend(Element.prototype, {
          _type: void 0,
          initialize: function() {
            this.hidden = false;
          },
          pivot: function() {
            var me = this;
            if (!me._view) {
              me._view = helpers$1.extend({}, me._model);
            }
            me._start = {};
            return me;
          },
          transition: function(ease) {
            var me = this;
            var model = me._model;
            var start2 = me._start;
            var view = me._view;
            if (!model || ease === 1) {
              me._view = helpers$1.extend({}, model);
              me._start = null;
              return me;
            }
            if (!view) {
              view = me._view = {};
            }
            if (!start2) {
              start2 = me._start = {};
            }
            interpolate(start2, view, model, ease);
            return me;
          },
          tooltipPosition: function() {
            return {
              x: this._model.x,
              y: this._model.y
            };
          },
          hasValue: function() {
            return helpers$1.isNumber(this._model.x) && helpers$1.isNumber(this._model.y);
          }
        });
        Element.extend = helpers$1.inherits;
        var core_element = Element;
        var exports$3 = core_element.extend({
          chart: null,
          currentStep: 0,
          numSteps: 60,
          easing: "",
          render: null,
          onAnimationProgress: null,
          onAnimationComplete: null
        });
        var core_animation = exports$3;
        Object.defineProperty(exports$3.prototype, "animationObject", {
          get: function() {
            return this;
          }
        });
        Object.defineProperty(exports$3.prototype, "chartInstance", {
          get: function() {
            return this.chart;
          },
          set: function(value) {
            this.chart = value;
          }
        });
        core_defaults._set("global", {
          animation: {
            duration: 1e3,
            easing: "easeOutQuart",
            onProgress: helpers$1.noop,
            onComplete: helpers$1.noop
          }
        });
        var core_animations = {
          animations: [],
          request: null,
          addAnimation: function(chart, animation, duration, lazy) {
            var animations = this.animations;
            var i, ilen;
            animation.chart = chart;
            animation.startTime = Date.now();
            animation.duration = duration;
            if (!lazy) {
              chart.animating = true;
            }
            for (i = 0, ilen = animations.length; i < ilen; ++i) {
              if (animations[i].chart === chart) {
                animations[i] = animation;
                return;
              }
            }
            animations.push(animation);
            if (animations.length === 1) {
              this.requestAnimationFrame();
            }
          },
          cancelAnimation: function(chart) {
            var index = helpers$1.findIndex(this.animations, function(animation) {
              return animation.chart === chart;
            });
            if (index !== -1) {
              this.animations.splice(index, 1);
              chart.animating = false;
            }
          },
          requestAnimationFrame: function() {
            var me = this;
            if (me.request === null) {
              me.request = helpers$1.requestAnimFrame.call(window, function() {
                me.request = null;
                me.startDigest();
              });
            }
          },
          startDigest: function() {
            var me = this;
            me.advance();
            if (me.animations.length > 0) {
              me.requestAnimationFrame();
            }
          },
          advance: function() {
            var animations = this.animations;
            var animation, chart, numSteps, nextStep;
            var i = 0;
            while (i < animations.length) {
              animation = animations[i];
              chart = animation.chart;
              numSteps = animation.numSteps;
              nextStep = Math.floor((Date.now() - animation.startTime) / animation.duration * numSteps) + 1;
              animation.currentStep = Math.min(nextStep, numSteps);
              helpers$1.callback(animation.render, [chart, animation], chart);
              helpers$1.callback(animation.onAnimationProgress, [animation], chart);
              if (animation.currentStep >= numSteps) {
                helpers$1.callback(animation.onAnimationComplete, [animation], chart);
                chart.animating = false;
                animations.splice(i, 1);
              } else {
                ++i;
              }
            }
          }
        };
        var resolve = helpers$1.options.resolve;
        var arrayEvents = ["push", "pop", "shift", "splice", "unshift"];
        function listenArrayEvents(array, listener) {
          if (array._chartjs) {
            array._chartjs.listeners.push(listener);
            return;
          }
          Object.defineProperty(array, "_chartjs", {
            configurable: true,
            enumerable: false,
            value: {
              listeners: [listener]
            }
          });
          arrayEvents.forEach(function(key) {
            var method = "onData" + key.charAt(0).toUpperCase() + key.slice(1);
            var base = array[key];
            Object.defineProperty(array, key, {
              configurable: true,
              enumerable: false,
              value: function() {
                var args = Array.prototype.slice.call(arguments);
                var res = base.apply(this, args);
                helpers$1.each(array._chartjs.listeners, function(object) {
                  if (typeof object[method] === "function") {
                    object[method].apply(object, args);
                  }
                });
                return res;
              }
            });
          });
        }
        function unlistenArrayEvents(array, listener) {
          var stub = array._chartjs;
          if (!stub) {
            return;
          }
          var listeners = stub.listeners;
          var index = listeners.indexOf(listener);
          if (index !== -1) {
            listeners.splice(index, 1);
          }
          if (listeners.length > 0) {
            return;
          }
          arrayEvents.forEach(function(key) {
            delete array[key];
          });
          delete array._chartjs;
        }
        var DatasetController = function(chart, datasetIndex) {
          this.initialize(chart, datasetIndex);
        };
        helpers$1.extend(DatasetController.prototype, {
          datasetElementType: null,
          dataElementType: null,
          _datasetElementOptions: [
            "backgroundColor",
            "borderCapStyle",
            "borderColor",
            "borderDash",
            "borderDashOffset",
            "borderJoinStyle",
            "borderWidth"
          ],
          _dataElementOptions: [
            "backgroundColor",
            "borderColor",
            "borderWidth",
            "pointStyle"
          ],
          initialize: function(chart, datasetIndex) {
            var me = this;
            me.chart = chart;
            me.index = datasetIndex;
            me.linkScales();
            me.addElements();
            me._type = me.getMeta().type;
          },
          updateIndex: function(datasetIndex) {
            this.index = datasetIndex;
          },
          linkScales: function() {
            var me = this;
            var meta = me.getMeta();
            var chart = me.chart;
            var scales2 = chart.scales;
            var dataset = me.getDataset();
            var scalesOpts = chart.options.scales;
            if (meta.xAxisID === null || !(meta.xAxisID in scales2) || dataset.xAxisID) {
              meta.xAxisID = dataset.xAxisID || scalesOpts.xAxes[0].id;
            }
            if (meta.yAxisID === null || !(meta.yAxisID in scales2) || dataset.yAxisID) {
              meta.yAxisID = dataset.yAxisID || scalesOpts.yAxes[0].id;
            }
          },
          getDataset: function() {
            return this.chart.data.datasets[this.index];
          },
          getMeta: function() {
            return this.chart.getDatasetMeta(this.index);
          },
          getScaleForId: function(scaleID) {
            return this.chart.scales[scaleID];
          },
          _getValueScaleId: function() {
            return this.getMeta().yAxisID;
          },
          _getIndexScaleId: function() {
            return this.getMeta().xAxisID;
          },
          _getValueScale: function() {
            return this.getScaleForId(this._getValueScaleId());
          },
          _getIndexScale: function() {
            return this.getScaleForId(this._getIndexScaleId());
          },
          reset: function() {
            this._update(true);
          },
          destroy: function() {
            if (this._data) {
              unlistenArrayEvents(this._data, this);
            }
          },
          createMetaDataset: function() {
            var me = this;
            var type = me.datasetElementType;
            return type && new type({
              _chart: me.chart,
              _datasetIndex: me.index
            });
          },
          createMetaData: function(index) {
            var me = this;
            var type = me.dataElementType;
            return type && new type({
              _chart: me.chart,
              _datasetIndex: me.index,
              _index: index
            });
          },
          addElements: function() {
            var me = this;
            var meta = me.getMeta();
            var data = me.getDataset().data || [];
            var metaData = meta.data;
            var i, ilen;
            for (i = 0, ilen = data.length; i < ilen; ++i) {
              metaData[i] = metaData[i] || me.createMetaData(i);
            }
            meta.dataset = meta.dataset || me.createMetaDataset();
          },
          addElementAndReset: function(index) {
            var element2 = this.createMetaData(index);
            this.getMeta().data.splice(index, 0, element2);
            this.updateElement(element2, index, true);
          },
          buildOrUpdateElements: function() {
            var me = this;
            var dataset = me.getDataset();
            var data = dataset.data || (dataset.data = []);
            if (me._data !== data) {
              if (me._data) {
                unlistenArrayEvents(me._data, me);
              }
              if (data && Object.isExtensible(data)) {
                listenArrayEvents(data, me);
              }
              me._data = data;
            }
            me.resyncElements();
          },
          _configure: function() {
            var me = this;
            me._config = helpers$1.merge(Object.create(null), [
              me.chart.options.datasets[me._type],
              me.getDataset()
            ], {
              merger: function(key, target, source) {
                if (key !== "_meta" && key !== "data") {
                  helpers$1._merger(key, target, source);
                }
              }
            });
          },
          _update: function(reset) {
            var me = this;
            me._configure();
            me._cachedDataOpts = null;
            me.update(reset);
          },
          update: helpers$1.noop,
          transition: function(easingValue) {
            var meta = this.getMeta();
            var elements2 = meta.data || [];
            var ilen = elements2.length;
            var i = 0;
            for (; i < ilen; ++i) {
              elements2[i].transition(easingValue);
            }
            if (meta.dataset) {
              meta.dataset.transition(easingValue);
            }
          },
          draw: function() {
            var meta = this.getMeta();
            var elements2 = meta.data || [];
            var ilen = elements2.length;
            var i = 0;
            if (meta.dataset) {
              meta.dataset.draw();
            }
            for (; i < ilen; ++i) {
              elements2[i].draw();
            }
          },
          getStyle: function(index) {
            var me = this;
            var meta = me.getMeta();
            var dataset = meta.dataset;
            var style;
            me._configure();
            if (dataset && index === void 0) {
              style = me._resolveDatasetElementOptions(dataset || {});
            } else {
              index = index || 0;
              style = me._resolveDataElementOptions(meta.data[index] || {}, index);
            }
            if (style.fill === false || style.fill === null) {
              style.backgroundColor = style.borderColor;
            }
            return style;
          },
          _resolveDatasetElementOptions: function(element2, hover) {
            var me = this;
            var chart = me.chart;
            var datasetOpts = me._config;
            var custom = element2.custom || {};
            var options2 = chart.options.elements[me.datasetElementType.prototype._type] || {};
            var elementOptions = me._datasetElementOptions;
            var values = {};
            var i, ilen, key, readKey;
            var context = {
              chart,
              dataset: me.getDataset(),
              datasetIndex: me.index,
              hover
            };
            for (i = 0, ilen = elementOptions.length; i < ilen; ++i) {
              key = elementOptions[i];
              readKey = hover ? "hover" + key.charAt(0).toUpperCase() + key.slice(1) : key;
              values[key] = resolve([
                custom[readKey],
                datasetOpts[readKey],
                options2[readKey]
              ], context);
            }
            return values;
          },
          _resolveDataElementOptions: function(element2, index) {
            var me = this;
            var custom = element2 && element2.custom;
            var cached = me._cachedDataOpts;
            if (cached && !custom) {
              return cached;
            }
            var chart = me.chart;
            var datasetOpts = me._config;
            var options2 = chart.options.elements[me.dataElementType.prototype._type] || {};
            var elementOptions = me._dataElementOptions;
            var values = {};
            var context = {
              chart,
              dataIndex: index,
              dataset: me.getDataset(),
              datasetIndex: me.index
            };
            var info = { cacheable: !custom };
            var keys, i, ilen, key;
            custom = custom || {};
            if (helpers$1.isArray(elementOptions)) {
              for (i = 0, ilen = elementOptions.length; i < ilen; ++i) {
                key = elementOptions[i];
                values[key] = resolve([
                  custom[key],
                  datasetOpts[key],
                  options2[key]
                ], context, index, info);
              }
            } else {
              keys = Object.keys(elementOptions);
              for (i = 0, ilen = keys.length; i < ilen; ++i) {
                key = keys[i];
                values[key] = resolve([
                  custom[key],
                  datasetOpts[elementOptions[key]],
                  datasetOpts[key],
                  options2[key]
                ], context, index, info);
              }
            }
            if (info.cacheable) {
              me._cachedDataOpts = Object.freeze(values);
            }
            return values;
          },
          removeHoverStyle: function(element2) {
            helpers$1.merge(element2._model, element2.$previousStyle || {});
            delete element2.$previousStyle;
          },
          setHoverStyle: function(element2) {
            var dataset = this.chart.data.datasets[element2._datasetIndex];
            var index = element2._index;
            var custom = element2.custom || {};
            var model = element2._model;
            var getHoverColor = helpers$1.getHoverColor;
            element2.$previousStyle = {
              backgroundColor: model.backgroundColor,
              borderColor: model.borderColor,
              borderWidth: model.borderWidth
            };
            model.backgroundColor = resolve([custom.hoverBackgroundColor, dataset.hoverBackgroundColor, getHoverColor(model.backgroundColor)], void 0, index);
            model.borderColor = resolve([custom.hoverBorderColor, dataset.hoverBorderColor, getHoverColor(model.borderColor)], void 0, index);
            model.borderWidth = resolve([custom.hoverBorderWidth, dataset.hoverBorderWidth, model.borderWidth], void 0, index);
          },
          _removeDatasetHoverStyle: function() {
            var element2 = this.getMeta().dataset;
            if (element2) {
              this.removeHoverStyle(element2);
            }
          },
          _setDatasetHoverStyle: function() {
            var element2 = this.getMeta().dataset;
            var prev = {};
            var i, ilen, key, keys, hoverOptions, model;
            if (!element2) {
              return;
            }
            model = element2._model;
            hoverOptions = this._resolveDatasetElementOptions(element2, true);
            keys = Object.keys(hoverOptions);
            for (i = 0, ilen = keys.length; i < ilen; ++i) {
              key = keys[i];
              prev[key] = model[key];
              model[key] = hoverOptions[key];
            }
            element2.$previousStyle = prev;
          },
          resyncElements: function() {
            var me = this;
            var meta = me.getMeta();
            var data = me.getDataset().data;
            var numMeta = meta.data.length;
            var numData = data.length;
            if (numData < numMeta) {
              meta.data.splice(numData, numMeta - numData);
            } else if (numData > numMeta) {
              me.insertElements(numMeta, numData - numMeta);
            }
          },
          insertElements: function(start2, count) {
            for (var i = 0; i < count; ++i) {
              this.addElementAndReset(start2 + i);
            }
          },
          onDataPush: function() {
            var count = arguments.length;
            this.insertElements(this.getDataset().data.length - count, count);
          },
          onDataPop: function() {
            this.getMeta().data.pop();
          },
          onDataShift: function() {
            this.getMeta().data.shift();
          },
          onDataSplice: function(start2, count) {
            this.getMeta().data.splice(start2, count);
            this.insertElements(start2, arguments.length - 2);
          },
          onDataUnshift: function() {
            this.insertElements(0, arguments.length);
          }
        });
        DatasetController.extend = helpers$1.inherits;
        var core_datasetController = DatasetController;
        var TAU = Math.PI * 2;
        core_defaults._set("global", {
          elements: {
            arc: {
              backgroundColor: core_defaults.global.defaultColor,
              borderColor: "#fff",
              borderWidth: 2,
              borderAlign: "center"
            }
          }
        });
        function clipArc(ctx, arc) {
          var startAngle = arc.startAngle;
          var endAngle = arc.endAngle;
          var pixelMargin = arc.pixelMargin;
          var angleMargin = pixelMargin / arc.outerRadius;
          var x = arc.x;
          var y = arc.y;
          ctx.beginPath();
          ctx.arc(x, y, arc.outerRadius, startAngle - angleMargin, endAngle + angleMargin);
          if (arc.innerRadius > pixelMargin) {
            angleMargin = pixelMargin / arc.innerRadius;
            ctx.arc(x, y, arc.innerRadius - pixelMargin, endAngle + angleMargin, startAngle - angleMargin, true);
          } else {
            ctx.arc(x, y, pixelMargin, endAngle + Math.PI / 2, startAngle - Math.PI / 2);
          }
          ctx.closePath();
          ctx.clip();
        }
        function drawFullCircleBorders(ctx, vm, arc, inner) {
          var endAngle = arc.endAngle;
          var i;
          if (inner) {
            arc.endAngle = arc.startAngle + TAU;
            clipArc(ctx, arc);
            arc.endAngle = endAngle;
            if (arc.endAngle === arc.startAngle && arc.fullCircles) {
              arc.endAngle += TAU;
              arc.fullCircles--;
            }
          }
          ctx.beginPath();
          ctx.arc(arc.x, arc.y, arc.innerRadius, arc.startAngle + TAU, arc.startAngle, true);
          for (i = 0; i < arc.fullCircles; ++i) {
            ctx.stroke();
          }
          ctx.beginPath();
          ctx.arc(arc.x, arc.y, vm.outerRadius, arc.startAngle, arc.startAngle + TAU);
          for (i = 0; i < arc.fullCircles; ++i) {
            ctx.stroke();
          }
        }
        function drawBorder(ctx, vm, arc) {
          var inner = vm.borderAlign === "inner";
          if (inner) {
            ctx.lineWidth = vm.borderWidth * 2;
            ctx.lineJoin = "round";
          } else {
            ctx.lineWidth = vm.borderWidth;
            ctx.lineJoin = "bevel";
          }
          if (arc.fullCircles) {
            drawFullCircleBorders(ctx, vm, arc, inner);
          }
          if (inner) {
            clipArc(ctx, arc);
          }
          ctx.beginPath();
          ctx.arc(arc.x, arc.y, vm.outerRadius, arc.startAngle, arc.endAngle);
          ctx.arc(arc.x, arc.y, arc.innerRadius, arc.endAngle, arc.startAngle, true);
          ctx.closePath();
          ctx.stroke();
        }
        var element_arc = core_element.extend({
          _type: "arc",
          inLabelRange: function(mouseX) {
            var vm = this._view;
            if (vm) {
              return Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2);
            }
            return false;
          },
          inRange: function(chartX, chartY) {
            var vm = this._view;
            if (vm) {
              var pointRelativePosition = helpers$1.getAngleFromPoint(vm, { x: chartX, y: chartY });
              var angle = pointRelativePosition.angle;
              var distance = pointRelativePosition.distance;
              var startAngle = vm.startAngle;
              var endAngle = vm.endAngle;
              while (endAngle < startAngle) {
                endAngle += TAU;
              }
              while (angle > endAngle) {
                angle -= TAU;
              }
              while (angle < startAngle) {
                angle += TAU;
              }
              var betweenAngles = angle >= startAngle && angle <= endAngle;
              var withinRadius = distance >= vm.innerRadius && distance <= vm.outerRadius;
              return betweenAngles && withinRadius;
            }
            return false;
          },
          getCenterPoint: function() {
            var vm = this._view;
            var halfAngle = (vm.startAngle + vm.endAngle) / 2;
            var halfRadius = (vm.innerRadius + vm.outerRadius) / 2;
            return {
              x: vm.x + Math.cos(halfAngle) * halfRadius,
              y: vm.y + Math.sin(halfAngle) * halfRadius
            };
          },
          getArea: function() {
            var vm = this._view;
            return Math.PI * ((vm.endAngle - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius, 2));
          },
          tooltipPosition: function() {
            var vm = this._view;
            var centreAngle = vm.startAngle + (vm.endAngle - vm.startAngle) / 2;
            var rangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;
            return {
              x: vm.x + Math.cos(centreAngle) * rangeFromCentre,
              y: vm.y + Math.sin(centreAngle) * rangeFromCentre
            };
          },
          draw: function() {
            var ctx = this._chart.ctx;
            var vm = this._view;
            var pixelMargin = vm.borderAlign === "inner" ? 0.33 : 0;
            var arc = {
              x: vm.x,
              y: vm.y,
              innerRadius: vm.innerRadius,
              outerRadius: Math.max(vm.outerRadius - pixelMargin, 0),
              pixelMargin,
              startAngle: vm.startAngle,
              endAngle: vm.endAngle,
              fullCircles: Math.floor(vm.circumference / TAU)
            };
            var i;
            ctx.save();
            ctx.fillStyle = vm.backgroundColor;
            ctx.strokeStyle = vm.borderColor;
            if (arc.fullCircles) {
              arc.endAngle = arc.startAngle + TAU;
              ctx.beginPath();
              ctx.arc(arc.x, arc.y, arc.outerRadius, arc.startAngle, arc.endAngle);
              ctx.arc(arc.x, arc.y, arc.innerRadius, arc.endAngle, arc.startAngle, true);
              ctx.closePath();
              for (i = 0; i < arc.fullCircles; ++i) {
                ctx.fill();
              }
              arc.endAngle = arc.startAngle + vm.circumference % TAU;
            }
            ctx.beginPath();
            ctx.arc(arc.x, arc.y, arc.outerRadius, arc.startAngle, arc.endAngle);
            ctx.arc(arc.x, arc.y, arc.innerRadius, arc.endAngle, arc.startAngle, true);
            ctx.closePath();
            ctx.fill();
            if (vm.borderWidth) {
              drawBorder(ctx, vm, arc);
            }
            ctx.restore();
          }
        });
        var valueOrDefault$1 = helpers$1.valueOrDefault;
        var defaultColor = core_defaults.global.defaultColor;
        core_defaults._set("global", {
          elements: {
            line: {
              tension: 0.4,
              backgroundColor: defaultColor,
              borderWidth: 3,
              borderColor: defaultColor,
              borderCapStyle: "butt",
              borderDash: [],
              borderDashOffset: 0,
              borderJoinStyle: "miter",
              capBezierPoints: true,
              fill: true
            }
          }
        });
        var element_line = core_element.extend({
          _type: "line",
          draw: function() {
            var me = this;
            var vm = me._view;
            var ctx = me._chart.ctx;
            var spanGaps = vm.spanGaps;
            var points = me._children.slice();
            var globalDefaults = core_defaults.global;
            var globalOptionLineElements = globalDefaults.elements.line;
            var lastDrawnIndex = -1;
            var closePath = me._loop;
            var index, previous, currentVM;
            if (!points.length) {
              return;
            }
            if (me._loop) {
              for (index = 0; index < points.length; ++index) {
                previous = helpers$1.previousItem(points, index);
                if (!points[index]._view.skip && previous._view.skip) {
                  points = points.slice(index).concat(points.slice(0, index));
                  closePath = spanGaps;
                  break;
                }
              }
              if (closePath) {
                points.push(points[0]);
              }
            }
            ctx.save();
            ctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle;
            if (ctx.setLineDash) {
              ctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);
            }
            ctx.lineDashOffset = valueOrDefault$1(vm.borderDashOffset, globalOptionLineElements.borderDashOffset);
            ctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;
            ctx.lineWidth = valueOrDefault$1(vm.borderWidth, globalOptionLineElements.borderWidth);
            ctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor;
            ctx.beginPath();
            currentVM = points[0]._view;
            if (!currentVM.skip) {
              ctx.moveTo(currentVM.x, currentVM.y);
              lastDrawnIndex = 0;
            }
            for (index = 1; index < points.length; ++index) {
              currentVM = points[index]._view;
              previous = lastDrawnIndex === -1 ? helpers$1.previousItem(points, index) : points[lastDrawnIndex];
              if (!currentVM.skip) {
                if (lastDrawnIndex !== index - 1 && !spanGaps || lastDrawnIndex === -1) {
                  ctx.moveTo(currentVM.x, currentVM.y);
                } else {
                  helpers$1.canvas.lineTo(ctx, previous._view, currentVM);
                }
                lastDrawnIndex = index;
              }
            }
            if (closePath) {
              ctx.closePath();
            }
            ctx.stroke();
            ctx.restore();
          }
        });
        var valueOrDefault$2 = helpers$1.valueOrDefault;
        var defaultColor$1 = core_defaults.global.defaultColor;
        core_defaults._set("global", {
          elements: {
            point: {
              radius: 3,
              pointStyle: "circle",
              backgroundColor: defaultColor$1,
              borderColor: defaultColor$1,
              borderWidth: 1,
              hitRadius: 1,
              hoverRadius: 4,
              hoverBorderWidth: 1
            }
          }
        });
        function xRange(mouseX) {
          var vm = this._view;
          return vm ? Math.abs(mouseX - vm.x) < vm.radius + vm.hitRadius : false;
        }
        function yRange(mouseY) {
          var vm = this._view;
          return vm ? Math.abs(mouseY - vm.y) < vm.radius + vm.hitRadius : false;
        }
        var element_point = core_element.extend({
          _type: "point",
          inRange: function(mouseX, mouseY) {
            var vm = this._view;
            return vm ? Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2) < Math.pow(vm.hitRadius + vm.radius, 2) : false;
          },
          inLabelRange: xRange,
          inXRange: xRange,
          inYRange: yRange,
          getCenterPoint: function() {
            var vm = this._view;
            return {
              x: vm.x,
              y: vm.y
            };
          },
          getArea: function() {
            return Math.PI * Math.pow(this._view.radius, 2);
          },
          tooltipPosition: function() {
            var vm = this._view;
            return {
              x: vm.x,
              y: vm.y,
              padding: vm.radius + vm.borderWidth
            };
          },
          draw: function(chartArea) {
            var vm = this._view;
            var ctx = this._chart.ctx;
            var pointStyle = vm.pointStyle;
            var rotation = vm.rotation;
            var radius = vm.radius;
            var x = vm.x;
            var y = vm.y;
            var globalDefaults = core_defaults.global;
            var defaultColor2 = globalDefaults.defaultColor;
            if (vm.skip) {
              return;
            }
            if (chartArea === void 0 || helpers$1.canvas._isPointInArea(vm, chartArea)) {
              ctx.strokeStyle = vm.borderColor || defaultColor2;
              ctx.lineWidth = valueOrDefault$2(vm.borderWidth, globalDefaults.elements.point.borderWidth);
              ctx.fillStyle = vm.backgroundColor || defaultColor2;
              helpers$1.canvas.drawPoint(ctx, pointStyle, radius, x, y, rotation);
            }
          }
        });
        var defaultColor$2 = core_defaults.global.defaultColor;
        core_defaults._set("global", {
          elements: {
            rectangle: {
              backgroundColor: defaultColor$2,
              borderColor: defaultColor$2,
              borderSkipped: "bottom",
              borderWidth: 0
            }
          }
        });
        function isVertical(vm) {
          return vm && vm.width !== void 0;
        }
        function getBarBounds(vm) {
          var x1, x2, y1, y2, half;
          if (isVertical(vm)) {
            half = vm.width / 2;
            x1 = vm.x - half;
            x2 = vm.x + half;
            y1 = Math.min(vm.y, vm.base);
            y2 = Math.max(vm.y, vm.base);
          } else {
            half = vm.height / 2;
            x1 = Math.min(vm.x, vm.base);
            x2 = Math.max(vm.x, vm.base);
            y1 = vm.y - half;
            y2 = vm.y + half;
          }
          return {
            left: x1,
            top: y1,
            right: x2,
            bottom: y2
          };
        }
        function swap(orig, v1, v2) {
          return orig === v1 ? v2 : orig === v2 ? v1 : orig;
        }
        function parseBorderSkipped(vm) {
          var edge = vm.borderSkipped;
          var res = {};
          if (!edge) {
            return res;
          }
          if (vm.horizontal) {
            if (vm.base > vm.x) {
              edge = swap(edge, "left", "right");
            }
          } else if (vm.base < vm.y) {
            edge = swap(edge, "bottom", "top");
          }
          res[edge] = true;
          return res;
        }
        function parseBorderWidth(vm, maxW, maxH) {
          var value = vm.borderWidth;
          var skip2 = parseBorderSkipped(vm);
          var t, r, b, l;
          if (helpers$1.isObject(value)) {
            t = +value.top || 0;
            r = +value.right || 0;
            b = +value.bottom || 0;
            l = +value.left || 0;
          } else {
            t = r = b = l = +value || 0;
          }
          return {
            t: skip2.top || t < 0 ? 0 : t > maxH ? maxH : t,
            r: skip2.right || r < 0 ? 0 : r > maxW ? maxW : r,
            b: skip2.bottom || b < 0 ? 0 : b > maxH ? maxH : b,
            l: skip2.left || l < 0 ? 0 : l > maxW ? maxW : l
          };
        }
        function boundingRects(vm) {
          var bounds = getBarBounds(vm);
          var width = bounds.right - bounds.left;
          var height = bounds.bottom - bounds.top;
          var border = parseBorderWidth(vm, width / 2, height / 2);
          return {
            outer: {
              x: bounds.left,
              y: bounds.top,
              w: width,
              h: height
            },
            inner: {
              x: bounds.left + border.l,
              y: bounds.top + border.t,
              w: width - border.l - border.r,
              h: height - border.t - border.b
            }
          };
        }
        function inRange(vm, x, y) {
          var skipX = x === null;
          var skipY = y === null;
          var bounds = !vm || skipX && skipY ? false : getBarBounds(vm);
          return bounds && (skipX || x >= bounds.left && x <= bounds.right) && (skipY || y >= bounds.top && y <= bounds.bottom);
        }
        var element_rectangle = core_element.extend({
          _type: "rectangle",
          draw: function() {
            var ctx = this._chart.ctx;
            var vm = this._view;
            var rects = boundingRects(vm);
            var outer = rects.outer;
            var inner = rects.inner;
            ctx.fillStyle = vm.backgroundColor;
            ctx.fillRect(outer.x, outer.y, outer.w, outer.h);
            if (outer.w === inner.w && outer.h === inner.h) {
              return;
            }
            ctx.save();
            ctx.beginPath();
            ctx.rect(outer.x, outer.y, outer.w, outer.h);
            ctx.clip();
            ctx.fillStyle = vm.borderColor;
            ctx.rect(inner.x, inner.y, inner.w, inner.h);
            ctx.fill("evenodd");
            ctx.restore();
          },
          height: function() {
            var vm = this._view;
            return vm.base - vm.y;
          },
          inRange: function(mouseX, mouseY) {
            return inRange(this._view, mouseX, mouseY);
          },
          inLabelRange: function(mouseX, mouseY) {
            var vm = this._view;
            return isVertical(vm) ? inRange(vm, mouseX, null) : inRange(vm, null, mouseY);
          },
          inXRange: function(mouseX) {
            return inRange(this._view, mouseX, null);
          },
          inYRange: function(mouseY) {
            return inRange(this._view, null, mouseY);
          },
          getCenterPoint: function() {
            var vm = this._view;
            var x, y;
            if (isVertical(vm)) {
              x = vm.x;
              y = (vm.y + vm.base) / 2;
            } else {
              x = (vm.x + vm.base) / 2;
              y = vm.y;
            }
            return { x, y };
          },
          getArea: function() {
            var vm = this._view;
            return isVertical(vm) ? vm.width * Math.abs(vm.y - vm.base) : vm.height * Math.abs(vm.x - vm.base);
          },
          tooltipPosition: function() {
            var vm = this._view;
            return {
              x: vm.x,
              y: vm.y
            };
          }
        });
        var elements = {};
        var Arc = element_arc;
        var Line = element_line;
        var Point = element_point;
        var Rectangle = element_rectangle;
        elements.Arc = Arc;
        elements.Line = Line;
        elements.Point = Point;
        elements.Rectangle = Rectangle;
        var deprecated = helpers$1._deprecated;
        var valueOrDefault$3 = helpers$1.valueOrDefault;
        core_defaults._set("bar", {
          hover: {
            mode: "label"
          },
          scales: {
            xAxes: [{
              type: "category",
              offset: true,
              gridLines: {
                offsetGridLines: true
              }
            }],
            yAxes: [{
              type: "linear"
            }]
          }
        });
        core_defaults._set("global", {
          datasets: {
            bar: {
              categoryPercentage: 0.8,
              barPercentage: 0.9
            }
          }
        });
        function computeMinSampleSize(scale2, pixels) {
          var min = scale2._length;
          var prev, curr, i, ilen;
          for (i = 1, ilen = pixels.length; i < ilen; ++i) {
            min = Math.min(min, Math.abs(pixels[i] - pixels[i - 1]));
          }
          for (i = 0, ilen = scale2.getTicks().length; i < ilen; ++i) {
            curr = scale2.getPixelForTick(i);
            min = i > 0 ? Math.min(min, Math.abs(curr - prev)) : min;
            prev = curr;
          }
          return min;
        }
        function computeFitCategoryTraits(index, ruler, options2) {
          var thickness = options2.barThickness;
          var count = ruler.stackCount;
          var curr = ruler.pixels[index];
          var min = helpers$1.isNullOrUndef(thickness) ? computeMinSampleSize(ruler.scale, ruler.pixels) : -1;
          var size, ratio;
          if (helpers$1.isNullOrUndef(thickness)) {
            size = min * options2.categoryPercentage;
            ratio = options2.barPercentage;
          } else {
            size = thickness * count;
            ratio = 1;
          }
          return {
            chunk: size / count,
            ratio,
            start: curr - size / 2
          };
        }
        function computeFlexCategoryTraits(index, ruler, options2) {
          var pixels = ruler.pixels;
          var curr = pixels[index];
          var prev = index > 0 ? pixels[index - 1] : null;
          var next = index < pixels.length - 1 ? pixels[index + 1] : null;
          var percent = options2.categoryPercentage;
          var start2, size;
          if (prev === null) {
            prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
          }
          if (next === null) {
            next = curr + curr - prev;
          }
          start2 = curr - (curr - Math.min(prev, next)) / 2 * percent;
          size = Math.abs(next - prev) / 2 * percent;
          return {
            chunk: size / ruler.stackCount,
            ratio: options2.barPercentage,
            start: start2
          };
        }
        var controller_bar = core_datasetController.extend({
          dataElementType: elements.Rectangle,
          _dataElementOptions: [
            "backgroundColor",
            "borderColor",
            "borderSkipped",
            "borderWidth",
            "barPercentage",
            "barThickness",
            "categoryPercentage",
            "maxBarThickness",
            "minBarLength"
          ],
          initialize: function() {
            var me = this;
            var meta, scaleOpts;
            core_datasetController.prototype.initialize.apply(me, arguments);
            meta = me.getMeta();
            meta.stack = me.getDataset().stack;
            meta.bar = true;
            scaleOpts = me._getIndexScale().options;
            deprecated("bar chart", scaleOpts.barPercentage, "scales.[x/y]Axes.barPercentage", "dataset.barPercentage");
            deprecated("bar chart", scaleOpts.barThickness, "scales.[x/y]Axes.barThickness", "dataset.barThickness");
            deprecated("bar chart", scaleOpts.categoryPercentage, "scales.[x/y]Axes.categoryPercentage", "dataset.categoryPercentage");
            deprecated("bar chart", me._getValueScale().options.minBarLength, "scales.[x/y]Axes.minBarLength", "dataset.minBarLength");
            deprecated("bar chart", scaleOpts.maxBarThickness, "scales.[x/y]Axes.maxBarThickness", "dataset.maxBarThickness");
          },
          update: function(reset) {
            var me = this;
            var rects = me.getMeta().data;
            var i, ilen;
            me._ruler = me.getRuler();
            for (i = 0, ilen = rects.length; i < ilen; ++i) {
              me.updateElement(rects[i], i, reset);
            }
          },
          updateElement: function(rectangle, index, reset) {
            var me = this;
            var meta = me.getMeta();
            var dataset = me.getDataset();
            var options2 = me._resolveDataElementOptions(rectangle, index);
            rectangle._xScale = me.getScaleForId(meta.xAxisID);
            rectangle._yScale = me.getScaleForId(meta.yAxisID);
            rectangle._datasetIndex = me.index;
            rectangle._index = index;
            rectangle._model = {
              backgroundColor: options2.backgroundColor,
              borderColor: options2.borderColor,
              borderSkipped: options2.borderSkipped,
              borderWidth: options2.borderWidth,
              datasetLabel: dataset.label,
              label: me.chart.data.labels[index]
            };
            if (helpers$1.isArray(dataset.data[index])) {
              rectangle._model.borderSkipped = null;
            }
            me._updateElementGeometry(rectangle, index, reset, options2);
            rectangle.pivot();
          },
          _updateElementGeometry: function(rectangle, index, reset, options2) {
            var me = this;
            var model = rectangle._model;
            var vscale = me._getValueScale();
            var base = vscale.getBasePixel();
            var horizontal = vscale.isHorizontal();
            var ruler = me._ruler || me.getRuler();
            var vpixels = me.calculateBarValuePixels(me.index, index, options2);
            var ipixels = me.calculateBarIndexPixels(me.index, index, ruler, options2);
            model.horizontal = horizontal;
            model.base = reset ? base : vpixels.base;
            model.x = horizontal ? reset ? base : vpixels.head : ipixels.center;
            model.y = horizontal ? ipixels.center : reset ? base : vpixels.head;
            model.height = horizontal ? ipixels.size : void 0;
            model.width = horizontal ? void 0 : ipixels.size;
          },
          _getStacks: function(last) {
            var me = this;
            var scale2 = me._getIndexScale();
            var metasets = scale2._getMatchingVisibleMetas(me._type);
            var stacked = scale2.options.stacked;
            var ilen = metasets.length;
            var stacks = [];
            var i, meta;
            for (i = 0; i < ilen; ++i) {
              meta = metasets[i];
              if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === void 0 && meta.stack === void 0) {
                stacks.push(meta.stack);
              }
              if (meta.index === last) {
                break;
              }
            }
            return stacks;
          },
          getStackCount: function() {
            return this._getStacks().length;
          },
          getStackIndex: function(datasetIndex, name2) {
            var stacks = this._getStacks(datasetIndex);
            var index = name2 !== void 0 ? stacks.indexOf(name2) : -1;
            return index === -1 ? stacks.length - 1 : index;
          },
          getRuler: function() {
            var me = this;
            var scale2 = me._getIndexScale();
            var pixels = [];
            var i, ilen;
            for (i = 0, ilen = me.getMeta().data.length; i < ilen; ++i) {
              pixels.push(scale2.getPixelForValue(null, i, me.index));
            }
            return {
              pixels,
              start: scale2._startPixel,
              end: scale2._endPixel,
              stackCount: me.getStackCount(),
              scale: scale2
            };
          },
          calculateBarValuePixels: function(datasetIndex, index, options2) {
            var me = this;
            var chart = me.chart;
            var scale2 = me._getValueScale();
            var isHorizontal = scale2.isHorizontal();
            var datasets = chart.data.datasets;
            var metasets = scale2._getMatchingVisibleMetas(me._type);
            var value = scale2._parseValue(datasets[datasetIndex].data[index]);
            var minBarLength = options2.minBarLength;
            var stacked = scale2.options.stacked;
            var stack = me.getMeta().stack;
            var start2 = value.start === void 0 ? 0 : value.max >= 0 && value.min >= 0 ? value.min : value.max;
            var length = value.start === void 0 ? value.end : value.max >= 0 && value.min >= 0 ? value.max - value.min : value.min - value.max;
            var ilen = metasets.length;
            var i, imeta, ivalue, base, head, size, stackLength;
            if (stacked || stacked === void 0 && stack !== void 0) {
              for (i = 0; i < ilen; ++i) {
                imeta = metasets[i];
                if (imeta.index === datasetIndex) {
                  break;
                }
                if (imeta.stack === stack) {
                  stackLength = scale2._parseValue(datasets[imeta.index].data[index]);
                  ivalue = stackLength.start === void 0 ? stackLength.end : stackLength.min >= 0 && stackLength.max >= 0 ? stackLength.max : stackLength.min;
                  if (value.min < 0 && ivalue < 0 || value.max >= 0 && ivalue > 0) {
                    start2 += ivalue;
                  }
                }
              }
            }
            base = scale2.getPixelForValue(start2);
            head = scale2.getPixelForValue(start2 + length);
            size = head - base;
            if (minBarLength !== void 0 && Math.abs(size) < minBarLength) {
              size = minBarLength;
              if (length >= 0 && !isHorizontal || length < 0 && isHorizontal) {
                head = base - minBarLength;
              } else {
                head = base + minBarLength;
              }
            }
            return {
              size,
              base,
              head,
              center: head + size / 2
            };
          },
          calculateBarIndexPixels: function(datasetIndex, index, ruler, options2) {
            var me = this;
            var range = options2.barThickness === "flex" ? computeFlexCategoryTraits(index, ruler, options2) : computeFitCategoryTraits(index, ruler, options2);
            var stackIndex = me.getStackIndex(datasetIndex, me.getMeta().stack);
            var center = range.start + range.chunk * stackIndex + range.chunk / 2;
            var size = Math.min(valueOrDefault$3(options2.maxBarThickness, Infinity), range.chunk * range.ratio);
            return {
              base: center - size / 2,
              head: center + size / 2,
              center,
              size
            };
          },
          draw: function() {
            var me = this;
            var chart = me.chart;
            var scale2 = me._getValueScale();
            var rects = me.getMeta().data;
            var dataset = me.getDataset();
            var ilen = rects.length;
            var i = 0;
            helpers$1.canvas.clipArea(chart.ctx, chart.chartArea);
            for (; i < ilen; ++i) {
              var val = scale2._parseValue(dataset.data[i]);
              if (!isNaN(val.min) && !isNaN(val.max)) {
                rects[i].draw();
              }
            }
            helpers$1.canvas.unclipArea(chart.ctx);
          },
          _resolveDataElementOptions: function() {
            var me = this;
            var values = helpers$1.extend({}, core_datasetController.prototype._resolveDataElementOptions.apply(me, arguments));
            var indexOpts = me._getIndexScale().options;
            var valueOpts = me._getValueScale().options;
            values.barPercentage = valueOrDefault$3(indexOpts.barPercentage, values.barPercentage);
            values.barThickness = valueOrDefault$3(indexOpts.barThickness, values.barThickness);
            values.categoryPercentage = valueOrDefault$3(indexOpts.categoryPercentage, values.categoryPercentage);
            values.maxBarThickness = valueOrDefault$3(indexOpts.maxBarThickness, values.maxBarThickness);
            values.minBarLength = valueOrDefault$3(valueOpts.minBarLength, values.minBarLength);
            return values;
          }
        });
        var valueOrDefault$4 = helpers$1.valueOrDefault;
        var resolve$1 = helpers$1.options.resolve;
        core_defaults._set("bubble", {
          hover: {
            mode: "single"
          },
          scales: {
            xAxes: [{
              type: "linear",
              position: "bottom",
              id: "x-axis-0"
            }],
            yAxes: [{
              type: "linear",
              position: "left",
              id: "y-axis-0"
            }]
          },
          tooltips: {
            callbacks: {
              title: function() {
                return "";
              },
              label: function(item2, data) {
                var datasetLabel = data.datasets[item2.datasetIndex].label || "";
                var dataPoint = data.datasets[item2.datasetIndex].data[item2.index];
                return datasetLabel + ": (" + item2.xLabel + ", " + item2.yLabel + ", " + dataPoint.r + ")";
              }
            }
          }
        });
        var controller_bubble = core_datasetController.extend({
          dataElementType: elements.Point,
          _dataElementOptions: [
            "backgroundColor",
            "borderColor",
            "borderWidth",
            "hoverBackgroundColor",
            "hoverBorderColor",
            "hoverBorderWidth",
            "hoverRadius",
            "hitRadius",
            "pointStyle",
            "rotation"
          ],
          update: function(reset) {
            var me = this;
            var meta = me.getMeta();
            var points = meta.data;
            helpers$1.each(points, function(point, index) {
              me.updateElement(point, index, reset);
            });
          },
          updateElement: function(point, index, reset) {
            var me = this;
            var meta = me.getMeta();
            var custom = point.custom || {};
            var xScale = me.getScaleForId(meta.xAxisID);
            var yScale = me.getScaleForId(meta.yAxisID);
            var options2 = me._resolveDataElementOptions(point, index);
            var data = me.getDataset().data[index];
            var dsIndex = me.index;
            var x = reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(typeof data === "object" ? data : NaN, index, dsIndex);
            var y = reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index, dsIndex);
            point._xScale = xScale;
            point._yScale = yScale;
            point._options = options2;
            point._datasetIndex = dsIndex;
            point._index = index;
            point._model = {
              backgroundColor: options2.backgroundColor,
              borderColor: options2.borderColor,
              borderWidth: options2.borderWidth,
              hitRadius: options2.hitRadius,
              pointStyle: options2.pointStyle,
              rotation: options2.rotation,
              radius: reset ? 0 : options2.radius,
              skip: custom.skip || isNaN(x) || isNaN(y),
              x,
              y
            };
            point.pivot();
          },
          setHoverStyle: function(point) {
            var model = point._model;
            var options2 = point._options;
            var getHoverColor = helpers$1.getHoverColor;
            point.$previousStyle = {
              backgroundColor: model.backgroundColor,
              borderColor: model.borderColor,
              borderWidth: model.borderWidth,
              radius: model.radius
            };
            model.backgroundColor = valueOrDefault$4(options2.hoverBackgroundColor, getHoverColor(options2.backgroundColor));
            model.borderColor = valueOrDefault$4(options2.hoverBorderColor, getHoverColor(options2.borderColor));
            model.borderWidth = valueOrDefault$4(options2.hoverBorderWidth, options2.borderWidth);
            model.radius = options2.radius + options2.hoverRadius;
          },
          _resolveDataElementOptions: function(point, index) {
            var me = this;
            var chart = me.chart;
            var dataset = me.getDataset();
            var custom = point.custom || {};
            var data = dataset.data[index] || {};
            var values = core_datasetController.prototype._resolveDataElementOptions.apply(me, arguments);
            var context = {
              chart,
              dataIndex: index,
              dataset,
              datasetIndex: me.index
            };
            if (me._cachedDataOpts === values) {
              values = helpers$1.extend({}, values);
            }
            values.radius = resolve$1([
              custom.radius,
              data.r,
              me._config.radius,
              chart.options.elements.point.radius
            ], context, index);
            return values;
          }
        });
        var valueOrDefault$5 = helpers$1.valueOrDefault;
        var PI$1 = Math.PI;
        var DOUBLE_PI$1 = PI$1 * 2;
        var HALF_PI$1 = PI$1 / 2;
        core_defaults._set("doughnut", {
          animation: {
            animateRotate: true,
            animateScale: false
          },
          hover: {
            mode: "single"
          },
          legendCallback: function(chart) {
            var list = document.createElement("ul");
            var data = chart.data;
            var datasets = data.datasets;
            var labels = data.labels;
            var i, ilen, listItem, listItemSpan;
            list.setAttribute("class", chart.id + "-legend");
            if (datasets.length) {
              for (i = 0, ilen = datasets[0].data.length; i < ilen; ++i) {
                listItem = list.appendChild(document.createElement("li"));
                listItemSpan = listItem.appendChild(document.createElement("span"));
                listItemSpan.style.backgroundColor = datasets[0].backgroundColor[i];
                if (labels[i]) {
                  listItem.appendChild(document.createTextNode(labels[i]));
                }
              }
            }
            return list.outerHTML;
          },
          legend: {
            labels: {
              generateLabels: function(chart) {
                var data = chart.data;
                if (data.labels.length && data.datasets.length) {
                  return data.labels.map(function(label, i) {
                    var meta = chart.getDatasetMeta(0);
                    var style = meta.controller.getStyle(i);
                    return {
                      text: label,
                      fillStyle: style.backgroundColor,
                      strokeStyle: style.borderColor,
                      lineWidth: style.borderWidth,
                      hidden: isNaN(data.datasets[0].data[i]) || meta.data[i].hidden,
                      index: i
                    };
                  });
                }
                return [];
              }
            },
            onClick: function(e, legendItem) {
              var index = legendItem.index;
              var chart = this.chart;
              var i, ilen, meta;
              for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
                meta = chart.getDatasetMeta(i);
                if (meta.data[index]) {
                  meta.data[index].hidden = !meta.data[index].hidden;
                }
              }
              chart.update();
            }
          },
          cutoutPercentage: 50,
          rotation: -HALF_PI$1,
          circumference: DOUBLE_PI$1,
          tooltips: {
            callbacks: {
              title: function() {
                return "";
              },
              label: function(tooltipItem, data) {
                var dataLabel = data.labels[tooltipItem.index];
                var value = ": " + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];
                if (helpers$1.isArray(dataLabel)) {
                  dataLabel = dataLabel.slice();
                  dataLabel[0] += value;
                } else {
                  dataLabel += value;
                }
                return dataLabel;
              }
            }
          }
        });
        var controller_doughnut = core_datasetController.extend({
          dataElementType: elements.Arc,
          linkScales: helpers$1.noop,
          _dataElementOptions: [
            "backgroundColor",
            "borderColor",
            "borderWidth",
            "borderAlign",
            "hoverBackgroundColor",
            "hoverBorderColor",
            "hoverBorderWidth"
          ],
          getRingIndex: function(datasetIndex) {
            var ringIndex = 0;
            for (var j = 0; j < datasetIndex; ++j) {
              if (this.chart.isDatasetVisible(j)) {
                ++ringIndex;
              }
            }
            return ringIndex;
          },
          update: function(reset) {
            var me = this;
            var chart = me.chart;
            var chartArea = chart.chartArea;
            var opts = chart.options;
            var ratioX = 1;
            var ratioY = 1;
            var offsetX = 0;
            var offsetY = 0;
            var meta = me.getMeta();
            var arcs = meta.data;
            var cutout = opts.cutoutPercentage / 100 || 0;
            var circumference = opts.circumference;
            var chartWeight = me._getRingWeight(me.index);
            var maxWidth, maxHeight, i, ilen;
            if (circumference < DOUBLE_PI$1) {
              var startAngle = opts.rotation % DOUBLE_PI$1;
              startAngle += startAngle >= PI$1 ? -DOUBLE_PI$1 : startAngle < -PI$1 ? DOUBLE_PI$1 : 0;
              var endAngle = startAngle + circumference;
              var startX = Math.cos(startAngle);
              var startY = Math.sin(startAngle);
              var endX = Math.cos(endAngle);
              var endY = Math.sin(endAngle);
              var contains0 = startAngle <= 0 && endAngle >= 0 || endAngle >= DOUBLE_PI$1;
              var contains90 = startAngle <= HALF_PI$1 && endAngle >= HALF_PI$1 || endAngle >= DOUBLE_PI$1 + HALF_PI$1;
              var contains180 = startAngle === -PI$1 || endAngle >= PI$1;
              var contains270 = startAngle <= -HALF_PI$1 && endAngle >= -HALF_PI$1 || endAngle >= PI$1 + HALF_PI$1;
              var minX = contains180 ? -1 : Math.min(startX, startX * cutout, endX, endX * cutout);
              var minY = contains270 ? -1 : Math.min(startY, startY * cutout, endY, endY * cutout);
              var maxX = contains0 ? 1 : Math.max(startX, startX * cutout, endX, endX * cutout);
              var maxY = contains90 ? 1 : Math.max(startY, startY * cutout, endY, endY * cutout);
              ratioX = (maxX - minX) / 2;
              ratioY = (maxY - minY) / 2;
              offsetX = -(maxX + minX) / 2;
              offsetY = -(maxY + minY) / 2;
            }
            for (i = 0, ilen = arcs.length; i < ilen; ++i) {
              arcs[i]._options = me._resolveDataElementOptions(arcs[i], i);
            }
            chart.borderWidth = me.getMaxBorderWidth();
            maxWidth = (chartArea.right - chartArea.left - chart.borderWidth) / ratioX;
            maxHeight = (chartArea.bottom - chartArea.top - chart.borderWidth) / ratioY;
            chart.outerRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
            chart.innerRadius = Math.max(chart.outerRadius * cutout, 0);
            chart.radiusLength = (chart.outerRadius - chart.innerRadius) / (me._getVisibleDatasetWeightTotal() || 1);
            chart.offsetX = offsetX * chart.outerRadius;
            chart.offsetY = offsetY * chart.outerRadius;
            meta.total = me.calculateTotal();
            me.outerRadius = chart.outerRadius - chart.radiusLength * me._getRingWeightOffset(me.index);
            me.innerRadius = Math.max(me.outerRadius - chart.radiusLength * chartWeight, 0);
            for (i = 0, ilen = arcs.length; i < ilen; ++i) {
              me.updateElement(arcs[i], i, reset);
            }
          },
          updateElement: function(arc, index, reset) {
            var me = this;
            var chart = me.chart;
            var chartArea = chart.chartArea;
            var opts = chart.options;
            var animationOpts = opts.animation;
            var centerX = (chartArea.left + chartArea.right) / 2;
            var centerY = (chartArea.top + chartArea.bottom) / 2;
            var startAngle = opts.rotation;
            var endAngle = opts.rotation;
            var dataset = me.getDataset();
            var circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index]) * (opts.circumference / DOUBLE_PI$1);
            var innerRadius = reset && animationOpts.animateScale ? 0 : me.innerRadius;
            var outerRadius = reset && animationOpts.animateScale ? 0 : me.outerRadius;
            var options2 = arc._options || {};
            helpers$1.extend(arc, {
              _datasetIndex: me.index,
              _index: index,
              _model: {
                backgroundColor: options2.backgroundColor,
                borderColor: options2.borderColor,
                borderWidth: options2.borderWidth,
                borderAlign: options2.borderAlign,
                x: centerX + chart.offsetX,
                y: centerY + chart.offsetY,
                startAngle,
                endAngle,
                circumference,
                outerRadius,
                innerRadius,
                label: helpers$1.valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])
              }
            });
            var model = arc._model;
            if (!reset || !animationOpts.animateRotate) {
              if (index === 0) {
                model.startAngle = opts.rotation;
              } else {
                model.startAngle = me.getMeta().data[index - 1]._model.endAngle;
              }
              model.endAngle = model.startAngle + model.circumference;
            }
            arc.pivot();
          },
          calculateTotal: function() {
            var dataset = this.getDataset();
            var meta = this.getMeta();
            var total = 0;
            var value;
            helpers$1.each(meta.data, function(element2, index) {
              value = dataset.data[index];
              if (!isNaN(value) && !element2.hidden) {
                total += Math.abs(value);
              }
            });
            return total;
          },
          calculateCircumference: function(value) {
            var total = this.getMeta().total;
            if (total > 0 && !isNaN(value)) {
              return DOUBLE_PI$1 * (Math.abs(value) / total);
            }
            return 0;
          },
          getMaxBorderWidth: function(arcs) {
            var me = this;
            var max = 0;
            var chart = me.chart;
            var i, ilen, meta, arc, controller, options2, borderWidth, hoverWidth;
            if (!arcs) {
              for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
                if (chart.isDatasetVisible(i)) {
                  meta = chart.getDatasetMeta(i);
                  arcs = meta.data;
                  if (i !== me.index) {
                    controller = meta.controller;
                  }
                  break;
                }
              }
            }
            if (!arcs) {
              return 0;
            }
            for (i = 0, ilen = arcs.length; i < ilen; ++i) {
              arc = arcs[i];
              if (controller) {
                controller._configure();
                options2 = controller._resolveDataElementOptions(arc, i);
              } else {
                options2 = arc._options;
              }
              if (options2.borderAlign !== "inner") {
                borderWidth = options2.borderWidth;
                hoverWidth = options2.hoverBorderWidth;
                max = borderWidth > max ? borderWidth : max;
                max = hoverWidth > max ? hoverWidth : max;
              }
            }
            return max;
          },
          setHoverStyle: function(arc) {
            var model = arc._model;
            var options2 = arc._options;
            var getHoverColor = helpers$1.getHoverColor;
            arc.$previousStyle = {
              backgroundColor: model.backgroundColor,
              borderColor: model.borderColor,
              borderWidth: model.borderWidth
            };
            model.backgroundColor = valueOrDefault$5(options2.hoverBackgroundColor, getHoverColor(options2.backgroundColor));
            model.borderColor = valueOrDefault$5(options2.hoverBorderColor, getHoverColor(options2.borderColor));
            model.borderWidth = valueOrDefault$5(options2.hoverBorderWidth, options2.borderWidth);
          },
          _getRingWeightOffset: function(datasetIndex) {
            var ringWeightOffset = 0;
            for (var i = 0; i < datasetIndex; ++i) {
              if (this.chart.isDatasetVisible(i)) {
                ringWeightOffset += this._getRingWeight(i);
              }
            }
            return ringWeightOffset;
          },
          _getRingWeight: function(dataSetIndex) {
            return Math.max(valueOrDefault$5(this.chart.data.datasets[dataSetIndex].weight, 1), 0);
          },
          _getVisibleDatasetWeightTotal: function() {
            return this._getRingWeightOffset(this.chart.data.datasets.length);
          }
        });
        core_defaults._set("horizontalBar", {
          hover: {
            mode: "index",
            axis: "y"
          },
          scales: {
            xAxes: [{
              type: "linear",
              position: "bottom"
            }],
            yAxes: [{
              type: "category",
              position: "left",
              offset: true,
              gridLines: {
                offsetGridLines: true
              }
            }]
          },
          elements: {
            rectangle: {
              borderSkipped: "left"
            }
          },
          tooltips: {
            mode: "index",
            axis: "y"
          }
        });
        core_defaults._set("global", {
          datasets: {
            horizontalBar: {
              categoryPercentage: 0.8,
              barPercentage: 0.9
            }
          }
        });
        var controller_horizontalBar = controller_bar.extend({
          _getValueScaleId: function() {
            return this.getMeta().xAxisID;
          },
          _getIndexScaleId: function() {
            return this.getMeta().yAxisID;
          }
        });
        var valueOrDefault$6 = helpers$1.valueOrDefault;
        var resolve$2 = helpers$1.options.resolve;
        var isPointInArea = helpers$1.canvas._isPointInArea;
        core_defaults._set("line", {
          showLines: true,
          spanGaps: false,
          hover: {
            mode: "label"
          },
          scales: {
            xAxes: [{
              type: "category",
              id: "x-axis-0"
            }],
            yAxes: [{
              type: "linear",
              id: "y-axis-0"
            }]
          }
        });
        function scaleClip(scale2, halfBorderWidth) {
          var tickOpts = scale2 && scale2.options.ticks || {};
          var reverse = tickOpts.reverse;
          var min = tickOpts.min === void 0 ? halfBorderWidth : 0;
          var max = tickOpts.max === void 0 ? halfBorderWidth : 0;
          return {
            start: reverse ? max : min,
            end: reverse ? min : max
          };
        }
        function defaultClip(xScale, yScale, borderWidth) {
          var halfBorderWidth = borderWidth / 2;
          var x = scaleClip(xScale, halfBorderWidth);
          var y = scaleClip(yScale, halfBorderWidth);
          return {
            top: y.end,
            right: x.end,
            bottom: y.start,
            left: x.start
          };
        }
        function toClip(value) {
          var t, r, b, l;
          if (helpers$1.isObject(value)) {
            t = value.top;
            r = value.right;
            b = value.bottom;
            l = value.left;
          } else {
            t = r = b = l = value;
          }
          return {
            top: t,
            right: r,
            bottom: b,
            left: l
          };
        }
        var controller_line = core_datasetController.extend({
          datasetElementType: elements.Line,
          dataElementType: elements.Point,
          _datasetElementOptions: [
            "backgroundColor",
            "borderCapStyle",
            "borderColor",
            "borderDash",
            "borderDashOffset",
            "borderJoinStyle",
            "borderWidth",
            "cubicInterpolationMode",
            "fill"
          ],
          _dataElementOptions: {
            backgroundColor: "pointBackgroundColor",
            borderColor: "pointBorderColor",
            borderWidth: "pointBorderWidth",
            hitRadius: "pointHitRadius",
            hoverBackgroundColor: "pointHoverBackgroundColor",
            hoverBorderColor: "pointHoverBorderColor",
            hoverBorderWidth: "pointHoverBorderWidth",
            hoverRadius: "pointHoverRadius",
            pointStyle: "pointStyle",
            radius: "pointRadius",
            rotation: "pointRotation"
          },
          update: function(reset) {
            var me = this;
            var meta = me.getMeta();
            var line = meta.dataset;
            var points = meta.data || [];
            var options2 = me.chart.options;
            var config = me._config;
            var showLine = me._showLine = valueOrDefault$6(config.showLine, options2.showLines);
            var i, ilen;
            me._xScale = me.getScaleForId(meta.xAxisID);
            me._yScale = me.getScaleForId(meta.yAxisID);
            if (showLine) {
              if (config.tension !== void 0 && config.lineTension === void 0) {
                config.lineTension = config.tension;
              }
              line._scale = me._yScale;
              line._datasetIndex = me.index;
              line._children = points;
              line._model = me._resolveDatasetElementOptions(line);
              line.pivot();
            }
            for (i = 0, ilen = points.length; i < ilen; ++i) {
              me.updateElement(points[i], i, reset);
            }
            if (showLine && line._model.tension !== 0) {
              me.updateBezierControlPoints();
            }
            for (i = 0, ilen = points.length; i < ilen; ++i) {
              points[i].pivot();
            }
          },
          updateElement: function(point, index, reset) {
            var me = this;
            var meta = me.getMeta();
            var custom = point.custom || {};
            var dataset = me.getDataset();
            var datasetIndex = me.index;
            var value = dataset.data[index];
            var xScale = me._xScale;
            var yScale = me._yScale;
            var lineModel = meta.dataset._model;
            var x, y;
            var options2 = me._resolveDataElementOptions(point, index);
            x = xScale.getPixelForValue(typeof value === "object" ? value : NaN, index, datasetIndex);
            y = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex);
            point._xScale = xScale;
            point._yScale = yScale;
            point._options = options2;
            point._datasetIndex = datasetIndex;
            point._index = index;
            point._model = {
              x,
              y,
              skip: custom.skip || isNaN(x) || isNaN(y),
              radius: options2.radius,
              pointStyle: options2.pointStyle,
              rotation: options2.rotation,
              backgroundColor: options2.backgroundColor,
              borderColor: options2.borderColor,
              borderWidth: options2.borderWidth,
              tension: valueOrDefault$6(custom.tension, lineModel ? lineModel.tension : 0),
              steppedLine: lineModel ? lineModel.steppedLine : false,
              hitRadius: options2.hitRadius
            };
          },
          _resolveDatasetElementOptions: function(element2) {
            var me = this;
            var config = me._config;
            var custom = element2.custom || {};
            var options2 = me.chart.options;
            var lineOptions = options2.elements.line;
            var values = core_datasetController.prototype._resolveDatasetElementOptions.apply(me, arguments);
            values.spanGaps = valueOrDefault$6(config.spanGaps, options2.spanGaps);
            values.tension = valueOrDefault$6(config.lineTension, lineOptions.tension);
            values.steppedLine = resolve$2([custom.steppedLine, config.steppedLine, lineOptions.stepped]);
            values.clip = toClip(valueOrDefault$6(config.clip, defaultClip(me._xScale, me._yScale, values.borderWidth)));
            return values;
          },
          calculatePointY: function(value, index, datasetIndex) {
            var me = this;
            var chart = me.chart;
            var yScale = me._yScale;
            var sumPos = 0;
            var sumNeg = 0;
            var i, ds, dsMeta, stackedRightValue, rightValue, metasets, ilen;
            if (yScale.options.stacked) {
              rightValue = +yScale.getRightValue(value);
              metasets = chart._getSortedVisibleDatasetMetas();
              ilen = metasets.length;
              for (i = 0; i < ilen; ++i) {
                dsMeta = metasets[i];
                if (dsMeta.index === datasetIndex) {
                  break;
                }
                ds = chart.data.datasets[dsMeta.index];
                if (dsMeta.type === "line" && dsMeta.yAxisID === yScale.id) {
                  stackedRightValue = +yScale.getRightValue(ds.data[index]);
                  if (stackedRightValue < 0) {
                    sumNeg += stackedRightValue || 0;
                  } else {
                    sumPos += stackedRightValue || 0;
                  }
                }
              }
              if (rightValue < 0) {
                return yScale.getPixelForValue(sumNeg + rightValue);
              }
              return yScale.getPixelForValue(sumPos + rightValue);
            }
            return yScale.getPixelForValue(value);
          },
          updateBezierControlPoints: function() {
            var me = this;
            var chart = me.chart;
            var meta = me.getMeta();
            var lineModel = meta.dataset._model;
            var area = chart.chartArea;
            var points = meta.data || [];
            var i, ilen, model, controlPoints;
            if (lineModel.spanGaps) {
              points = points.filter(function(pt) {
                return !pt._model.skip;
              });
            }
            function capControlPoint(pt, min, max) {
              return Math.max(Math.min(pt, max), min);
            }
            if (lineModel.cubicInterpolationMode === "monotone") {
              helpers$1.splineCurveMonotone(points);
            } else {
              for (i = 0, ilen = points.length; i < ilen; ++i) {
                model = points[i]._model;
                controlPoints = helpers$1.splineCurve(helpers$1.previousItem(points, i)._model, model, helpers$1.nextItem(points, i)._model, lineModel.tension);
                model.controlPointPreviousX = controlPoints.previous.x;
                model.controlPointPreviousY = controlPoints.previous.y;
                model.controlPointNextX = controlPoints.next.x;
                model.controlPointNextY = controlPoints.next.y;
              }
            }
            if (chart.options.elements.line.capBezierPoints) {
              for (i = 0, ilen = points.length; i < ilen; ++i) {
                model = points[i]._model;
                if (isPointInArea(model, area)) {
                  if (i > 0 && isPointInArea(points[i - 1]._model, area)) {
                    model.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);
                    model.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);
                  }
                  if (i < points.length - 1 && isPointInArea(points[i + 1]._model, area)) {
                    model.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);
                    model.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);
                  }
                }
              }
            }
          },
          draw: function() {
            var me = this;
            var chart = me.chart;
            var meta = me.getMeta();
            var points = meta.data || [];
            var area = chart.chartArea;
            var canvas2 = chart.canvas;
            var i = 0;
            var ilen = points.length;
            var clip;
            if (me._showLine) {
              clip = meta.dataset._model.clip;
              helpers$1.canvas.clipArea(chart.ctx, {
                left: clip.left === false ? 0 : area.left - clip.left,
                right: clip.right === false ? canvas2.width : area.right + clip.right,
                top: clip.top === false ? 0 : area.top - clip.top,
                bottom: clip.bottom === false ? canvas2.height : area.bottom + clip.bottom
              });
              meta.dataset.draw();
              helpers$1.canvas.unclipArea(chart.ctx);
            }
            for (; i < ilen; ++i) {
              points[i].draw(area);
            }
          },
          setHoverStyle: function(point) {
            var model = point._model;
            var options2 = point._options;
            var getHoverColor = helpers$1.getHoverColor;
            point.$previousStyle = {
              backgroundColor: model.backgroundColor,
              borderColor: model.borderColor,
              borderWidth: model.borderWidth,
              radius: model.radius
            };
            model.backgroundColor = valueOrDefault$6(options2.hoverBackgroundColor, getHoverColor(options2.backgroundColor));
            model.borderColor = valueOrDefault$6(options2.hoverBorderColor, getHoverColor(options2.borderColor));
            model.borderWidth = valueOrDefault$6(options2.hoverBorderWidth, options2.borderWidth);
            model.radius = valueOrDefault$6(options2.hoverRadius, options2.radius);
          }
        });
        var resolve$3 = helpers$1.options.resolve;
        core_defaults._set("polarArea", {
          scale: {
            type: "radialLinear",
            angleLines: {
              display: false
            },
            gridLines: {
              circular: true
            },
            pointLabels: {
              display: false
            },
            ticks: {
              beginAtZero: true
            }
          },
          animation: {
            animateRotate: true,
            animateScale: true
          },
          startAngle: -0.5 * Math.PI,
          legendCallback: function(chart) {
            var list = document.createElement("ul");
            var data = chart.data;
            var datasets = data.datasets;
            var labels = data.labels;
            var i, ilen, listItem, listItemSpan;
            list.setAttribute("class", chart.id + "-legend");
            if (datasets.length) {
              for (i = 0, ilen = datasets[0].data.length; i < ilen; ++i) {
                listItem = list.appendChild(document.createElement("li"));
                listItemSpan = listItem.appendChild(document.createElement("span"));
                listItemSpan.style.backgroundColor = datasets[0].backgroundColor[i];
                if (labels[i]) {
                  listItem.appendChild(document.createTextNode(labels[i]));
                }
              }
            }
            return list.outerHTML;
          },
          legend: {
            labels: {
              generateLabels: function(chart) {
                var data = chart.data;
                if (data.labels.length && data.datasets.length) {
                  return data.labels.map(function(label, i) {
                    var meta = chart.getDatasetMeta(0);
                    var style = meta.controller.getStyle(i);
                    return {
                      text: label,
                      fillStyle: style.backgroundColor,
                      strokeStyle: style.borderColor,
                      lineWidth: style.borderWidth,
                      hidden: isNaN(data.datasets[0].data[i]) || meta.data[i].hidden,
                      index: i
                    };
                  });
                }
                return [];
              }
            },
            onClick: function(e, legendItem) {
              var index = legendItem.index;
              var chart = this.chart;
              var i, ilen, meta;
              for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
                meta = chart.getDatasetMeta(i);
                meta.data[index].hidden = !meta.data[index].hidden;
              }
              chart.update();
            }
          },
          tooltips: {
            callbacks: {
              title: function() {
                return "";
              },
              label: function(item2, data) {
                return data.labels[item2.index] + ": " + item2.yLabel;
              }
            }
          }
        });
        var controller_polarArea = core_datasetController.extend({
          dataElementType: elements.Arc,
          linkScales: helpers$1.noop,
          _dataElementOptions: [
            "backgroundColor",
            "borderColor",
            "borderWidth",
            "borderAlign",
            "hoverBackgroundColor",
            "hoverBorderColor",
            "hoverBorderWidth"
          ],
          _getIndexScaleId: function() {
            return this.chart.scale.id;
          },
          _getValueScaleId: function() {
            return this.chart.scale.id;
          },
          update: function(reset) {
            var me = this;
            var dataset = me.getDataset();
            var meta = me.getMeta();
            var start2 = me.chart.options.startAngle || 0;
            var starts = me._starts = [];
            var angles = me._angles = [];
            var arcs = meta.data;
            var i, ilen, angle;
            me._updateRadius();
            meta.count = me.countVisibleElements();
            for (i = 0, ilen = dataset.data.length; i < ilen; i++) {
              starts[i] = start2;
              angle = me._computeAngle(i);
              angles[i] = angle;
              start2 += angle;
            }
            for (i = 0, ilen = arcs.length; i < ilen; ++i) {
              arcs[i]._options = me._resolveDataElementOptions(arcs[i], i);
              me.updateElement(arcs[i], i, reset);
            }
          },
          _updateRadius: function() {
            var me = this;
            var chart = me.chart;
            var chartArea = chart.chartArea;
            var opts = chart.options;
            var minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
            chart.outerRadius = Math.max(minSize / 2, 0);
            chart.innerRadius = Math.max(opts.cutoutPercentage ? chart.outerRadius / 100 * opts.cutoutPercentage : 1, 0);
            chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();
            me.outerRadius = chart.outerRadius - chart.radiusLength * me.index;
            me.innerRadius = me.outerRadius - chart.radiusLength;
          },
          updateElement: function(arc, index, reset) {
            var me = this;
            var chart = me.chart;
            var dataset = me.getDataset();
            var opts = chart.options;
            var animationOpts = opts.animation;
            var scale2 = chart.scale;
            var labels = chart.data.labels;
            var centerX = scale2.xCenter;
            var centerY = scale2.yCenter;
            var datasetStartAngle = opts.startAngle;
            var distance = arc.hidden ? 0 : scale2.getDistanceFromCenterForValue(dataset.data[index]);
            var startAngle = me._starts[index];
            var endAngle = startAngle + (arc.hidden ? 0 : me._angles[index]);
            var resetRadius = animationOpts.animateScale ? 0 : scale2.getDistanceFromCenterForValue(dataset.data[index]);
            var options2 = arc._options || {};
            helpers$1.extend(arc, {
              _datasetIndex: me.index,
              _index: index,
              _scale: scale2,
              _model: {
                backgroundColor: options2.backgroundColor,
                borderColor: options2.borderColor,
                borderWidth: options2.borderWidth,
                borderAlign: options2.borderAlign,
                x: centerX,
                y: centerY,
                innerRadius: 0,
                outerRadius: reset ? resetRadius : distance,
                startAngle: reset && animationOpts.animateRotate ? datasetStartAngle : startAngle,
                endAngle: reset && animationOpts.animateRotate ? datasetStartAngle : endAngle,
                label: helpers$1.valueAtIndexOrDefault(labels, index, labels[index])
              }
            });
            arc.pivot();
          },
          countVisibleElements: function() {
            var dataset = this.getDataset();
            var meta = this.getMeta();
            var count = 0;
            helpers$1.each(meta.data, function(element2, index) {
              if (!isNaN(dataset.data[index]) && !element2.hidden) {
                count++;
              }
            });
            return count;
          },
          setHoverStyle: function(arc) {
            var model = arc._model;
            var options2 = arc._options;
            var getHoverColor = helpers$1.getHoverColor;
            var valueOrDefault2 = helpers$1.valueOrDefault;
            arc.$previousStyle = {
              backgroundColor: model.backgroundColor,
              borderColor: model.borderColor,
              borderWidth: model.borderWidth
            };
            model.backgroundColor = valueOrDefault2(options2.hoverBackgroundColor, getHoverColor(options2.backgroundColor));
            model.borderColor = valueOrDefault2(options2.hoverBorderColor, getHoverColor(options2.borderColor));
            model.borderWidth = valueOrDefault2(options2.hoverBorderWidth, options2.borderWidth);
          },
          _computeAngle: function(index) {
            var me = this;
            var count = this.getMeta().count;
            var dataset = me.getDataset();
            var meta = me.getMeta();
            if (isNaN(dataset.data[index]) || meta.data[index].hidden) {
              return 0;
            }
            var context = {
              chart: me.chart,
              dataIndex: index,
              dataset,
              datasetIndex: me.index
            };
            return resolve$3([
              me.chart.options.elements.arc.angle,
              2 * Math.PI / count
            ], context, index);
          }
        });
        core_defaults._set("pie", helpers$1.clone(core_defaults.doughnut));
        core_defaults._set("pie", {
          cutoutPercentage: 0
        });
        var controller_pie = controller_doughnut;
        var valueOrDefault$7 = helpers$1.valueOrDefault;
        core_defaults._set("radar", {
          spanGaps: false,
          scale: {
            type: "radialLinear"
          },
          elements: {
            line: {
              fill: "start",
              tension: 0
            }
          }
        });
        var controller_radar = core_datasetController.extend({
          datasetElementType: elements.Line,
          dataElementType: elements.Point,
          linkScales: helpers$1.noop,
          _datasetElementOptions: [
            "backgroundColor",
            "borderWidth",
            "borderColor",
            "borderCapStyle",
            "borderDash",
            "borderDashOffset",
            "borderJoinStyle",
            "fill"
          ],
          _dataElementOptions: {
            backgroundColor: "pointBackgroundColor",
            borderColor: "pointBorderColor",
            borderWidth: "pointBorderWidth",
            hitRadius: "pointHitRadius",
            hoverBackgroundColor: "pointHoverBackgroundColor",
            hoverBorderColor: "pointHoverBorderColor",
            hoverBorderWidth: "pointHoverBorderWidth",
            hoverRadius: "pointHoverRadius",
            pointStyle: "pointStyle",
            radius: "pointRadius",
            rotation: "pointRotation"
          },
          _getIndexScaleId: function() {
            return this.chart.scale.id;
          },
          _getValueScaleId: function() {
            return this.chart.scale.id;
          },
          update: function(reset) {
            var me = this;
            var meta = me.getMeta();
            var line = meta.dataset;
            var points = meta.data || [];
            var scale2 = me.chart.scale;
            var config = me._config;
            var i, ilen;
            if (config.tension !== void 0 && config.lineTension === void 0) {
              config.lineTension = config.tension;
            }
            line._scale = scale2;
            line._datasetIndex = me.index;
            line._children = points;
            line._loop = true;
            line._model = me._resolveDatasetElementOptions(line);
            line.pivot();
            for (i = 0, ilen = points.length; i < ilen; ++i) {
              me.updateElement(points[i], i, reset);
            }
            me.updateBezierControlPoints();
            for (i = 0, ilen = points.length; i < ilen; ++i) {
              points[i].pivot();
            }
          },
          updateElement: function(point, index, reset) {
            var me = this;
            var custom = point.custom || {};
            var dataset = me.getDataset();
            var scale2 = me.chart.scale;
            var pointPosition = scale2.getPointPositionForValue(index, dataset.data[index]);
            var options2 = me._resolveDataElementOptions(point, index);
            var lineModel = me.getMeta().dataset._model;
            var x = reset ? scale2.xCenter : pointPosition.x;
            var y = reset ? scale2.yCenter : pointPosition.y;
            point._scale = scale2;
            point._options = options2;
            point._datasetIndex = me.index;
            point._index = index;
            point._model = {
              x,
              y,
              skip: custom.skip || isNaN(x) || isNaN(y),
              radius: options2.radius,
              pointStyle: options2.pointStyle,
              rotation: options2.rotation,
              backgroundColor: options2.backgroundColor,
              borderColor: options2.borderColor,
              borderWidth: options2.borderWidth,
              tension: valueOrDefault$7(custom.tension, lineModel ? lineModel.tension : 0),
              hitRadius: options2.hitRadius
            };
          },
          _resolveDatasetElementOptions: function() {
            var me = this;
            var config = me._config;
            var options2 = me.chart.options;
            var values = core_datasetController.prototype._resolveDatasetElementOptions.apply(me, arguments);
            values.spanGaps = valueOrDefault$7(config.spanGaps, options2.spanGaps);
            values.tension = valueOrDefault$7(config.lineTension, options2.elements.line.tension);
            return values;
          },
          updateBezierControlPoints: function() {
            var me = this;
            var meta = me.getMeta();
            var area = me.chart.chartArea;
            var points = meta.data || [];
            var i, ilen, model, controlPoints;
            if (meta.dataset._model.spanGaps) {
              points = points.filter(function(pt) {
                return !pt._model.skip;
              });
            }
            function capControlPoint(pt, min, max) {
              return Math.max(Math.min(pt, max), min);
            }
            for (i = 0, ilen = points.length; i < ilen; ++i) {
              model = points[i]._model;
              controlPoints = helpers$1.splineCurve(helpers$1.previousItem(points, i, true)._model, model, helpers$1.nextItem(points, i, true)._model, model.tension);
              model.controlPointPreviousX = capControlPoint(controlPoints.previous.x, area.left, area.right);
              model.controlPointPreviousY = capControlPoint(controlPoints.previous.y, area.top, area.bottom);
              model.controlPointNextX = capControlPoint(controlPoints.next.x, area.left, area.right);
              model.controlPointNextY = capControlPoint(controlPoints.next.y, area.top, area.bottom);
            }
          },
          setHoverStyle: function(point) {
            var model = point._model;
            var options2 = point._options;
            var getHoverColor = helpers$1.getHoverColor;
            point.$previousStyle = {
              backgroundColor: model.backgroundColor,
              borderColor: model.borderColor,
              borderWidth: model.borderWidth,
              radius: model.radius
            };
            model.backgroundColor = valueOrDefault$7(options2.hoverBackgroundColor, getHoverColor(options2.backgroundColor));
            model.borderColor = valueOrDefault$7(options2.hoverBorderColor, getHoverColor(options2.borderColor));
            model.borderWidth = valueOrDefault$7(options2.hoverBorderWidth, options2.borderWidth);
            model.radius = valueOrDefault$7(options2.hoverRadius, options2.radius);
          }
        });
        core_defaults._set("scatter", {
          hover: {
            mode: "single"
          },
          scales: {
            xAxes: [{
              id: "x-axis-1",
              type: "linear",
              position: "bottom"
            }],
            yAxes: [{
              id: "y-axis-1",
              type: "linear",
              position: "left"
            }]
          },
          tooltips: {
            callbacks: {
              title: function() {
                return "";
              },
              label: function(item2) {
                return "(" + item2.xLabel + ", " + item2.yLabel + ")";
              }
            }
          }
        });
        core_defaults._set("global", {
          datasets: {
            scatter: {
              showLine: false
            }
          }
        });
        var controller_scatter = controller_line;
        var controllers = {
          bar: controller_bar,
          bubble: controller_bubble,
          doughnut: controller_doughnut,
          horizontalBar: controller_horizontalBar,
          line: controller_line,
          polarArea: controller_polarArea,
          pie: controller_pie,
          radar: controller_radar,
          scatter: controller_scatter
        };
        function getRelativePosition(e, chart) {
          if (e.native) {
            return {
              x: e.x,
              y: e.y
            };
          }
          return helpers$1.getRelativePosition(e, chart);
        }
        function parseVisibleItems(chart, handler) {
          var metasets = chart._getSortedVisibleDatasetMetas();
          var metadata, i, j, ilen, jlen, element2;
          for (i = 0, ilen = metasets.length; i < ilen; ++i) {
            metadata = metasets[i].data;
            for (j = 0, jlen = metadata.length; j < jlen; ++j) {
              element2 = metadata[j];
              if (!element2._view.skip) {
                handler(element2);
              }
            }
          }
        }
        function getIntersectItems(chart, position) {
          var elements2 = [];
          parseVisibleItems(chart, function(element2) {
            if (element2.inRange(position.x, position.y)) {
              elements2.push(element2);
            }
          });
          return elements2;
        }
        function getNearestItems(chart, position, intersect, distanceMetric) {
          var minDistance = Number.POSITIVE_INFINITY;
          var nearestItems = [];
          parseVisibleItems(chart, function(element2) {
            if (intersect && !element2.inRange(position.x, position.y)) {
              return;
            }
            var center = element2.getCenterPoint();
            var distance = distanceMetric(position, center);
            if (distance < minDistance) {
              nearestItems = [element2];
              minDistance = distance;
            } else if (distance === minDistance) {
              nearestItems.push(element2);
            }
          });
          return nearestItems;
        }
        function getDistanceMetricForAxis(axis) {
          var useX = axis.indexOf("x") !== -1;
          var useY = axis.indexOf("y") !== -1;
          return function(pt1, pt2) {
            var deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
            var deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
            return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
          };
        }
        function indexMode(chart, e, options2) {
          var position = getRelativePosition(e, chart);
          options2.axis = options2.axis || "x";
          var distanceMetric = getDistanceMetricForAxis(options2.axis);
          var items = options2.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);
          var elements2 = [];
          if (!items.length) {
            return [];
          }
          chart._getSortedVisibleDatasetMetas().forEach(function(meta) {
            var element2 = meta.data[items[0]._index];
            if (element2 && !element2._view.skip) {
              elements2.push(element2);
            }
          });
          return elements2;
        }
        var core_interaction = {
          modes: {
            single: function(chart, e) {
              var position = getRelativePosition(e, chart);
              var elements2 = [];
              parseVisibleItems(chart, function(element2) {
                if (element2.inRange(position.x, position.y)) {
                  elements2.push(element2);
                  return elements2;
                }
              });
              return elements2.slice(0, 1);
            },
            label: indexMode,
            index: indexMode,
            dataset: function(chart, e, options2) {
              var position = getRelativePosition(e, chart);
              options2.axis = options2.axis || "xy";
              var distanceMetric = getDistanceMetricForAxis(options2.axis);
              var items = options2.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);
              if (items.length > 0) {
                items = chart.getDatasetMeta(items[0]._datasetIndex).data;
              }
              return items;
            },
            "x-axis": function(chart, e) {
              return indexMode(chart, e, { intersect: false });
            },
            point: function(chart, e) {
              var position = getRelativePosition(e, chart);
              return getIntersectItems(chart, position);
            },
            nearest: function(chart, e, options2) {
              var position = getRelativePosition(e, chart);
              options2.axis = options2.axis || "xy";
              var distanceMetric = getDistanceMetricForAxis(options2.axis);
              return getNearestItems(chart, position, options2.intersect, distanceMetric);
            },
            x: function(chart, e, options2) {
              var position = getRelativePosition(e, chart);
              var items = [];
              var intersectsItem = false;
              parseVisibleItems(chart, function(element2) {
                if (element2.inXRange(position.x)) {
                  items.push(element2);
                }
                if (element2.inRange(position.x, position.y)) {
                  intersectsItem = true;
                }
              });
              if (options2.intersect && !intersectsItem) {
                items = [];
              }
              return items;
            },
            y: function(chart, e, options2) {
              var position = getRelativePosition(e, chart);
              var items = [];
              var intersectsItem = false;
              parseVisibleItems(chart, function(element2) {
                if (element2.inYRange(position.y)) {
                  items.push(element2);
                }
                if (element2.inRange(position.x, position.y)) {
                  intersectsItem = true;
                }
              });
              if (options2.intersect && !intersectsItem) {
                items = [];
              }
              return items;
            }
          }
        };
        var extend = helpers$1.extend;
        function filterByPosition(array, position) {
          return helpers$1.where(array, function(v) {
            return v.pos === position;
          });
        }
        function sortByWeight(array, reverse) {
          return array.sort(function(a, b) {
            var v0 = reverse ? b : a;
            var v1 = reverse ? a : b;
            return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
          });
        }
        function wrapBoxes(boxes) {
          var layoutBoxes = [];
          var i, ilen, box;
          for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {
            box = boxes[i];
            layoutBoxes.push({
              index: i,
              box,
              pos: box.position,
              horizontal: box.isHorizontal(),
              weight: box.weight
            });
          }
          return layoutBoxes;
        }
        function setLayoutDims(layouts, params2) {
          var i, ilen, layout;
          for (i = 0, ilen = layouts.length; i < ilen; ++i) {
            layout = layouts[i];
            layout.width = layout.horizontal ? layout.box.fullWidth && params2.availableWidth : params2.vBoxMaxWidth;
            layout.height = layout.horizontal && params2.hBoxMaxHeight;
          }
        }
        function buildLayoutBoxes(boxes) {
          var layoutBoxes = wrapBoxes(boxes);
          var left = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
          var right = sortByWeight(filterByPosition(layoutBoxes, "right"));
          var top = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
          var bottom = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
          return {
            leftAndTop: left.concat(top),
            rightAndBottom: right.concat(bottom),
            chartArea: filterByPosition(layoutBoxes, "chartArea"),
            vertical: left.concat(right),
            horizontal: top.concat(bottom)
          };
        }
        function getCombinedMax(maxPadding, chartArea, a, b) {
          return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
        }
        function updateDims(chartArea, params2, layout) {
          var box = layout.box;
          var maxPadding = chartArea.maxPadding;
          var newWidth, newHeight;
          if (layout.size) {
            chartArea[layout.pos] -= layout.size;
          }
          layout.size = layout.horizontal ? box.height : box.width;
          chartArea[layout.pos] += layout.size;
          if (box.getPadding) {
            var boxPadding = box.getPadding();
            maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
            maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
            maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
            maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
          }
          newWidth = params2.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right");
          newHeight = params2.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom");
          if (newWidth !== chartArea.w || newHeight !== chartArea.h) {
            chartArea.w = newWidth;
            chartArea.h = newHeight;
            var sizes = layout.horizontal ? [newWidth, chartArea.w] : [newHeight, chartArea.h];
            return sizes[0] !== sizes[1] && (!isNaN(sizes[0]) || !isNaN(sizes[1]));
          }
        }
        function handleMaxPadding(chartArea) {
          var maxPadding = chartArea.maxPadding;
          function updatePos(pos) {
            var change = Math.max(maxPadding[pos] - chartArea[pos], 0);
            chartArea[pos] += change;
            return change;
          }
          chartArea.y += updatePos("top");
          chartArea.x += updatePos("left");
          updatePos("right");
          updatePos("bottom");
        }
        function getMargins(horizontal, chartArea) {
          var maxPadding = chartArea.maxPadding;
          function marginForPositions(positions) {
            var margin = { left: 0, top: 0, right: 0, bottom: 0 };
            positions.forEach(function(pos) {
              margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
            });
            return margin;
          }
          return horizontal ? marginForPositions(["left", "right"]) : marginForPositions(["top", "bottom"]);
        }
        function fitBoxes(boxes, chartArea, params2) {
          var refitBoxes = [];
          var i, ilen, layout, box, refit, changed;
          for (i = 0, ilen = boxes.length; i < ilen; ++i) {
            layout = boxes[i];
            box = layout.box;
            box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
            if (updateDims(chartArea, params2, layout)) {
              changed = true;
              if (refitBoxes.length) {
                refit = true;
              }
            }
            if (!box.fullWidth) {
              refitBoxes.push(layout);
            }
          }
          return refit ? fitBoxes(refitBoxes, chartArea, params2) || changed : changed;
        }
        function placeBoxes(boxes, chartArea, params2) {
          var userPadding = params2.padding;
          var x = chartArea.x;
          var y = chartArea.y;
          var i, ilen, layout, box;
          for (i = 0, ilen = boxes.length; i < ilen; ++i) {
            layout = boxes[i];
            box = layout.box;
            if (layout.horizontal) {
              box.left = box.fullWidth ? userPadding.left : chartArea.left;
              box.right = box.fullWidth ? params2.outerWidth - userPadding.right : chartArea.left + chartArea.w;
              box.top = y;
              box.bottom = y + box.height;
              box.width = box.right - box.left;
              y = box.bottom;
            } else {
              box.left = x;
              box.right = x + box.width;
              box.top = chartArea.top;
              box.bottom = chartArea.top + chartArea.h;
              box.height = box.bottom - box.top;
              x = box.right;
            }
          }
          chartArea.x = x;
          chartArea.y = y;
        }
        core_defaults._set("global", {
          layout: {
            padding: {
              top: 0,
              right: 0,
              bottom: 0,
              left: 0
            }
          }
        });
        var core_layouts = {
          defaults: {},
          addBox: function(chart, item2) {
            if (!chart.boxes) {
              chart.boxes = [];
            }
            item2.fullWidth = item2.fullWidth || false;
            item2.position = item2.position || "top";
            item2.weight = item2.weight || 0;
            item2._layers = item2._layers || function() {
              return [{
                z: 0,
                draw: function() {
                  item2.draw.apply(item2, arguments);
                }
              }];
            };
            chart.boxes.push(item2);
          },
          removeBox: function(chart, layoutItem) {
            var index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
            if (index !== -1) {
              chart.boxes.splice(index, 1);
            }
          },
          configure: function(chart, item2, options2) {
            var props = ["fullWidth", "position", "weight"];
            var ilen = props.length;
            var i = 0;
            var prop;
            for (; i < ilen; ++i) {
              prop = props[i];
              if (options2.hasOwnProperty(prop)) {
                item2[prop] = options2[prop];
              }
            }
          },
          update: function(chart, width, height) {
            if (!chart) {
              return;
            }
            var layoutOptions = chart.options.layout || {};
            var padding = helpers$1.options.toPadding(layoutOptions.padding);
            var availableWidth = width - padding.width;
            var availableHeight = height - padding.height;
            var boxes = buildLayoutBoxes(chart.boxes);
            var verticalBoxes = boxes.vertical;
            var horizontalBoxes = boxes.horizontal;
            var params2 = Object.freeze({
              outerWidth: width,
              outerHeight: height,
              padding,
              availableWidth,
              vBoxMaxWidth: availableWidth / 2 / verticalBoxes.length,
              hBoxMaxHeight: availableHeight / 2
            });
            var chartArea = extend({
              maxPadding: extend({}, padding),
              w: availableWidth,
              h: availableHeight,
              x: padding.left,
              y: padding.top
            }, padding);
            setLayoutDims(verticalBoxes.concat(horizontalBoxes), params2);
            fitBoxes(verticalBoxes, chartArea, params2);
            if (fitBoxes(horizontalBoxes, chartArea, params2)) {
              fitBoxes(verticalBoxes, chartArea, params2);
            }
            handleMaxPadding(chartArea);
            placeBoxes(boxes.leftAndTop, chartArea, params2);
            chartArea.x += chartArea.w;
            chartArea.y += chartArea.h;
            placeBoxes(boxes.rightAndBottom, chartArea, params2);
            chart.chartArea = {
              left: chartArea.left,
              top: chartArea.top,
              right: chartArea.left + chartArea.w,
              bottom: chartArea.top + chartArea.h
            };
            helpers$1.each(boxes.chartArea, function(layout) {
              var box = layout.box;
              extend(box, chart.chartArea);
              box.update(chartArea.w, chartArea.h);
            });
          }
        };
        var platform_basic = {
          acquireContext: function(item2) {
            if (item2 && item2.canvas) {
              item2 = item2.canvas;
            }
            return item2 && item2.getContext("2d") || null;
          }
        };
        var platform_dom = "/*\r\n * DOM element rendering detection\r\n * https://davidwalsh.name/detect-node-insertion\r\n */\r\n@keyframes chartjs-render-animation {\r\n	from { opacity: 0.99; }\r\n	to { opacity: 1; }\r\n}\r\n\r\n.chartjs-render-monitor {\r\n	animation: chartjs-render-animation 0.001s;\r\n}\r\n\r\n/*\r\n * DOM element resizing detection\r\n * https://github.com/marcj/css-element-queries\r\n */\r\n.chartjs-size-monitor,\r\n.chartjs-size-monitor-expand,\r\n.chartjs-size-monitor-shrink {\r\n	position: absolute;\r\n	direction: ltr;\r\n	left: 0;\r\n	top: 0;\r\n	right: 0;\r\n	bottom: 0;\r\n	overflow: hidden;\r\n	pointer-events: none;\r\n	visibility: hidden;\r\n	z-index: -1;\r\n}\r\n\r\n.chartjs-size-monitor-expand > div {\r\n	position: absolute;\r\n	width: 1000000px;\r\n	height: 1000000px;\r\n	left: 0;\r\n	top: 0;\r\n}\r\n\r\n.chartjs-size-monitor-shrink > div {\r\n	position: absolute;\r\n	width: 200%;\r\n	height: 200%;\r\n	left: 0;\r\n	top: 0;\r\n}\r\n";
        var platform_dom$1 = /* @__PURE__ */ Object.freeze({
          __proto__: null,
          "default": platform_dom
        });
        var stylesheet = getCjsExportFromNamespace(platform_dom$1);
        var EXPANDO_KEY = "$chartjs";
        var CSS_PREFIX = "chartjs-";
        var CSS_SIZE_MONITOR = CSS_PREFIX + "size-monitor";
        var CSS_RENDER_MONITOR = CSS_PREFIX + "render-monitor";
        var CSS_RENDER_ANIMATION = CSS_PREFIX + "render-animation";
        var ANIMATION_START_EVENTS = ["animationstart", "webkitAnimationStart"];
        var EVENT_TYPES = {
          touchstart: "mousedown",
          touchmove: "mousemove",
          touchend: "mouseup",
          pointerenter: "mouseenter",
          pointerdown: "mousedown",
          pointermove: "mousemove",
          pointerup: "mouseup",
          pointerleave: "mouseout",
          pointerout: "mouseout"
        };
        function readUsedSize(element2, property) {
          var value = helpers$1.getStyle(element2, property);
          var matches = value && value.match(/^(\d+)(\.\d+)?px$/);
          return matches ? Number(matches[1]) : void 0;
        }
        function initCanvas(canvas2, config) {
          var style = canvas2.style;
          var renderHeight = canvas2.getAttribute("height");
          var renderWidth = canvas2.getAttribute("width");
          canvas2[EXPANDO_KEY] = {
            initial: {
              height: renderHeight,
              width: renderWidth,
              style: {
                display: style.display,
                height: style.height,
                width: style.width
              }
            }
          };
          style.display = style.display || "block";
          if (renderWidth === null || renderWidth === "") {
            var displayWidth = readUsedSize(canvas2, "width");
            if (displayWidth !== void 0) {
              canvas2.width = displayWidth;
            }
          }
          if (renderHeight === null || renderHeight === "") {
            if (canvas2.style.height === "") {
              canvas2.height = canvas2.width / (config.options.aspectRatio || 2);
            } else {
              var displayHeight = readUsedSize(canvas2, "height");
              if (displayWidth !== void 0) {
                canvas2.height = displayHeight;
              }
            }
          }
          return canvas2;
        }
        var supportsEventListenerOptions = function() {
          var supports = false;
          try {
            var options2 = Object.defineProperty({}, "passive", {
              get: function() {
                supports = true;
              }
            });
            window.addEventListener("e", null, options2);
          } catch (e) {
          }
          return supports;
        }();
        var eventListenerOptions = supportsEventListenerOptions ? { passive: true } : false;
        function addListener(node, type, listener) {
          node.addEventListener(type, listener, eventListenerOptions);
        }
        function removeListener(node, type, listener) {
          node.removeEventListener(type, listener, eventListenerOptions);
        }
        function createEvent(type, chart, x, y, nativeEvent) {
          return {
            type,
            chart,
            native: nativeEvent || null,
            x: x !== void 0 ? x : null,
            y: y !== void 0 ? y : null
          };
        }
        function fromNativeEvent(event, chart) {
          var type = EVENT_TYPES[event.type] || event.type;
          var pos = helpers$1.getRelativePosition(event, chart);
          return createEvent(type, chart, pos.x, pos.y, event);
        }
        function throttled(fn, thisArg) {
          var ticking = false;
          var args = [];
          return function() {
            args = Array.prototype.slice.call(arguments);
            thisArg = thisArg || this;
            if (!ticking) {
              ticking = true;
              helpers$1.requestAnimFrame.call(window, function() {
                ticking = false;
                fn.apply(thisArg, args);
              });
            }
          };
        }
        function createDiv(cls) {
          var el = document.createElement("div");
          el.className = cls || "";
          return el;
        }
        function createResizer(handler) {
          var maxSize = 1e6;
          var resizer = createDiv(CSS_SIZE_MONITOR);
          var expand = createDiv(CSS_SIZE_MONITOR + "-expand");
          var shrink = createDiv(CSS_SIZE_MONITOR + "-shrink");
          expand.appendChild(createDiv());
          shrink.appendChild(createDiv());
          resizer.appendChild(expand);
          resizer.appendChild(shrink);
          resizer._reset = function() {
            expand.scrollLeft = maxSize;
            expand.scrollTop = maxSize;
            shrink.scrollLeft = maxSize;
            shrink.scrollTop = maxSize;
          };
          var onScroll = function() {
            resizer._reset();
            handler();
          };
          addListener(expand, "scroll", onScroll.bind(expand, "expand"));
          addListener(shrink, "scroll", onScroll.bind(shrink, "shrink"));
          return resizer;
        }
        function watchForRender(node, handler) {
          var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});
          var proxy = expando.renderProxy = function(e) {
            if (e.animationName === CSS_RENDER_ANIMATION) {
              handler();
            }
          };
          helpers$1.each(ANIMATION_START_EVENTS, function(type) {
            addListener(node, type, proxy);
          });
          expando.reflow = !!node.offsetParent;
          node.classList.add(CSS_RENDER_MONITOR);
        }
        function unwatchForRender(node) {
          var expando = node[EXPANDO_KEY] || {};
          var proxy = expando.renderProxy;
          if (proxy) {
            helpers$1.each(ANIMATION_START_EVENTS, function(type) {
              removeListener(node, type, proxy);
            });
            delete expando.renderProxy;
          }
          node.classList.remove(CSS_RENDER_MONITOR);
        }
        function addResizeListener(node, listener, chart) {
          var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});
          var resizer = expando.resizer = createResizer(throttled(function() {
            if (expando.resizer) {
              var container = chart.options.maintainAspectRatio && node.parentNode;
              var w = container ? container.clientWidth : 0;
              listener(createEvent("resize", chart));
              if (container && container.clientWidth < w && chart.canvas) {
                listener(createEvent("resize", chart));
              }
            }
          }));
          watchForRender(node, function() {
            if (expando.resizer) {
              var container = node.parentNode;
              if (container && container !== resizer.parentNode) {
                container.insertBefore(resizer, container.firstChild);
              }
              resizer._reset();
            }
          });
        }
        function removeResizeListener(node) {
          var expando = node[EXPANDO_KEY] || {};
          var resizer = expando.resizer;
          delete expando.resizer;
          unwatchForRender(node);
          if (resizer && resizer.parentNode) {
            resizer.parentNode.removeChild(resizer);
          }
        }
        function injectCSS(rootNode, css) {
          var expando = rootNode[EXPANDO_KEY] || (rootNode[EXPANDO_KEY] = {});
          if (!expando.containsStyles) {
            expando.containsStyles = true;
            css = "/* Chart.js */\n" + css;
            var style = document.createElement("style");
            style.setAttribute("type", "text/css");
            style.appendChild(document.createTextNode(css));
            rootNode.appendChild(style);
          }
        }
        var platform_dom$2 = {
          disableCSSInjection: false,
          _enabled: typeof window !== "undefined" && typeof document !== "undefined",
          _ensureLoaded: function(canvas2) {
            if (!this.disableCSSInjection) {
              var root = canvas2.getRootNode ? canvas2.getRootNode() : document;
              var targetNode = root.host ? root : document.head;
              injectCSS(targetNode, stylesheet);
            }
          },
          acquireContext: function(item2, config) {
            if (typeof item2 === "string") {
              item2 = document.getElementById(item2);
            } else if (item2.length) {
              item2 = item2[0];
            }
            if (item2 && item2.canvas) {
              item2 = item2.canvas;
            }
            var context = item2 && item2.getContext && item2.getContext("2d");
            if (context && context.canvas === item2) {
              this._ensureLoaded(item2);
              initCanvas(item2, config);
              return context;
            }
            return null;
          },
          releaseContext: function(context) {
            var canvas2 = context.canvas;
            if (!canvas2[EXPANDO_KEY]) {
              return;
            }
            var initial = canvas2[EXPANDO_KEY].initial;
            ["height", "width"].forEach(function(prop) {
              var value = initial[prop];
              if (helpers$1.isNullOrUndef(value)) {
                canvas2.removeAttribute(prop);
              } else {
                canvas2.setAttribute(prop, value);
              }
            });
            helpers$1.each(initial.style || {}, function(value, key) {
              canvas2.style[key] = value;
            });
            canvas2.width = canvas2.width;
            delete canvas2[EXPANDO_KEY];
          },
          addEventListener: function(chart, type, listener) {
            var canvas2 = chart.canvas;
            if (type === "resize") {
              addResizeListener(canvas2, listener, chart);
              return;
            }
            var expando = listener[EXPANDO_KEY] || (listener[EXPANDO_KEY] = {});
            var proxies = expando.proxies || (expando.proxies = {});
            var proxy = proxies[chart.id + "_" + type] = function(event) {
              listener(fromNativeEvent(event, chart));
            };
            addListener(canvas2, type, proxy);
          },
          removeEventListener: function(chart, type, listener) {
            var canvas2 = chart.canvas;
            if (type === "resize") {
              removeResizeListener(canvas2);
              return;
            }
            var expando = listener[EXPANDO_KEY] || {};
            var proxies = expando.proxies || {};
            var proxy = proxies[chart.id + "_" + type];
            if (!proxy) {
              return;
            }
            removeListener(canvas2, type, proxy);
          }
        };
        helpers$1.addEvent = addListener;
        helpers$1.removeEvent = removeListener;
        var implementation = platform_dom$2._enabled ? platform_dom$2 : platform_basic;
        var platform = helpers$1.extend({
          initialize: function() {
          },
          acquireContext: function() {
          },
          releaseContext: function() {
          },
          addEventListener: function() {
          },
          removeEventListener: function() {
          }
        }, implementation);
        core_defaults._set("global", {
          plugins: {}
        });
        var core_plugins = {
          _plugins: [],
          _cacheId: 0,
          register: function(plugins2) {
            var p = this._plugins;
            [].concat(plugins2).forEach(function(plugin) {
              if (p.indexOf(plugin) === -1) {
                p.push(plugin);
              }
            });
            this._cacheId++;
          },
          unregister: function(plugins2) {
            var p = this._plugins;
            [].concat(plugins2).forEach(function(plugin) {
              var idx = p.indexOf(plugin);
              if (idx !== -1) {
                p.splice(idx, 1);
              }
            });
            this._cacheId++;
          },
          clear: function() {
            this._plugins = [];
            this._cacheId++;
          },
          count: function() {
            return this._plugins.length;
          },
          getAll: function() {
            return this._plugins;
          },
          notify: function(chart, hook, args) {
            var descriptors = this.descriptors(chart);
            var ilen = descriptors.length;
            var i, descriptor, plugin, params2, method;
            for (i = 0; i < ilen; ++i) {
              descriptor = descriptors[i];
              plugin = descriptor.plugin;
              method = plugin[hook];
              if (typeof method === "function") {
                params2 = [chart].concat(args || []);
                params2.push(descriptor.options);
                if (method.apply(plugin, params2) === false) {
                  return false;
                }
              }
            }
            return true;
          },
          descriptors: function(chart) {
            var cache = chart.$plugins || (chart.$plugins = {});
            if (cache.id === this._cacheId) {
              return cache.descriptors;
            }
            var plugins2 = [];
            var descriptors = [];
            var config = chart && chart.config || {};
            var options2 = config.options && config.options.plugins || {};
            this._plugins.concat(config.plugins || []).forEach(function(plugin) {
              var idx = plugins2.indexOf(plugin);
              if (idx !== -1) {
                return;
              }
              var id = plugin.id;
              var opts = options2[id];
              if (opts === false) {
                return;
              }
              if (opts === true) {
                opts = helpers$1.clone(core_defaults.global.plugins[id]);
              }
              plugins2.push(plugin);
              descriptors.push({
                plugin,
                options: opts || {}
              });
            });
            cache.descriptors = descriptors;
            cache.id = this._cacheId;
            return descriptors;
          },
          _invalidate: function(chart) {
            delete chart.$plugins;
          }
        };
        var core_scaleService = {
          constructors: {},
          defaults: {},
          registerScaleType: function(type, scaleConstructor, scaleDefaults) {
            this.constructors[type] = scaleConstructor;
            this.defaults[type] = helpers$1.clone(scaleDefaults);
          },
          getScaleConstructor: function(type) {
            return this.constructors.hasOwnProperty(type) ? this.constructors[type] : void 0;
          },
          getScaleDefaults: function(type) {
            return this.defaults.hasOwnProperty(type) ? helpers$1.merge(Object.create(null), [core_defaults.scale, this.defaults[type]]) : {};
          },
          updateScaleDefaults: function(type, additions) {
            var me = this;
            if (me.defaults.hasOwnProperty(type)) {
              me.defaults[type] = helpers$1.extend(me.defaults[type], additions);
            }
          },
          addScalesToLayout: function(chart) {
            helpers$1.each(chart.scales, function(scale2) {
              scale2.fullWidth = scale2.options.fullWidth;
              scale2.position = scale2.options.position;
              scale2.weight = scale2.options.weight;
              core_layouts.addBox(chart, scale2);
            });
          }
        };
        var valueOrDefault$8 = helpers$1.valueOrDefault;
        var getRtlHelper = helpers$1.rtl.getRtlAdapter;
        core_defaults._set("global", {
          tooltips: {
            enabled: true,
            custom: null,
            mode: "nearest",
            position: "average",
            intersect: true,
            backgroundColor: "rgba(0,0,0,0.8)",
            titleFontStyle: "bold",
            titleSpacing: 2,
            titleMarginBottom: 6,
            titleFontColor: "#fff",
            titleAlign: "left",
            bodySpacing: 2,
            bodyFontColor: "#fff",
            bodyAlign: "left",
            footerFontStyle: "bold",
            footerSpacing: 2,
            footerMarginTop: 6,
            footerFontColor: "#fff",
            footerAlign: "left",
            yPadding: 6,
            xPadding: 6,
            caretPadding: 2,
            caretSize: 5,
            cornerRadius: 6,
            multiKeyBackground: "#fff",
            displayColors: true,
            borderColor: "rgba(0,0,0,0)",
            borderWidth: 0,
            callbacks: {
              beforeTitle: helpers$1.noop,
              title: function(tooltipItems, data) {
                var title3 = "";
                var labels = data.labels;
                var labelCount = labels ? labels.length : 0;
                if (tooltipItems.length > 0) {
                  var item2 = tooltipItems[0];
                  if (item2.label) {
                    title3 = item2.label;
                  } else if (item2.xLabel) {
                    title3 = item2.xLabel;
                  } else if (labelCount > 0 && item2.index < labelCount) {
                    title3 = labels[item2.index];
                  }
                }
                return title3;
              },
              afterTitle: helpers$1.noop,
              beforeBody: helpers$1.noop,
              beforeLabel: helpers$1.noop,
              label: function(tooltipItem, data) {
                var label = data.datasets[tooltipItem.datasetIndex].label || "";
                if (label) {
                  label += ": ";
                }
                if (!helpers$1.isNullOrUndef(tooltipItem.value)) {
                  label += tooltipItem.value;
                } else {
                  label += tooltipItem.yLabel;
                }
                return label;
              },
              labelColor: function(tooltipItem, chart) {
                var meta = chart.getDatasetMeta(tooltipItem.datasetIndex);
                var activeElement = meta.data[tooltipItem.index];
                var view = activeElement._view;
                return {
                  borderColor: view.borderColor,
                  backgroundColor: view.backgroundColor
                };
              },
              labelTextColor: function() {
                return this._options.bodyFontColor;
              },
              afterLabel: helpers$1.noop,
              afterBody: helpers$1.noop,
              beforeFooter: helpers$1.noop,
              footer: helpers$1.noop,
              afterFooter: helpers$1.noop
            }
          }
        });
        var positioners = {
          average: function(elements2) {
            if (!elements2.length) {
              return false;
            }
            var i, len;
            var x = 0;
            var y = 0;
            var count = 0;
            for (i = 0, len = elements2.length; i < len; ++i) {
              var el = elements2[i];
              if (el && el.hasValue()) {
                var pos = el.tooltipPosition();
                x += pos.x;
                y += pos.y;
                ++count;
              }
            }
            return {
              x: x / count,
              y: y / count
            };
          },
          nearest: function(elements2, eventPosition) {
            var x = eventPosition.x;
            var y = eventPosition.y;
            var minDistance = Number.POSITIVE_INFINITY;
            var i, len, nearestElement;
            for (i = 0, len = elements2.length; i < len; ++i) {
              var el = elements2[i];
              if (el && el.hasValue()) {
                var center = el.getCenterPoint();
                var d = helpers$1.distanceBetweenPoints(eventPosition, center);
                if (d < minDistance) {
                  minDistance = d;
                  nearestElement = el;
                }
              }
            }
            if (nearestElement) {
              var tp = nearestElement.tooltipPosition();
              x = tp.x;
              y = tp.y;
            }
            return {
              x,
              y
            };
          }
        };
        function pushOrConcat(base, toPush) {
          if (toPush) {
            if (helpers$1.isArray(toPush)) {
              Array.prototype.push.apply(base, toPush);
            } else {
              base.push(toPush);
            }
          }
          return base;
        }
        function splitNewlines(str) {
          if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
            return str.split("\n");
          }
          return str;
        }
        function createTooltipItem(element2) {
          var xScale = element2._xScale;
          var yScale = element2._yScale || element2._scale;
          var index = element2._index;
          var datasetIndex = element2._datasetIndex;
          var controller = element2._chart.getDatasetMeta(datasetIndex).controller;
          var indexScale = controller._getIndexScale();
          var valueScale = controller._getValueScale();
          return {
            xLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : "",
            yLabel: yScale ? yScale.getLabelForIndex(index, datasetIndex) : "",
            label: indexScale ? "" + indexScale.getLabelForIndex(index, datasetIndex) : "",
            value: valueScale ? "" + valueScale.getLabelForIndex(index, datasetIndex) : "",
            index,
            datasetIndex,
            x: element2._model.x,
            y: element2._model.y
          };
        }
        function getBaseModel(tooltipOpts) {
          var globalDefaults = core_defaults.global;
          return {
            xPadding: tooltipOpts.xPadding,
            yPadding: tooltipOpts.yPadding,
            xAlign: tooltipOpts.xAlign,
            yAlign: tooltipOpts.yAlign,
            rtl: tooltipOpts.rtl,
            textDirection: tooltipOpts.textDirection,
            bodyFontColor: tooltipOpts.bodyFontColor,
            _bodyFontFamily: valueOrDefault$8(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),
            _bodyFontStyle: valueOrDefault$8(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),
            _bodyAlign: tooltipOpts.bodyAlign,
            bodyFontSize: valueOrDefault$8(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),
            bodySpacing: tooltipOpts.bodySpacing,
            titleFontColor: tooltipOpts.titleFontColor,
            _titleFontFamily: valueOrDefault$8(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),
            _titleFontStyle: valueOrDefault$8(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),
            titleFontSize: valueOrDefault$8(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),
            _titleAlign: tooltipOpts.titleAlign,
            titleSpacing: tooltipOpts.titleSpacing,
            titleMarginBottom: tooltipOpts.titleMarginBottom,
            footerFontColor: tooltipOpts.footerFontColor,
            _footerFontFamily: valueOrDefault$8(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),
            _footerFontStyle: valueOrDefault$8(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),
            footerFontSize: valueOrDefault$8(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),
            _footerAlign: tooltipOpts.footerAlign,
            footerSpacing: tooltipOpts.footerSpacing,
            footerMarginTop: tooltipOpts.footerMarginTop,
            caretSize: tooltipOpts.caretSize,
            cornerRadius: tooltipOpts.cornerRadius,
            backgroundColor: tooltipOpts.backgroundColor,
            opacity: 0,
            legendColorBackground: tooltipOpts.multiKeyBackground,
            displayColors: tooltipOpts.displayColors,
            borderColor: tooltipOpts.borderColor,
            borderWidth: tooltipOpts.borderWidth
          };
        }
        function getTooltipSize(tooltip, model) {
          var ctx = tooltip._chart.ctx;
          var height = model.yPadding * 2;
          var width = 0;
          var body = model.body;
          var combinedBodyLength = body.reduce(function(count, bodyItem) {
            return count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;
          }, 0);
          combinedBodyLength += model.beforeBody.length + model.afterBody.length;
          var titleLineCount = model.title.length;
          var footerLineCount = model.footer.length;
          var titleFontSize = model.titleFontSize;
          var bodyFontSize = model.bodyFontSize;
          var footerFontSize = model.footerFontSize;
          height += titleLineCount * titleFontSize;
          height += titleLineCount ? (titleLineCount - 1) * model.titleSpacing : 0;
          height += titleLineCount ? model.titleMarginBottom : 0;
          height += combinedBodyLength * bodyFontSize;
          height += combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing : 0;
          height += footerLineCount ? model.footerMarginTop : 0;
          height += footerLineCount * footerFontSize;
          height += footerLineCount ? (footerLineCount - 1) * model.footerSpacing : 0;
          var widthPadding = 0;
          var maxLineWidth = function(line) {
            width = Math.max(width, ctx.measureText(line).width + widthPadding);
          };
          ctx.font = helpers$1.fontString(titleFontSize, model._titleFontStyle, model._titleFontFamily);
          helpers$1.each(model.title, maxLineWidth);
          ctx.font = helpers$1.fontString(bodyFontSize, model._bodyFontStyle, model._bodyFontFamily);
          helpers$1.each(model.beforeBody.concat(model.afterBody), maxLineWidth);
          widthPadding = model.displayColors ? bodyFontSize + 2 : 0;
          helpers$1.each(body, function(bodyItem) {
            helpers$1.each(bodyItem.before, maxLineWidth);
            helpers$1.each(bodyItem.lines, maxLineWidth);
            helpers$1.each(bodyItem.after, maxLineWidth);
          });
          widthPadding = 0;
          ctx.font = helpers$1.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);
          helpers$1.each(model.footer, maxLineWidth);
          width += 2 * model.xPadding;
          return {
            width,
            height
          };
        }
        function determineAlignment(tooltip, size) {
          var model = tooltip._model;
          var chart = tooltip._chart;
          var chartArea = tooltip._chart.chartArea;
          var xAlign = "center";
          var yAlign = "center";
          if (model.y < size.height) {
            yAlign = "top";
          } else if (model.y > chart.height - size.height) {
            yAlign = "bottom";
          }
          var lf, rf;
          var olf, orf;
          var yf;
          var midX = (chartArea.left + chartArea.right) / 2;
          var midY = (chartArea.top + chartArea.bottom) / 2;
          if (yAlign === "center") {
            lf = function(x) {
              return x <= midX;
            };
            rf = function(x) {
              return x > midX;
            };
          } else {
            lf = function(x) {
              return x <= size.width / 2;
            };
            rf = function(x) {
              return x >= chart.width - size.width / 2;
            };
          }
          olf = function(x) {
            return x + size.width + model.caretSize + model.caretPadding > chart.width;
          };
          orf = function(x) {
            return x - size.width - model.caretSize - model.caretPadding < 0;
          };
          yf = function(y) {
            return y <= midY ? "top" : "bottom";
          };
          if (lf(model.x)) {
            xAlign = "left";
            if (olf(model.x)) {
              xAlign = "center";
              yAlign = yf(model.y);
            }
          } else if (rf(model.x)) {
            xAlign = "right";
            if (orf(model.x)) {
              xAlign = "center";
              yAlign = yf(model.y);
            }
          }
          var opts = tooltip._options;
          return {
            xAlign: opts.xAlign ? opts.xAlign : xAlign,
            yAlign: opts.yAlign ? opts.yAlign : yAlign
          };
        }
        function getBackgroundPoint(vm, size, alignment, chart) {
          var x = vm.x;
          var y = vm.y;
          var caretSize = vm.caretSize;
          var caretPadding = vm.caretPadding;
          var cornerRadius = vm.cornerRadius;
          var xAlign = alignment.xAlign;
          var yAlign = alignment.yAlign;
          var paddingAndSize = caretSize + caretPadding;
          var radiusAndPadding = cornerRadius + caretPadding;
          if (xAlign === "right") {
            x -= size.width;
          } else if (xAlign === "center") {
            x -= size.width / 2;
            if (x + size.width > chart.width) {
              x = chart.width - size.width;
            }
            if (x < 0) {
              x = 0;
            }
          }
          if (yAlign === "top") {
            y += paddingAndSize;
          } else if (yAlign === "bottom") {
            y -= size.height + paddingAndSize;
          } else {
            y -= size.height / 2;
          }
          if (yAlign === "center") {
            if (xAlign === "left") {
              x += paddingAndSize;
            } else if (xAlign === "right") {
              x -= paddingAndSize;
            }
          } else if (xAlign === "left") {
            x -= radiusAndPadding;
          } else if (xAlign === "right") {
            x += radiusAndPadding;
          }
          return {
            x,
            y
          };
        }
        function getAlignedX(vm, align) {
          return align === "center" ? vm.x + vm.width / 2 : align === "right" ? vm.x + vm.width - vm.xPadding : vm.x + vm.xPadding;
        }
        function getBeforeAfterBodyLines(callback) {
          return pushOrConcat([], splitNewlines(callback));
        }
        var exports$4 = core_element.extend({
          initialize: function() {
            this._model = getBaseModel(this._options);
            this._lastActive = [];
          },
          getTitle: function() {
            var me = this;
            var opts = me._options;
            var callbacks = opts.callbacks;
            var beforeTitle = callbacks.beforeTitle.apply(me, arguments);
            var title3 = callbacks.title.apply(me, arguments);
            var afterTitle = callbacks.afterTitle.apply(me, arguments);
            var lines = [];
            lines = pushOrConcat(lines, splitNewlines(beforeTitle));
            lines = pushOrConcat(lines, splitNewlines(title3));
            lines = pushOrConcat(lines, splitNewlines(afterTitle));
            return lines;
          },
          getBeforeBody: function() {
            return getBeforeAfterBodyLines(this._options.callbacks.beforeBody.apply(this, arguments));
          },
          getBody: function(tooltipItems, data) {
            var me = this;
            var callbacks = me._options.callbacks;
            var bodyItems = [];
            helpers$1.each(tooltipItems, function(tooltipItem) {
              var bodyItem = {
                before: [],
                lines: [],
                after: []
              };
              pushOrConcat(bodyItem.before, splitNewlines(callbacks.beforeLabel.call(me, tooltipItem, data)));
              pushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));
              pushOrConcat(bodyItem.after, splitNewlines(callbacks.afterLabel.call(me, tooltipItem, data)));
              bodyItems.push(bodyItem);
            });
            return bodyItems;
          },
          getAfterBody: function() {
            return getBeforeAfterBodyLines(this._options.callbacks.afterBody.apply(this, arguments));
          },
          getFooter: function() {
            var me = this;
            var callbacks = me._options.callbacks;
            var beforeFooter = callbacks.beforeFooter.apply(me, arguments);
            var footer = callbacks.footer.apply(me, arguments);
            var afterFooter = callbacks.afterFooter.apply(me, arguments);
            var lines = [];
            lines = pushOrConcat(lines, splitNewlines(beforeFooter));
            lines = pushOrConcat(lines, splitNewlines(footer));
            lines = pushOrConcat(lines, splitNewlines(afterFooter));
            return lines;
          },
          update: function(changed) {
            var me = this;
            var opts = me._options;
            var existingModel = me._model;
            var model = me._model = getBaseModel(opts);
            var active = me._active;
            var data = me._data;
            var alignment = {
              xAlign: existingModel.xAlign,
              yAlign: existingModel.yAlign
            };
            var backgroundPoint = {
              x: existingModel.x,
              y: existingModel.y
            };
            var tooltipSize = {
              width: existingModel.width,
              height: existingModel.height
            };
            var tooltipPosition = {
              x: existingModel.caretX,
              y: existingModel.caretY
            };
            var i, len;
            if (active.length) {
              model.opacity = 1;
              var labelColors = [];
              var labelTextColors = [];
              tooltipPosition = positioners[opts.position].call(me, active, me._eventPosition);
              var tooltipItems = [];
              for (i = 0, len = active.length; i < len; ++i) {
                tooltipItems.push(createTooltipItem(active[i]));
              }
              if (opts.filter) {
                tooltipItems = tooltipItems.filter(function(a) {
                  return opts.filter(a, data);
                });
              }
              if (opts.itemSort) {
                tooltipItems = tooltipItems.sort(function(a, b) {
                  return opts.itemSort(a, b, data);
                });
              }
              helpers$1.each(tooltipItems, function(tooltipItem) {
                labelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, me._chart));
                labelTextColors.push(opts.callbacks.labelTextColor.call(me, tooltipItem, me._chart));
              });
              model.title = me.getTitle(tooltipItems, data);
              model.beforeBody = me.getBeforeBody(tooltipItems, data);
              model.body = me.getBody(tooltipItems, data);
              model.afterBody = me.getAfterBody(tooltipItems, data);
              model.footer = me.getFooter(tooltipItems, data);
              model.x = tooltipPosition.x;
              model.y = tooltipPosition.y;
              model.caretPadding = opts.caretPadding;
              model.labelColors = labelColors;
              model.labelTextColors = labelTextColors;
              model.dataPoints = tooltipItems;
              tooltipSize = getTooltipSize(this, model);
              alignment = determineAlignment(this, tooltipSize);
              backgroundPoint = getBackgroundPoint(model, tooltipSize, alignment, me._chart);
            } else {
              model.opacity = 0;
            }
            model.xAlign = alignment.xAlign;
            model.yAlign = alignment.yAlign;
            model.x = backgroundPoint.x;
            model.y = backgroundPoint.y;
            model.width = tooltipSize.width;
            model.height = tooltipSize.height;
            model.caretX = tooltipPosition.x;
            model.caretY = tooltipPosition.y;
            me._model = model;
            if (changed && opts.custom) {
              opts.custom.call(me, model);
            }
            return me;
          },
          drawCaret: function(tooltipPoint, size) {
            var ctx = this._chart.ctx;
            var vm = this._view;
            var caretPosition = this.getCaretPosition(tooltipPoint, size, vm);
            ctx.lineTo(caretPosition.x1, caretPosition.y1);
            ctx.lineTo(caretPosition.x2, caretPosition.y2);
            ctx.lineTo(caretPosition.x3, caretPosition.y3);
          },
          getCaretPosition: function(tooltipPoint, size, vm) {
            var x1, x2, x3, y1, y2, y3;
            var caretSize = vm.caretSize;
            var cornerRadius = vm.cornerRadius;
            var xAlign = vm.xAlign;
            var yAlign = vm.yAlign;
            var ptX = tooltipPoint.x;
            var ptY = tooltipPoint.y;
            var width = size.width;
            var height = size.height;
            if (yAlign === "center") {
              y2 = ptY + height / 2;
              if (xAlign === "left") {
                x1 = ptX;
                x2 = x1 - caretSize;
                x3 = x1;
                y1 = y2 + caretSize;
                y3 = y2 - caretSize;
              } else {
                x1 = ptX + width;
                x2 = x1 + caretSize;
                x3 = x1;
                y1 = y2 - caretSize;
                y3 = y2 + caretSize;
              }
            } else {
              if (xAlign === "left") {
                x2 = ptX + cornerRadius + caretSize;
                x1 = x2 - caretSize;
                x3 = x2 + caretSize;
              } else if (xAlign === "right") {
                x2 = ptX + width - cornerRadius - caretSize;
                x1 = x2 - caretSize;
                x3 = x2 + caretSize;
              } else {
                x2 = vm.caretX;
                x1 = x2 - caretSize;
                x3 = x2 + caretSize;
              }
              if (yAlign === "top") {
                y1 = ptY;
                y2 = y1 - caretSize;
                y3 = y1;
              } else {
                y1 = ptY + height;
                y2 = y1 + caretSize;
                y3 = y1;
                var tmp = x3;
                x3 = x1;
                x1 = tmp;
              }
            }
            return { x1, x2, x3, y1, y2, y3 };
          },
          drawTitle: function(pt, vm, ctx) {
            var title3 = vm.title;
            var length = title3.length;
            var titleFontSize, titleSpacing, i;
            if (length) {
              var rtlHelper = getRtlHelper(vm.rtl, vm.x, vm.width);
              pt.x = getAlignedX(vm, vm._titleAlign);
              ctx.textAlign = rtlHelper.textAlign(vm._titleAlign);
              ctx.textBaseline = "middle";
              titleFontSize = vm.titleFontSize;
              titleSpacing = vm.titleSpacing;
              ctx.fillStyle = vm.titleFontColor;
              ctx.font = helpers$1.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);
              for (i = 0; i < length; ++i) {
                ctx.fillText(title3[i], rtlHelper.x(pt.x), pt.y + titleFontSize / 2);
                pt.y += titleFontSize + titleSpacing;
                if (i + 1 === length) {
                  pt.y += vm.titleMarginBottom - titleSpacing;
                }
              }
            }
          },
          drawBody: function(pt, vm, ctx) {
            var bodyFontSize = vm.bodyFontSize;
            var bodySpacing = vm.bodySpacing;
            var bodyAlign = vm._bodyAlign;
            var body = vm.body;
            var drawColorBoxes = vm.displayColors;
            var xLinePadding = 0;
            var colorX = drawColorBoxes ? getAlignedX(vm, "left") : 0;
            var rtlHelper = getRtlHelper(vm.rtl, vm.x, vm.width);
            var fillLineOfText = function(line) {
              ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyFontSize / 2);
              pt.y += bodyFontSize + bodySpacing;
            };
            var bodyItem, textColor, labelColors, lines, i, j, ilen, jlen;
            var bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
            ctx.textAlign = bodyAlign;
            ctx.textBaseline = "middle";
            ctx.font = helpers$1.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);
            pt.x = getAlignedX(vm, bodyAlignForCalculation);
            ctx.fillStyle = vm.bodyFontColor;
            helpers$1.each(vm.beforeBody, fillLineOfText);
            xLinePadding = drawColorBoxes && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? bodyFontSize / 2 + 1 : bodyFontSize + 2 : 0;
            for (i = 0, ilen = body.length; i < ilen; ++i) {
              bodyItem = body[i];
              textColor = vm.labelTextColors[i];
              labelColors = vm.labelColors[i];
              ctx.fillStyle = textColor;
              helpers$1.each(bodyItem.before, fillLineOfText);
              lines = bodyItem.lines;
              for (j = 0, jlen = lines.length; j < jlen; ++j) {
                if (drawColorBoxes) {
                  var rtlColorX = rtlHelper.x(colorX);
                  ctx.fillStyle = vm.legendColorBackground;
                  ctx.fillRect(rtlHelper.leftForLtr(rtlColorX, bodyFontSize), pt.y, bodyFontSize, bodyFontSize);
                  ctx.lineWidth = 1;
                  ctx.strokeStyle = labelColors.borderColor;
                  ctx.strokeRect(rtlHelper.leftForLtr(rtlColorX, bodyFontSize), pt.y, bodyFontSize, bodyFontSize);
                  ctx.fillStyle = labelColors.backgroundColor;
                  ctx.fillRect(rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), bodyFontSize - 2), pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);
                  ctx.fillStyle = textColor;
                }
                fillLineOfText(lines[j]);
              }
              helpers$1.each(bodyItem.after, fillLineOfText);
            }
            xLinePadding = 0;
            helpers$1.each(vm.afterBody, fillLineOfText);
            pt.y -= bodySpacing;
          },
          drawFooter: function(pt, vm, ctx) {
            var footer = vm.footer;
            var length = footer.length;
            var footerFontSize, i;
            if (length) {
              var rtlHelper = getRtlHelper(vm.rtl, vm.x, vm.width);
              pt.x = getAlignedX(vm, vm._footerAlign);
              pt.y += vm.footerMarginTop;
              ctx.textAlign = rtlHelper.textAlign(vm._footerAlign);
              ctx.textBaseline = "middle";
              footerFontSize = vm.footerFontSize;
              ctx.fillStyle = vm.footerFontColor;
              ctx.font = helpers$1.fontString(footerFontSize, vm._footerFontStyle, vm._footerFontFamily);
              for (i = 0; i < length; ++i) {
                ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFontSize / 2);
                pt.y += footerFontSize + vm.footerSpacing;
              }
            }
          },
          drawBackground: function(pt, vm, ctx, tooltipSize) {
            ctx.fillStyle = vm.backgroundColor;
            ctx.strokeStyle = vm.borderColor;
            ctx.lineWidth = vm.borderWidth;
            var xAlign = vm.xAlign;
            var yAlign = vm.yAlign;
            var x = pt.x;
            var y = pt.y;
            var width = tooltipSize.width;
            var height = tooltipSize.height;
            var radius = vm.cornerRadius;
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            if (yAlign === "top") {
              this.drawCaret(pt, tooltipSize);
            }
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            if (yAlign === "center" && xAlign === "right") {
              this.drawCaret(pt, tooltipSize);
            }
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            if (yAlign === "bottom") {
              this.drawCaret(pt, tooltipSize);
            }
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            if (yAlign === "center" && xAlign === "left") {
              this.drawCaret(pt, tooltipSize);
            }
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            ctx.fill();
            if (vm.borderWidth > 0) {
              ctx.stroke();
            }
          },
          draw: function() {
            var ctx = this._chart.ctx;
            var vm = this._view;
            if (vm.opacity === 0) {
              return;
            }
            var tooltipSize = {
              width: vm.width,
              height: vm.height
            };
            var pt = {
              x: vm.x,
              y: vm.y
            };
            var opacity = Math.abs(vm.opacity < 1e-3) ? 0 : vm.opacity;
            var hasTooltipContent = vm.title.length || vm.beforeBody.length || vm.body.length || vm.afterBody.length || vm.footer.length;
            if (this._options.enabled && hasTooltipContent) {
              ctx.save();
              ctx.globalAlpha = opacity;
              this.drawBackground(pt, vm, ctx, tooltipSize);
              pt.y += vm.yPadding;
              helpers$1.rtl.overrideTextDirection(ctx, vm.textDirection);
              this.drawTitle(pt, vm, ctx);
              this.drawBody(pt, vm, ctx);
              this.drawFooter(pt, vm, ctx);
              helpers$1.rtl.restoreTextDirection(ctx, vm.textDirection);
              ctx.restore();
            }
          },
          handleEvent: function(e) {
            var me = this;
            var options2 = me._options;
            var changed = false;
            me._lastActive = me._lastActive || [];
            if (e.type === "mouseout") {
              me._active = [];
            } else {
              me._active = me._chart.getElementsAtEventForMode(e, options2.mode, options2);
              if (options2.reverse) {
                me._active.reverse();
              }
            }
            changed = !helpers$1.arrayEquals(me._active, me._lastActive);
            if (changed) {
              me._lastActive = me._active;
              if (options2.enabled || options2.custom) {
                me._eventPosition = {
                  x: e.x,
                  y: e.y
                };
                me.update(true);
                me.pivot();
              }
            }
            return changed;
          }
        });
        var positioners_1 = positioners;
        var core_tooltip = exports$4;
        core_tooltip.positioners = positioners_1;
        var valueOrDefault$9 = helpers$1.valueOrDefault;
        core_defaults._set("global", {
          elements: {},
          events: [
            "mousemove",
            "mouseout",
            "click",
            "touchstart",
            "touchmove"
          ],
          hover: {
            onHover: null,
            mode: "nearest",
            intersect: true,
            animationDuration: 400
          },
          onClick: null,
          maintainAspectRatio: true,
          responsive: true,
          responsiveAnimationDuration: 0
        });
        function mergeScaleConfig() {
          return helpers$1.merge(Object.create(null), [].slice.call(arguments), {
            merger: function(key, target, source, options2) {
              if (key === "xAxes" || key === "yAxes") {
                var slen = source[key].length;
                var i, type, scale2;
                if (!target[key]) {
                  target[key] = [];
                }
                for (i = 0; i < slen; ++i) {
                  scale2 = source[key][i];
                  type = valueOrDefault$9(scale2.type, key === "xAxes" ? "category" : "linear");
                  if (i >= target[key].length) {
                    target[key].push({});
                  }
                  if (!target[key][i].type || scale2.type && scale2.type !== target[key][i].type) {
                    helpers$1.merge(target[key][i], [core_scaleService.getScaleDefaults(type), scale2]);
                  } else {
                    helpers$1.merge(target[key][i], scale2);
                  }
                }
              } else {
                helpers$1._merger(key, target, source, options2);
              }
            }
          });
        }
        function mergeConfig() {
          return helpers$1.merge(Object.create(null), [].slice.call(arguments), {
            merger: function(key, target, source, options2) {
              var tval = target[key] || Object.create(null);
              var sval = source[key];
              if (key === "scales") {
                target[key] = mergeScaleConfig(tval, sval);
              } else if (key === "scale") {
                target[key] = helpers$1.merge(tval, [core_scaleService.getScaleDefaults(sval.type), sval]);
              } else {
                helpers$1._merger(key, target, source, options2);
              }
            }
          });
        }
        function initConfig(config) {
          config = config || Object.create(null);
          var data = config.data = config.data || {};
          data.datasets = data.datasets || [];
          data.labels = data.labels || [];
          config.options = mergeConfig(core_defaults.global, core_defaults[config.type], config.options || {});
          return config;
        }
        function updateConfig(chart) {
          var newOptions = chart.options;
          helpers$1.each(chart.scales, function(scale2) {
            core_layouts.removeBox(chart, scale2);
          });
          newOptions = mergeConfig(core_defaults.global, core_defaults[chart.config.type], newOptions);
          chart.options = chart.config.options = newOptions;
          chart.ensureScalesHaveIDs();
          chart.buildOrUpdateScales();
          chart.tooltip._options = newOptions.tooltips;
          chart.tooltip.initialize();
        }
        function nextAvailableScaleId(axesOpts, prefix, index) {
          var id;
          var hasId = function(obj) {
            return obj.id === id;
          };
          do {
            id = prefix + index++;
          } while (helpers$1.findIndex(axesOpts, hasId) >= 0);
          return id;
        }
        function positionIsHorizontal(position) {
          return position === "top" || position === "bottom";
        }
        function compare2Level(l1, l2) {
          return function(a, b) {
            return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
          };
        }
        var Chart2 = function(item2, config) {
          this.construct(item2, config);
          return this;
        };
        helpers$1.extend(Chart2.prototype, {
          construct: function(item2, config) {
            var me = this;
            config = initConfig(config);
            var context = platform.acquireContext(item2, config);
            var canvas2 = context && context.canvas;
            var height = canvas2 && canvas2.height;
            var width = canvas2 && canvas2.width;
            me.id = helpers$1.uid();
            me.ctx = context;
            me.canvas = canvas2;
            me.config = config;
            me.width = width;
            me.height = height;
            me.aspectRatio = height ? width / height : null;
            me.options = config.options;
            me._bufferedRender = false;
            me._layers = [];
            me.chart = me;
            me.controller = me;
            Chart2.instances[me.id] = me;
            Object.defineProperty(me, "data", {
              get: function() {
                return me.config.data;
              },
              set: function(value) {
                me.config.data = value;
              }
            });
            if (!context || !canvas2) {
              console.error("Failed to create chart: can't acquire context from the given item");
              return;
            }
            me.initialize();
            me.update();
          },
          initialize: function() {
            var me = this;
            core_plugins.notify(me, "beforeInit");
            helpers$1.retinaScale(me, me.options.devicePixelRatio);
            me.bindEvents();
            if (me.options.responsive) {
              me.resize(true);
            }
            me.initToolTip();
            core_plugins.notify(me, "afterInit");
            return me;
          },
          clear: function() {
            helpers$1.canvas.clear(this);
            return this;
          },
          stop: function() {
            core_animations.cancelAnimation(this);
            return this;
          },
          resize: function(silent) {
            var me = this;
            var options2 = me.options;
            var canvas2 = me.canvas;
            var aspectRatio = options2.maintainAspectRatio && me.aspectRatio || null;
            var newWidth = Math.max(0, Math.floor(helpers$1.getMaximumWidth(canvas2)));
            var newHeight = Math.max(0, Math.floor(aspectRatio ? newWidth / aspectRatio : helpers$1.getMaximumHeight(canvas2)));
            if (me.width === newWidth && me.height === newHeight) {
              return;
            }
            canvas2.width = me.width = newWidth;
            canvas2.height = me.height = newHeight;
            canvas2.style.width = newWidth + "px";
            canvas2.style.height = newHeight + "px";
            helpers$1.retinaScale(me, options2.devicePixelRatio);
            if (!silent) {
              var newSize = { width: newWidth, height: newHeight };
              core_plugins.notify(me, "resize", [newSize]);
              if (options2.onResize) {
                options2.onResize(me, newSize);
              }
              me.stop();
              me.update({
                duration: options2.responsiveAnimationDuration
              });
            }
          },
          ensureScalesHaveIDs: function() {
            var options2 = this.options;
            var scalesOptions = options2.scales || {};
            var scaleOptions = options2.scale;
            helpers$1.each(scalesOptions.xAxes, function(xAxisOptions, index) {
              if (!xAxisOptions.id) {
                xAxisOptions.id = nextAvailableScaleId(scalesOptions.xAxes, "x-axis-", index);
              }
            });
            helpers$1.each(scalesOptions.yAxes, function(yAxisOptions, index) {
              if (!yAxisOptions.id) {
                yAxisOptions.id = nextAvailableScaleId(scalesOptions.yAxes, "y-axis-", index);
              }
            });
            if (scaleOptions) {
              scaleOptions.id = scaleOptions.id || "scale";
            }
          },
          buildOrUpdateScales: function() {
            var me = this;
            var options2 = me.options;
            var scales2 = me.scales || {};
            var items = [];
            var updated = Object.keys(scales2).reduce(function(obj, id) {
              obj[id] = false;
              return obj;
            }, {});
            if (options2.scales) {
              items = items.concat((options2.scales.xAxes || []).map(function(xAxisOptions) {
                return { options: xAxisOptions, dtype: "category", dposition: "bottom" };
              }), (options2.scales.yAxes || []).map(function(yAxisOptions) {
                return { options: yAxisOptions, dtype: "linear", dposition: "left" };
              }));
            }
            if (options2.scale) {
              items.push({
                options: options2.scale,
                dtype: "radialLinear",
                isDefault: true,
                dposition: "chartArea"
              });
            }
            helpers$1.each(items, function(item2) {
              var scaleOptions = item2.options;
              var id = scaleOptions.id;
              var scaleType = valueOrDefault$9(scaleOptions.type, item2.dtype);
              if (positionIsHorizontal(scaleOptions.position) !== positionIsHorizontal(item2.dposition)) {
                scaleOptions.position = item2.dposition;
              }
              updated[id] = true;
              var scale2 = null;
              if (id in scales2 && scales2[id].type === scaleType) {
                scale2 = scales2[id];
                scale2.options = scaleOptions;
                scale2.ctx = me.ctx;
                scale2.chart = me;
              } else {
                var scaleClass = core_scaleService.getScaleConstructor(scaleType);
                if (!scaleClass) {
                  return;
                }
                scale2 = new scaleClass({
                  id,
                  type: scaleType,
                  options: scaleOptions,
                  ctx: me.ctx,
                  chart: me
                });
                scales2[scale2.id] = scale2;
              }
              scale2.mergeTicksOptions();
              if (item2.isDefault) {
                me.scale = scale2;
              }
            });
            helpers$1.each(updated, function(hasUpdated, id) {
              if (!hasUpdated) {
                delete scales2[id];
              }
            });
            me.scales = scales2;
            core_scaleService.addScalesToLayout(this);
          },
          buildOrUpdateControllers: function() {
            var me = this;
            var newControllers = [];
            var datasets = me.data.datasets;
            var i, ilen;
            for (i = 0, ilen = datasets.length; i < ilen; i++) {
              var dataset = datasets[i];
              var meta = me.getDatasetMeta(i);
              var type = dataset.type || me.config.type;
              if (meta.type && meta.type !== type) {
                me.destroyDatasetMeta(i);
                meta = me.getDatasetMeta(i);
              }
              meta.type = type;
              meta.order = dataset.order || 0;
              meta.index = i;
              if (meta.controller) {
                meta.controller.updateIndex(i);
                meta.controller.linkScales();
              } else {
                var ControllerClass = controllers[meta.type];
                if (ControllerClass === void 0) {
                  throw new Error('"' + meta.type + '" is not a chart type.');
                }
                meta.controller = new ControllerClass(me, i);
                newControllers.push(meta.controller);
              }
            }
            return newControllers;
          },
          resetElements: function() {
            var me = this;
            helpers$1.each(me.data.datasets, function(dataset, datasetIndex) {
              me.getDatasetMeta(datasetIndex).controller.reset();
            }, me);
          },
          reset: function() {
            this.resetElements();
            this.tooltip.initialize();
          },
          update: function(config) {
            var me = this;
            var i, ilen;
            if (!config || typeof config !== "object") {
              config = {
                duration: config,
                lazy: arguments[1]
              };
            }
            updateConfig(me);
            core_plugins._invalidate(me);
            if (core_plugins.notify(me, "beforeUpdate") === false) {
              return;
            }
            me.tooltip._data = me.data;
            var newControllers = me.buildOrUpdateControllers();
            for (i = 0, ilen = me.data.datasets.length; i < ilen; i++) {
              me.getDatasetMeta(i).controller.buildOrUpdateElements();
            }
            me.updateLayout();
            if (me.options.animation && me.options.animation.duration) {
              helpers$1.each(newControllers, function(controller) {
                controller.reset();
              });
            }
            me.updateDatasets();
            me.tooltip.initialize();
            me.lastActive = [];
            core_plugins.notify(me, "afterUpdate");
            me._layers.sort(compare2Level("z", "_idx"));
            if (me._bufferedRender) {
              me._bufferedRequest = {
                duration: config.duration,
                easing: config.easing,
                lazy: config.lazy
              };
            } else {
              me.render(config);
            }
          },
          updateLayout: function() {
            var me = this;
            if (core_plugins.notify(me, "beforeLayout") === false) {
              return;
            }
            core_layouts.update(this, this.width, this.height);
            me._layers = [];
            helpers$1.each(me.boxes, function(box) {
              if (box._configure) {
                box._configure();
              }
              me._layers.push.apply(me._layers, box._layers());
            }, me);
            me._layers.forEach(function(item2, index) {
              item2._idx = index;
            });
            core_plugins.notify(me, "afterScaleUpdate");
            core_plugins.notify(me, "afterLayout");
          },
          updateDatasets: function() {
            var me = this;
            if (core_plugins.notify(me, "beforeDatasetsUpdate") === false) {
              return;
            }
            for (var i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
              me.updateDataset(i);
            }
            core_plugins.notify(me, "afterDatasetsUpdate");
          },
          updateDataset: function(index) {
            var me = this;
            var meta = me.getDatasetMeta(index);
            var args = {
              meta,
              index
            };
            if (core_plugins.notify(me, "beforeDatasetUpdate", [args]) === false) {
              return;
            }
            meta.controller._update();
            core_plugins.notify(me, "afterDatasetUpdate", [args]);
          },
          render: function(config) {
            var me = this;
            if (!config || typeof config !== "object") {
              config = {
                duration: config,
                lazy: arguments[1]
              };
            }
            var animationOptions = me.options.animation;
            var duration = valueOrDefault$9(config.duration, animationOptions && animationOptions.duration);
            var lazy = config.lazy;
            if (core_plugins.notify(me, "beforeRender") === false) {
              return;
            }
            var onComplete = function(animation2) {
              core_plugins.notify(me, "afterRender");
              helpers$1.callback(animationOptions && animationOptions.onComplete, [animation2], me);
            };
            if (animationOptions && duration) {
              var animation = new core_animation({
                numSteps: duration / 16.66,
                easing: config.easing || animationOptions.easing,
                render: function(chart, animationObject) {
                  var easingFunction = helpers$1.easing.effects[animationObject.easing];
                  var currentStep = animationObject.currentStep;
                  var stepDecimal = currentStep / animationObject.numSteps;
                  chart.draw(easingFunction(stepDecimal), stepDecimal, currentStep);
                },
                onAnimationProgress: animationOptions.onProgress,
                onAnimationComplete: onComplete
              });
              core_animations.addAnimation(me, animation, duration, lazy);
            } else {
              me.draw();
              onComplete(new core_animation({ numSteps: 0, chart: me }));
            }
            return me;
          },
          draw: function(easingValue) {
            var me = this;
            var i, layers;
            me.clear();
            if (helpers$1.isNullOrUndef(easingValue)) {
              easingValue = 1;
            }
            me.transition(easingValue);
            if (me.width <= 0 || me.height <= 0) {
              return;
            }
            if (core_plugins.notify(me, "beforeDraw", [easingValue]) === false) {
              return;
            }
            layers = me._layers;
            for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {
              layers[i].draw(me.chartArea);
            }
            me.drawDatasets(easingValue);
            for (; i < layers.length; ++i) {
              layers[i].draw(me.chartArea);
            }
            me._drawTooltip(easingValue);
            core_plugins.notify(me, "afterDraw", [easingValue]);
          },
          transition: function(easingValue) {
            var me = this;
            for (var i = 0, ilen = (me.data.datasets || []).length; i < ilen; ++i) {
              if (me.isDatasetVisible(i)) {
                me.getDatasetMeta(i).controller.transition(easingValue);
              }
            }
            me.tooltip.transition(easingValue);
          },
          _getSortedDatasetMetas: function(filterVisible) {
            var me = this;
            var datasets = me.data.datasets || [];
            var result = [];
            var i, ilen;
            for (i = 0, ilen = datasets.length; i < ilen; ++i) {
              if (!filterVisible || me.isDatasetVisible(i)) {
                result.push(me.getDatasetMeta(i));
              }
            }
            result.sort(compare2Level("order", "index"));
            return result;
          },
          _getSortedVisibleDatasetMetas: function() {
            return this._getSortedDatasetMetas(true);
          },
          drawDatasets: function(easingValue) {
            var me = this;
            var metasets, i;
            if (core_plugins.notify(me, "beforeDatasetsDraw", [easingValue]) === false) {
              return;
            }
            metasets = me._getSortedVisibleDatasetMetas();
            for (i = metasets.length - 1; i >= 0; --i) {
              me.drawDataset(metasets[i], easingValue);
            }
            core_plugins.notify(me, "afterDatasetsDraw", [easingValue]);
          },
          drawDataset: function(meta, easingValue) {
            var me = this;
            var args = {
              meta,
              index: meta.index,
              easingValue
            };
            if (core_plugins.notify(me, "beforeDatasetDraw", [args]) === false) {
              return;
            }
            meta.controller.draw(easingValue);
            core_plugins.notify(me, "afterDatasetDraw", [args]);
          },
          _drawTooltip: function(easingValue) {
            var me = this;
            var tooltip = me.tooltip;
            var args = {
              tooltip,
              easingValue
            };
            if (core_plugins.notify(me, "beforeTooltipDraw", [args]) === false) {
              return;
            }
            tooltip.draw();
            core_plugins.notify(me, "afterTooltipDraw", [args]);
          },
          getElementAtEvent: function(e) {
            return core_interaction.modes.single(this, e);
          },
          getElementsAtEvent: function(e) {
            return core_interaction.modes.label(this, e, { intersect: true });
          },
          getElementsAtXAxis: function(e) {
            return core_interaction.modes["x-axis"](this, e, { intersect: true });
          },
          getElementsAtEventForMode: function(e, mode, options2) {
            var method = core_interaction.modes[mode];
            if (typeof method === "function") {
              return method(this, e, options2);
            }
            return [];
          },
          getDatasetAtEvent: function(e) {
            return core_interaction.modes.dataset(this, e, { intersect: true });
          },
          getDatasetMeta: function(datasetIndex) {
            var me = this;
            var dataset = me.data.datasets[datasetIndex];
            if (!dataset._meta) {
              dataset._meta = {};
            }
            var meta = dataset._meta[me.id];
            if (!meta) {
              meta = dataset._meta[me.id] = {
                type: null,
                data: [],
                dataset: null,
                controller: null,
                hidden: null,
                xAxisID: null,
                yAxisID: null,
                order: dataset.order || 0,
                index: datasetIndex
              };
            }
            return meta;
          },
          getVisibleDatasetCount: function() {
            var count = 0;
            for (var i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
              if (this.isDatasetVisible(i)) {
                count++;
              }
            }
            return count;
          },
          isDatasetVisible: function(datasetIndex) {
            var meta = this.getDatasetMeta(datasetIndex);
            return typeof meta.hidden === "boolean" ? !meta.hidden : !this.data.datasets[datasetIndex].hidden;
          },
          generateLegend: function() {
            return this.options.legendCallback(this);
          },
          destroyDatasetMeta: function(datasetIndex) {
            var id = this.id;
            var dataset = this.data.datasets[datasetIndex];
            var meta = dataset._meta && dataset._meta[id];
            if (meta) {
              meta.controller.destroy();
              delete dataset._meta[id];
            }
          },
          destroy: function() {
            var me = this;
            var canvas2 = me.canvas;
            var i, ilen;
            me.stop();
            for (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
              me.destroyDatasetMeta(i);
            }
            if (canvas2) {
              me.unbindEvents();
              helpers$1.canvas.clear(me);
              platform.releaseContext(me.ctx);
              me.canvas = null;
              me.ctx = null;
            }
            core_plugins.notify(me, "destroy");
            delete Chart2.instances[me.id];
          },
          toBase64Image: function() {
            return this.canvas.toDataURL.apply(this.canvas, arguments);
          },
          initToolTip: function() {
            var me = this;
            me.tooltip = new core_tooltip({
              _chart: me,
              _chartInstance: me,
              _data: me.data,
              _options: me.options.tooltips
            }, me);
          },
          bindEvents: function() {
            var me = this;
            var listeners = me._listeners = {};
            var listener = function() {
              me.eventHandler.apply(me, arguments);
            };
            helpers$1.each(me.options.events, function(type) {
              platform.addEventListener(me, type, listener);
              listeners[type] = listener;
            });
            if (me.options.responsive) {
              listener = function() {
                me.resize();
              };
              platform.addEventListener(me, "resize", listener);
              listeners.resize = listener;
            }
          },
          unbindEvents: function() {
            var me = this;
            var listeners = me._listeners;
            if (!listeners) {
              return;
            }
            delete me._listeners;
            helpers$1.each(listeners, function(listener, type) {
              platform.removeEventListener(me, type, listener);
            });
          },
          updateHoverStyle: function(elements2, mode, enabled) {
            var prefix = enabled ? "set" : "remove";
            var element2, i, ilen;
            for (i = 0, ilen = elements2.length; i < ilen; ++i) {
              element2 = elements2[i];
              if (element2) {
                this.getDatasetMeta(element2._datasetIndex).controller[prefix + "HoverStyle"](element2);
              }
            }
            if (mode === "dataset") {
              this.getDatasetMeta(elements2[0]._datasetIndex).controller["_" + prefix + "DatasetHoverStyle"]();
            }
          },
          eventHandler: function(e) {
            var me = this;
            var tooltip = me.tooltip;
            if (core_plugins.notify(me, "beforeEvent", [e]) === false) {
              return;
            }
            me._bufferedRender = true;
            me._bufferedRequest = null;
            var changed = me.handleEvent(e);
            if (tooltip) {
              changed = tooltip._start ? tooltip.handleEvent(e) : changed | tooltip.handleEvent(e);
            }
            core_plugins.notify(me, "afterEvent", [e]);
            var bufferedRequest = me._bufferedRequest;
            if (bufferedRequest) {
              me.render(bufferedRequest);
            } else if (changed && !me.animating) {
              me.stop();
              me.render({
                duration: me.options.hover.animationDuration,
                lazy: true
              });
            }
            me._bufferedRender = false;
            me._bufferedRequest = null;
            return me;
          },
          handleEvent: function(e) {
            var me = this;
            var options2 = me.options || {};
            var hoverOptions = options2.hover;
            var changed = false;
            me.lastActive = me.lastActive || [];
            if (e.type === "mouseout") {
              me.active = [];
            } else {
              me.active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions);
            }
            helpers$1.callback(options2.onHover || options2.hover.onHover, [e.native, me.active], me);
            if (e.type === "mouseup" || e.type === "click") {
              if (options2.onClick) {
                options2.onClick.call(me, e.native, me.active);
              }
            }
            if (me.lastActive.length) {
              me.updateHoverStyle(me.lastActive, hoverOptions.mode, false);
            }
            if (me.active.length && hoverOptions.mode) {
              me.updateHoverStyle(me.active, hoverOptions.mode, true);
            }
            changed = !helpers$1.arrayEquals(me.active, me.lastActive);
            me.lastActive = me.active;
            return changed;
          }
        });
        Chart2.instances = {};
        var core_controller = Chart2;
        Chart2.Controller = Chart2;
        Chart2.types = {};
        helpers$1.configMerge = mergeConfig;
        helpers$1.scaleMerge = mergeScaleConfig;
        var core_helpers = function() {
          helpers$1.where = function(collection, filterCallback) {
            if (helpers$1.isArray(collection) && Array.prototype.filter) {
              return collection.filter(filterCallback);
            }
            var filtered = [];
            helpers$1.each(collection, function(item2) {
              if (filterCallback(item2)) {
                filtered.push(item2);
              }
            });
            return filtered;
          };
          helpers$1.findIndex = Array.prototype.findIndex ? function(array, callback, scope) {
            return array.findIndex(callback, scope);
          } : function(array, callback, scope) {
            scope = scope === void 0 ? array : scope;
            for (var i = 0, ilen = array.length; i < ilen; ++i) {
              if (callback.call(scope, array[i], i, array)) {
                return i;
              }
            }
            return -1;
          };
          helpers$1.findNextWhere = function(arrayToSearch, filterCallback, startIndex) {
            if (helpers$1.isNullOrUndef(startIndex)) {
              startIndex = -1;
            }
            for (var i = startIndex + 1; i < arrayToSearch.length; i++) {
              var currentItem = arrayToSearch[i];
              if (filterCallback(currentItem)) {
                return currentItem;
              }
            }
          };
          helpers$1.findPreviousWhere = function(arrayToSearch, filterCallback, startIndex) {
            if (helpers$1.isNullOrUndef(startIndex)) {
              startIndex = arrayToSearch.length;
            }
            for (var i = startIndex - 1; i >= 0; i--) {
              var currentItem = arrayToSearch[i];
              if (filterCallback(currentItem)) {
                return currentItem;
              }
            }
          };
          helpers$1.isNumber = function(n) {
            return !isNaN(parseFloat(n)) && isFinite(n);
          };
          helpers$1.almostEquals = function(x, y, epsilon) {
            return Math.abs(x - y) < epsilon;
          };
          helpers$1.almostWhole = function(x, epsilon) {
            var rounded = Math.round(x);
            return rounded - epsilon <= x && rounded + epsilon >= x;
          };
          helpers$1.max = function(array) {
            return array.reduce(function(max, value) {
              if (!isNaN(value)) {
                return Math.max(max, value);
              }
              return max;
            }, Number.NEGATIVE_INFINITY);
          };
          helpers$1.min = function(array) {
            return array.reduce(function(min, value) {
              if (!isNaN(value)) {
                return Math.min(min, value);
              }
              return min;
            }, Number.POSITIVE_INFINITY);
          };
          helpers$1.sign = Math.sign ? function(x) {
            return Math.sign(x);
          } : function(x) {
            x = +x;
            if (x === 0 || isNaN(x)) {
              return x;
            }
            return x > 0 ? 1 : -1;
          };
          helpers$1.toRadians = function(degrees) {
            return degrees * (Math.PI / 180);
          };
          helpers$1.toDegrees = function(radians) {
            return radians * (180 / Math.PI);
          };
          helpers$1._decimalPlaces = function(x) {
            if (!helpers$1.isFinite(x)) {
              return;
            }
            var e = 1;
            var p = 0;
            while (Math.round(x * e) / e !== x) {
              e *= 10;
              p++;
            }
            return p;
          };
          helpers$1.getAngleFromPoint = function(centrePoint, anglePoint) {
            var distanceFromXCenter = anglePoint.x - centrePoint.x;
            var distanceFromYCenter = anglePoint.y - centrePoint.y;
            var radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
            var angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
            if (angle < -0.5 * Math.PI) {
              angle += 2 * Math.PI;
            }
            return {
              angle,
              distance: radialDistanceFromCenter
            };
          };
          helpers$1.distanceBetweenPoints = function(pt1, pt2) {
            return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
          };
          helpers$1.aliasPixel = function(pixelWidth) {
            return pixelWidth % 2 === 0 ? 0 : 0.5;
          };
          helpers$1._alignPixel = function(chart, pixel, width) {
            var devicePixelRatio = chart.currentDevicePixelRatio;
            var halfWidth = width / 2;
            return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
          };
          helpers$1.splineCurve = function(firstPoint, middlePoint, afterPoint, t) {
            var previous = firstPoint.skip ? middlePoint : firstPoint;
            var current = middlePoint;
            var next = afterPoint.skip ? middlePoint : afterPoint;
            var d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));
            var d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));
            var s01 = d01 / (d01 + d12);
            var s12 = d12 / (d01 + d12);
            s01 = isNaN(s01) ? 0 : s01;
            s12 = isNaN(s12) ? 0 : s12;
            var fa = t * s01;
            var fb = t * s12;
            return {
              previous: {
                x: current.x - fa * (next.x - previous.x),
                y: current.y - fa * (next.y - previous.y)
              },
              next: {
                x: current.x + fb * (next.x - previous.x),
                y: current.y + fb * (next.y - previous.y)
              }
            };
          };
          helpers$1.EPSILON = Number.EPSILON || 1e-14;
          helpers$1.splineCurveMonotone = function(points) {
            var pointsWithTangents = (points || []).map(function(point) {
              return {
                model: point._model,
                deltaK: 0,
                mK: 0
              };
            });
            var pointsLen = pointsWithTangents.length;
            var i, pointBefore, pointCurrent, pointAfter;
            for (i = 0; i < pointsLen; ++i) {
              pointCurrent = pointsWithTangents[i];
              if (pointCurrent.model.skip) {
                continue;
              }
              pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
              pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;
              if (pointAfter && !pointAfter.model.skip) {
                var slopeDeltaX = pointAfter.model.x - pointCurrent.model.x;
                pointCurrent.deltaK = slopeDeltaX !== 0 ? (pointAfter.model.y - pointCurrent.model.y) / slopeDeltaX : 0;
              }
              if (!pointBefore || pointBefore.model.skip) {
                pointCurrent.mK = pointCurrent.deltaK;
              } else if (!pointAfter || pointAfter.model.skip) {
                pointCurrent.mK = pointBefore.deltaK;
              } else if (this.sign(pointBefore.deltaK) !== this.sign(pointCurrent.deltaK)) {
                pointCurrent.mK = 0;
              } else {
                pointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK) / 2;
              }
            }
            var alphaK, betaK, tauK, squaredMagnitude;
            for (i = 0; i < pointsLen - 1; ++i) {
              pointCurrent = pointsWithTangents[i];
              pointAfter = pointsWithTangents[i + 1];
              if (pointCurrent.model.skip || pointAfter.model.skip) {
                continue;
              }
              if (helpers$1.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {
                pointCurrent.mK = pointAfter.mK = 0;
                continue;
              }
              alphaK = pointCurrent.mK / pointCurrent.deltaK;
              betaK = pointAfter.mK / pointCurrent.deltaK;
              squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
              if (squaredMagnitude <= 9) {
                continue;
              }
              tauK = 3 / Math.sqrt(squaredMagnitude);
              pointCurrent.mK = alphaK * tauK * pointCurrent.deltaK;
              pointAfter.mK = betaK * tauK * pointCurrent.deltaK;
            }
            var deltaX;
            for (i = 0; i < pointsLen; ++i) {
              pointCurrent = pointsWithTangents[i];
              if (pointCurrent.model.skip) {
                continue;
              }
              pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
              pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;
              if (pointBefore && !pointBefore.model.skip) {
                deltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;
                pointCurrent.model.controlPointPreviousX = pointCurrent.model.x - deltaX;
                pointCurrent.model.controlPointPreviousY = pointCurrent.model.y - deltaX * pointCurrent.mK;
              }
              if (pointAfter && !pointAfter.model.skip) {
                deltaX = (pointAfter.model.x - pointCurrent.model.x) / 3;
                pointCurrent.model.controlPointNextX = pointCurrent.model.x + deltaX;
                pointCurrent.model.controlPointNextY = pointCurrent.model.y + deltaX * pointCurrent.mK;
              }
            }
          };
          helpers$1.nextItem = function(collection, index, loop) {
            if (loop) {
              return index >= collection.length - 1 ? collection[0] : collection[index + 1];
            }
            return index >= collection.length - 1 ? collection[collection.length - 1] : collection[index + 1];
          };
          helpers$1.previousItem = function(collection, index, loop) {
            if (loop) {
              return index <= 0 ? collection[collection.length - 1] : collection[index - 1];
            }
            return index <= 0 ? collection[0] : collection[index - 1];
          };
          helpers$1.niceNum = function(range, round) {
            var exponent = Math.floor(helpers$1.log10(range));
            var fraction = range / Math.pow(10, exponent);
            var niceFraction;
            if (round) {
              if (fraction < 1.5) {
                niceFraction = 1;
              } else if (fraction < 3) {
                niceFraction = 2;
              } else if (fraction < 7) {
                niceFraction = 5;
              } else {
                niceFraction = 10;
              }
            } else if (fraction <= 1) {
              niceFraction = 1;
            } else if (fraction <= 2) {
              niceFraction = 2;
            } else if (fraction <= 5) {
              niceFraction = 5;
            } else {
              niceFraction = 10;
            }
            return niceFraction * Math.pow(10, exponent);
          };
          helpers$1.requestAnimFrame = function() {
            if (typeof window === "undefined") {
              return function(callback) {
                callback();
              };
            }
            return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {
              return window.setTimeout(callback, 1e3 / 60);
            };
          }();
          helpers$1.getRelativePosition = function(evt, chart) {
            var mouseX, mouseY;
            var e = evt.originalEvent || evt;
            var canvas2 = evt.target || evt.srcElement;
            var boundingRect = canvas2.getBoundingClientRect();
            var touches = e.touches;
            if (touches && touches.length > 0) {
              mouseX = touches[0].clientX;
              mouseY = touches[0].clientY;
            } else {
              mouseX = e.clientX;
              mouseY = e.clientY;
            }
            var paddingLeft = parseFloat(helpers$1.getStyle(canvas2, "padding-left"));
            var paddingTop = parseFloat(helpers$1.getStyle(canvas2, "padding-top"));
            var paddingRight = parseFloat(helpers$1.getStyle(canvas2, "padding-right"));
            var paddingBottom = parseFloat(helpers$1.getStyle(canvas2, "padding-bottom"));
            var width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;
            var height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom;
            mouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / width * canvas2.width / chart.currentDevicePixelRatio);
            mouseY = Math.round((mouseY - boundingRect.top - paddingTop) / height * canvas2.height / chart.currentDevicePixelRatio);
            return {
              x: mouseX,
              y: mouseY
            };
          };
          function parseMaxStyle(styleValue, node, parentProperty) {
            var valueInPixels;
            if (typeof styleValue === "string") {
              valueInPixels = parseInt(styleValue, 10);
              if (styleValue.indexOf("%") !== -1) {
                valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
              }
            } else {
              valueInPixels = styleValue;
            }
            return valueInPixels;
          }
          function isConstrainedValue(value) {
            return value !== void 0 && value !== null && value !== "none";
          }
          function getConstraintDimension(domNode, maxStyle, percentageProperty) {
            var view = document.defaultView;
            var parentNode = helpers$1._getParentNode(domNode);
            var constrainedNode = view.getComputedStyle(domNode)[maxStyle];
            var constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];
            var hasCNode = isConstrainedValue(constrainedNode);
            var hasCContainer = isConstrainedValue(constrainedContainer);
            var infinity = Number.POSITIVE_INFINITY;
            if (hasCNode || hasCContainer) {
              return Math.min(hasCNode ? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity, hasCContainer ? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity);
            }
            return "none";
          }
          helpers$1.getConstraintWidth = function(domNode) {
            return getConstraintDimension(domNode, "max-width", "clientWidth");
          };
          helpers$1.getConstraintHeight = function(domNode) {
            return getConstraintDimension(domNode, "max-height", "clientHeight");
          };
          helpers$1._calculatePadding = function(container, padding, parentDimension) {
            padding = helpers$1.getStyle(container, padding);
            return padding.indexOf("%") > -1 ? parentDimension * parseInt(padding, 10) / 100 : parseInt(padding, 10);
          };
          helpers$1._getParentNode = function(domNode) {
            var parent = domNode.parentNode;
            if (parent && parent.toString() === "[object ShadowRoot]") {
              parent = parent.host;
            }
            return parent;
          };
          helpers$1.getMaximumWidth = function(domNode) {
            var container = helpers$1._getParentNode(domNode);
            if (!container) {
              return domNode.clientWidth;
            }
            var clientWidth = container.clientWidth;
            var paddingLeft = helpers$1._calculatePadding(container, "padding-left", clientWidth);
            var paddingRight = helpers$1._calculatePadding(container, "padding-right", clientWidth);
            var w = clientWidth - paddingLeft - paddingRight;
            var cw = helpers$1.getConstraintWidth(domNode);
            return isNaN(cw) ? w : Math.min(w, cw);
          };
          helpers$1.getMaximumHeight = function(domNode) {
            var container = helpers$1._getParentNode(domNode);
            if (!container) {
              return domNode.clientHeight;
            }
            var clientHeight = container.clientHeight;
            var paddingTop = helpers$1._calculatePadding(container, "padding-top", clientHeight);
            var paddingBottom = helpers$1._calculatePadding(container, "padding-bottom", clientHeight);
            var h = clientHeight - paddingTop - paddingBottom;
            var ch = helpers$1.getConstraintHeight(domNode);
            return isNaN(ch) ? h : Math.min(h, ch);
          };
          helpers$1.getStyle = function(el, property) {
            return el.currentStyle ? el.currentStyle[property] : document.defaultView.getComputedStyle(el, null).getPropertyValue(property);
          };
          helpers$1.retinaScale = function(chart, forceRatio) {
            var pixelRatio = chart.currentDevicePixelRatio = forceRatio || typeof window !== "undefined" && window.devicePixelRatio || 1;
            if (pixelRatio === 1) {
              return;
            }
            var canvas2 = chart.canvas;
            var height = chart.height;
            var width = chart.width;
            canvas2.height = height * pixelRatio;
            canvas2.width = width * pixelRatio;
            chart.ctx.scale(pixelRatio, pixelRatio);
            if (!canvas2.style.height && !canvas2.style.width) {
              canvas2.style.height = height + "px";
              canvas2.style.width = width + "px";
            }
          };
          helpers$1.fontString = function(pixelSize, fontStyle, fontFamily) {
            return fontStyle + " " + pixelSize + "px " + fontFamily;
          };
          helpers$1.longestText = function(ctx, font, arrayOfThings, cache) {
            cache = cache || {};
            var data = cache.data = cache.data || {};
            var gc = cache.garbageCollect = cache.garbageCollect || [];
            if (cache.font !== font) {
              data = cache.data = {};
              gc = cache.garbageCollect = [];
              cache.font = font;
            }
            ctx.font = font;
            var longest = 0;
            var ilen = arrayOfThings.length;
            var i, j, jlen, thing, nestedThing;
            for (i = 0; i < ilen; i++) {
              thing = arrayOfThings[i];
              if (thing !== void 0 && thing !== null && helpers$1.isArray(thing) !== true) {
                longest = helpers$1.measureText(ctx, data, gc, longest, thing);
              } else if (helpers$1.isArray(thing)) {
                for (j = 0, jlen = thing.length; j < jlen; j++) {
                  nestedThing = thing[j];
                  if (nestedThing !== void 0 && nestedThing !== null && !helpers$1.isArray(nestedThing)) {
                    longest = helpers$1.measureText(ctx, data, gc, longest, nestedThing);
                  }
                }
              }
            }
            var gcLen = gc.length / 2;
            if (gcLen > arrayOfThings.length) {
              for (i = 0; i < gcLen; i++) {
                delete data[gc[i]];
              }
              gc.splice(0, gcLen);
            }
            return longest;
          };
          helpers$1.measureText = function(ctx, data, gc, longest, string) {
            var textWidth = data[string];
            if (!textWidth) {
              textWidth = data[string] = ctx.measureText(string).width;
              gc.push(string);
            }
            if (textWidth > longest) {
              longest = textWidth;
            }
            return longest;
          };
          helpers$1.numberOfLabelLines = function(arrayOfThings) {
            var numberOfLines = 1;
            helpers$1.each(arrayOfThings, function(thing) {
              if (helpers$1.isArray(thing)) {
                if (thing.length > numberOfLines) {
                  numberOfLines = thing.length;
                }
              }
            });
            return numberOfLines;
          };
          helpers$1.color = !chartjsColor ? function(value) {
            console.error("Color.js not found!");
            return value;
          } : function(value) {
            if (value instanceof CanvasGradient) {
              value = core_defaults.global.defaultColor;
            }
            return chartjsColor(value);
          };
          helpers$1.getHoverColor = function(colorValue) {
            return colorValue instanceof CanvasPattern || colorValue instanceof CanvasGradient ? colorValue : helpers$1.color(colorValue).saturate(0.5).darken(0.1).rgbString();
          };
        };
        function abstract() {
          throw new Error("This method is not implemented: either no adapter can be found or an incomplete integration was provided.");
        }
        function DateAdapter(options2) {
          this.options = options2 || {};
        }
        helpers$1.extend(DateAdapter.prototype, {
          formats: abstract,
          parse: abstract,
          format: abstract,
          add: abstract,
          diff: abstract,
          startOf: abstract,
          endOf: abstract,
          _create: function(value) {
            return value;
          }
        });
        DateAdapter.override = function(members) {
          helpers$1.extend(DateAdapter.prototype, members);
        };
        var _date = DateAdapter;
        var core_adapters = {
          _date
        };
        var core_ticks = {
          formatters: {
            values: function(value) {
              return helpers$1.isArray(value) ? value : "" + value;
            },
            linear: function(tickValue, index, ticks) {
              var delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0];
              if (Math.abs(delta) > 1) {
                if (tickValue !== Math.floor(tickValue)) {
                  delta = tickValue - Math.floor(tickValue);
                }
              }
              var logDelta = helpers$1.log10(Math.abs(delta));
              var tickString = "";
              if (tickValue !== 0) {
                var maxTick = Math.max(Math.abs(ticks[0]), Math.abs(ticks[ticks.length - 1]));
                if (maxTick < 1e-4) {
                  var logTick = helpers$1.log10(Math.abs(tickValue));
                  var numExponential = Math.floor(logTick) - Math.floor(logDelta);
                  numExponential = Math.max(Math.min(numExponential, 20), 0);
                  tickString = tickValue.toExponential(numExponential);
                } else {
                  var numDecimal = -1 * Math.floor(logDelta);
                  numDecimal = Math.max(Math.min(numDecimal, 20), 0);
                  tickString = tickValue.toFixed(numDecimal);
                }
              } else {
                tickString = "0";
              }
              return tickString;
            },
            logarithmic: function(tickValue, index, ticks) {
              var remain = tickValue / Math.pow(10, Math.floor(helpers$1.log10(tickValue)));
              if (tickValue === 0) {
                return "0";
              } else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {
                return tickValue.toExponential();
              }
              return "";
            }
          }
        };
        var isArray = helpers$1.isArray;
        var isNullOrUndef = helpers$1.isNullOrUndef;
        var valueOrDefault$a = helpers$1.valueOrDefault;
        var valueAtIndexOrDefault = helpers$1.valueAtIndexOrDefault;
        core_defaults._set("scale", {
          display: true,
          position: "left",
          offset: false,
          gridLines: {
            display: true,
            color: "rgba(0,0,0,0.1)",
            lineWidth: 1,
            drawBorder: true,
            drawOnChartArea: true,
            drawTicks: true,
            tickMarkLength: 10,
            zeroLineWidth: 1,
            zeroLineColor: "rgba(0,0,0,0.25)",
            zeroLineBorderDash: [],
            zeroLineBorderDashOffset: 0,
            offsetGridLines: false,
            borderDash: [],
            borderDashOffset: 0
          },
          scaleLabel: {
            display: false,
            labelString: "",
            padding: {
              top: 4,
              bottom: 4
            }
          },
          ticks: {
            beginAtZero: false,
            minRotation: 0,
            maxRotation: 50,
            mirror: false,
            padding: 0,
            reverse: false,
            display: true,
            autoSkip: true,
            autoSkipPadding: 0,
            labelOffset: 0,
            callback: core_ticks.formatters.values,
            minor: {},
            major: {}
          }
        });
        function sample(arr, numItems) {
          var result = [];
          var increment = arr.length / numItems;
          var i = 0;
          var len = arr.length;
          for (; i < len; i += increment) {
            result.push(arr[Math.floor(i)]);
          }
          return result;
        }
        function getPixelForGridLine(scale2, index, offsetGridLines) {
          var length = scale2.getTicks().length;
          var validIndex = Math.min(index, length - 1);
          var lineValue = scale2.getPixelForTick(validIndex);
          var start2 = scale2._startPixel;
          var end = scale2._endPixel;
          var epsilon = 1e-6;
          var offset;
          if (offsetGridLines) {
            if (length === 1) {
              offset = Math.max(lineValue - start2, end - lineValue);
            } else if (index === 0) {
              offset = (scale2.getPixelForTick(1) - lineValue) / 2;
            } else {
              offset = (lineValue - scale2.getPixelForTick(validIndex - 1)) / 2;
            }
            lineValue += validIndex < index ? offset : -offset;
            if (lineValue < start2 - epsilon || lineValue > end + epsilon) {
              return;
            }
          }
          return lineValue;
        }
        function garbageCollect(caches, length) {
          helpers$1.each(caches, function(cache) {
            var gc = cache.gc;
            var gcLen = gc.length / 2;
            var i;
            if (gcLen > length) {
              for (i = 0; i < gcLen; ++i) {
                delete cache.data[gc[i]];
              }
              gc.splice(0, gcLen);
            }
          });
        }
        function computeLabelSizes(ctx, tickFonts, ticks, caches) {
          var length = ticks.length;
          var widths = [];
          var heights = [];
          var offsets = [];
          var widestLabelSize = 0;
          var highestLabelSize = 0;
          var i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel, widest, highest;
          for (i = 0; i < length; ++i) {
            label = ticks[i].label;
            tickFont = ticks[i].major ? tickFonts.major : tickFonts.minor;
            ctx.font = fontString = tickFont.string;
            cache = caches[fontString] = caches[fontString] || { data: {}, gc: [] };
            lineHeight = tickFont.lineHeight;
            width = height = 0;
            if (!isNullOrUndef(label) && !isArray(label)) {
              width = helpers$1.measureText(ctx, cache.data, cache.gc, width, label);
              height = lineHeight;
            } else if (isArray(label)) {
              for (j = 0, jlen = label.length; j < jlen; ++j) {
                nestedLabel = label[j];
                if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {
                  width = helpers$1.measureText(ctx, cache.data, cache.gc, width, nestedLabel);
                  height += lineHeight;
                }
              }
            }
            widths.push(width);
            heights.push(height);
            offsets.push(lineHeight / 2);
            widestLabelSize = Math.max(width, widestLabelSize);
            highestLabelSize = Math.max(height, highestLabelSize);
          }
          garbageCollect(caches, length);
          widest = widths.indexOf(widestLabelSize);
          highest = heights.indexOf(highestLabelSize);
          function valueAt(idx) {
            return {
              width: widths[idx] || 0,
              height: heights[idx] || 0,
              offset: offsets[idx] || 0
            };
          }
          return {
            first: valueAt(0),
            last: valueAt(length - 1),
            widest: valueAt(widest),
            highest: valueAt(highest)
          };
        }
        function getTickMarkLength(options2) {
          return options2.drawTicks ? options2.tickMarkLength : 0;
        }
        function getScaleLabelHeight(options2) {
          var font, padding;
          if (!options2.display) {
            return 0;
          }
          font = helpers$1.options._parseFont(options2);
          padding = helpers$1.options.toPadding(options2.padding);
          return font.lineHeight + padding.height;
        }
        function parseFontOptions(options2, nestedOpts) {
          return helpers$1.extend(helpers$1.options._parseFont({
            fontFamily: valueOrDefault$a(nestedOpts.fontFamily, options2.fontFamily),
            fontSize: valueOrDefault$a(nestedOpts.fontSize, options2.fontSize),
            fontStyle: valueOrDefault$a(nestedOpts.fontStyle, options2.fontStyle),
            lineHeight: valueOrDefault$a(nestedOpts.lineHeight, options2.lineHeight)
          }), {
            color: helpers$1.options.resolve([nestedOpts.fontColor, options2.fontColor, core_defaults.global.defaultFontColor])
          });
        }
        function parseTickFontOptions(options2) {
          var minor = parseFontOptions(options2, options2.minor);
          var major = options2.major.enabled ? parseFontOptions(options2, options2.major) : minor;
          return { minor, major };
        }
        function nonSkipped(ticksToFilter) {
          var filtered = [];
          var item2, index, len;
          for (index = 0, len = ticksToFilter.length; index < len; ++index) {
            item2 = ticksToFilter[index];
            if (typeof item2._index !== "undefined") {
              filtered.push(item2);
            }
          }
          return filtered;
        }
        function getEvenSpacing(arr) {
          var len = arr.length;
          var i, diff;
          if (len < 2) {
            return false;
          }
          for (diff = arr[0], i = 1; i < len; ++i) {
            if (arr[i] - arr[i - 1] !== diff) {
              return false;
            }
          }
          return diff;
        }
        function calculateSpacing(majorIndices, ticks, axisLength, ticksLimit) {
          var evenMajorSpacing = getEvenSpacing(majorIndices);
          var spacing = (ticks.length - 1) / ticksLimit;
          var factors, factor, i, ilen;
          if (!evenMajorSpacing) {
            return Math.max(spacing, 1);
          }
          factors = helpers$1.math._factorize(evenMajorSpacing);
          for (i = 0, ilen = factors.length - 1; i < ilen; i++) {
            factor = factors[i];
            if (factor > spacing) {
              return factor;
            }
          }
          return Math.max(spacing, 1);
        }
        function getMajorIndices(ticks) {
          var result = [];
          var i, ilen;
          for (i = 0, ilen = ticks.length; i < ilen; i++) {
            if (ticks[i].major) {
              result.push(i);
            }
          }
          return result;
        }
        function skipMajors(ticks, majorIndices, spacing) {
          var count = 0;
          var next = majorIndices[0];
          var i, tick2;
          spacing = Math.ceil(spacing);
          for (i = 0; i < ticks.length; i++) {
            tick2 = ticks[i];
            if (i === next) {
              tick2._index = i;
              count++;
              next = majorIndices[count * spacing];
            } else {
              delete tick2.label;
            }
          }
        }
        function skip(ticks, spacing, majorStart, majorEnd) {
          var start2 = valueOrDefault$a(majorStart, 0);
          var end = Math.min(valueOrDefault$a(majorEnd, ticks.length), ticks.length);
          var count = 0;
          var length, i, tick2, next;
          spacing = Math.ceil(spacing);
          if (majorEnd) {
            length = majorEnd - majorStart;
            spacing = length / Math.floor(length / spacing);
          }
          next = start2;
          while (next < 0) {
            count++;
            next = Math.round(start2 + count * spacing);
          }
          for (i = Math.max(start2, 0); i < end; i++) {
            tick2 = ticks[i];
            if (i === next) {
              tick2._index = i;
              count++;
              next = Math.round(start2 + count * spacing);
            } else {
              delete tick2.label;
            }
          }
        }
        var Scale = core_element.extend({
          zeroLineIndex: 0,
          getPadding: function() {
            var me = this;
            return {
              left: me.paddingLeft || 0,
              top: me.paddingTop || 0,
              right: me.paddingRight || 0,
              bottom: me.paddingBottom || 0
            };
          },
          getTicks: function() {
            return this._ticks;
          },
          _getLabels: function() {
            var data = this.chart.data;
            return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
          },
          mergeTicksOptions: function() {
          },
          beforeUpdate: function() {
            helpers$1.callback(this.options.beforeUpdate, [this]);
          },
          update: function(maxWidth, maxHeight, margins) {
            var me = this;
            var tickOpts = me.options.ticks;
            var sampleSize = tickOpts.sampleSize;
            var i, ilen, labels, ticks, samplingEnabled;
            me.beforeUpdate();
            me.maxWidth = maxWidth;
            me.maxHeight = maxHeight;
            me.margins = helpers$1.extend({
              left: 0,
              right: 0,
              top: 0,
              bottom: 0
            }, margins);
            me._ticks = null;
            me.ticks = null;
            me._labelSizes = null;
            me._maxLabelLines = 0;
            me.longestLabelWidth = 0;
            me.longestTextCache = me.longestTextCache || {};
            me._gridLineItems = null;
            me._labelItems = null;
            me.beforeSetDimensions();
            me.setDimensions();
            me.afterSetDimensions();
            me.beforeDataLimits();
            me.determineDataLimits();
            me.afterDataLimits();
            me.beforeBuildTicks();
            ticks = me.buildTicks() || [];
            ticks = me.afterBuildTicks(ticks) || ticks;
            if ((!ticks || !ticks.length) && me.ticks) {
              ticks = [];
              for (i = 0, ilen = me.ticks.length; i < ilen; ++i) {
                ticks.push({
                  value: me.ticks[i],
                  major: false
                });
              }
            }
            me._ticks = ticks;
            samplingEnabled = sampleSize < ticks.length;
            labels = me._convertTicksToLabels(samplingEnabled ? sample(ticks, sampleSize) : ticks);
            me._configure();
            me.beforeCalculateTickRotation();
            me.calculateTickRotation();
            me.afterCalculateTickRotation();
            me.beforeFit();
            me.fit();
            me.afterFit();
            me._ticksToDraw = tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto") ? me._autoSkip(ticks) : ticks;
            if (samplingEnabled) {
              labels = me._convertTicksToLabels(me._ticksToDraw);
            }
            me.ticks = labels;
            me.afterUpdate();
            return me.minSize;
          },
          _configure: function() {
            var me = this;
            var reversePixels = me.options.ticks.reverse;
            var startPixel, endPixel;
            if (me.isHorizontal()) {
              startPixel = me.left;
              endPixel = me.right;
            } else {
              startPixel = me.top;
              endPixel = me.bottom;
              reversePixels = !reversePixels;
            }
            me._startPixel = startPixel;
            me._endPixel = endPixel;
            me._reversePixels = reversePixels;
            me._length = endPixel - startPixel;
          },
          afterUpdate: function() {
            helpers$1.callback(this.options.afterUpdate, [this]);
          },
          beforeSetDimensions: function() {
            helpers$1.callback(this.options.beforeSetDimensions, [this]);
          },
          setDimensions: function() {
            var me = this;
            if (me.isHorizontal()) {
              me.width = me.maxWidth;
              me.left = 0;
              me.right = me.width;
            } else {
              me.height = me.maxHeight;
              me.top = 0;
              me.bottom = me.height;
            }
            me.paddingLeft = 0;
            me.paddingTop = 0;
            me.paddingRight = 0;
            me.paddingBottom = 0;
          },
          afterSetDimensions: function() {
            helpers$1.callback(this.options.afterSetDimensions, [this]);
          },
          beforeDataLimits: function() {
            helpers$1.callback(this.options.beforeDataLimits, [this]);
          },
          determineDataLimits: helpers$1.noop,
          afterDataLimits: function() {
            helpers$1.callback(this.options.afterDataLimits, [this]);
          },
          beforeBuildTicks: function() {
            helpers$1.callback(this.options.beforeBuildTicks, [this]);
          },
          buildTicks: helpers$1.noop,
          afterBuildTicks: function(ticks) {
            var me = this;
            if (isArray(ticks) && ticks.length) {
              return helpers$1.callback(me.options.afterBuildTicks, [me, ticks]);
            }
            me.ticks = helpers$1.callback(me.options.afterBuildTicks, [me, me.ticks]) || me.ticks;
            return ticks;
          },
          beforeTickToLabelConversion: function() {
            helpers$1.callback(this.options.beforeTickToLabelConversion, [this]);
          },
          convertTicksToLabels: function() {
            var me = this;
            var tickOpts = me.options.ticks;
            me.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback, this);
          },
          afterTickToLabelConversion: function() {
            helpers$1.callback(this.options.afterTickToLabelConversion, [this]);
          },
          beforeCalculateTickRotation: function() {
            helpers$1.callback(this.options.beforeCalculateTickRotation, [this]);
          },
          calculateTickRotation: function() {
            var me = this;
            var options2 = me.options;
            var tickOpts = options2.ticks;
            var numTicks = me.getTicks().length;
            var minRotation = tickOpts.minRotation || 0;
            var maxRotation = tickOpts.maxRotation;
            var labelRotation = minRotation;
            var labelSizes, maxLabelWidth, maxLabelHeight, maxWidth, tickWidth, maxHeight, maxLabelDiagonal;
            if (!me._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !me.isHorizontal()) {
              me.labelRotation = minRotation;
              return;
            }
            labelSizes = me._getLabelSizes();
            maxLabelWidth = labelSizes.widest.width;
            maxLabelHeight = labelSizes.highest.height - labelSizes.highest.offset;
            maxWidth = Math.min(me.maxWidth, me.chart.width - maxLabelWidth);
            tickWidth = options2.offset ? me.maxWidth / numTicks : maxWidth / (numTicks - 1);
            if (maxLabelWidth + 6 > tickWidth) {
              tickWidth = maxWidth / (numTicks - (options2.offset ? 0.5 : 1));
              maxHeight = me.maxHeight - getTickMarkLength(options2.gridLines) - tickOpts.padding - getScaleLabelHeight(options2.scaleLabel);
              maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
              labelRotation = helpers$1.toDegrees(Math.min(Math.asin(Math.min((labelSizes.highest.height + 6) / tickWidth, 1)), Math.asin(Math.min(maxHeight / maxLabelDiagonal, 1)) - Math.asin(maxLabelHeight / maxLabelDiagonal)));
              labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
            }
            me.labelRotation = labelRotation;
          },
          afterCalculateTickRotation: function() {
            helpers$1.callback(this.options.afterCalculateTickRotation, [this]);
          },
          beforeFit: function() {
            helpers$1.callback(this.options.beforeFit, [this]);
          },
          fit: function() {
            var me = this;
            var minSize = me.minSize = {
              width: 0,
              height: 0
            };
            var chart = me.chart;
            var opts = me.options;
            var tickOpts = opts.ticks;
            var scaleLabelOpts = opts.scaleLabel;
            var gridLineOpts = opts.gridLines;
            var display = me._isVisible();
            var isBottom = opts.position === "bottom";
            var isHorizontal = me.isHorizontal();
            if (isHorizontal) {
              minSize.width = me.maxWidth;
            } else if (display) {
              minSize.width = getTickMarkLength(gridLineOpts) + getScaleLabelHeight(scaleLabelOpts);
            }
            if (!isHorizontal) {
              minSize.height = me.maxHeight;
            } else if (display) {
              minSize.height = getTickMarkLength(gridLineOpts) + getScaleLabelHeight(scaleLabelOpts);
            }
            if (tickOpts.display && display) {
              var tickFonts = parseTickFontOptions(tickOpts);
              var labelSizes = me._getLabelSizes();
              var firstLabelSize = labelSizes.first;
              var lastLabelSize = labelSizes.last;
              var widestLabelSize = labelSizes.widest;
              var highestLabelSize = labelSizes.highest;
              var lineSpace = tickFonts.minor.lineHeight * 0.4;
              var tickPadding = tickOpts.padding;
              if (isHorizontal) {
                var isRotated = me.labelRotation !== 0;
                var angleRadians = helpers$1.toRadians(me.labelRotation);
                var cosRotation = Math.cos(angleRadians);
                var sinRotation = Math.sin(angleRadians);
                var labelHeight = sinRotation * widestLabelSize.width + cosRotation * (highestLabelSize.height - (isRotated ? highestLabelSize.offset : 0)) + (isRotated ? 0 : lineSpace);
                minSize.height = Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);
                var offsetLeft = me.getPixelForTick(0) - me.left;
                var offsetRight = me.right - me.getPixelForTick(me.getTicks().length - 1);
                var paddingLeft, paddingRight;
                if (isRotated) {
                  paddingLeft = isBottom ? cosRotation * firstLabelSize.width + sinRotation * firstLabelSize.offset : sinRotation * (firstLabelSize.height - firstLabelSize.offset);
                  paddingRight = isBottom ? sinRotation * (lastLabelSize.height - lastLabelSize.offset) : cosRotation * lastLabelSize.width + sinRotation * lastLabelSize.offset;
                } else {
                  paddingLeft = firstLabelSize.width / 2;
                  paddingRight = lastLabelSize.width / 2;
                }
                me.paddingLeft = Math.max((paddingLeft - offsetLeft) * me.width / (me.width - offsetLeft), 0) + 3;
                me.paddingRight = Math.max((paddingRight - offsetRight) * me.width / (me.width - offsetRight), 0) + 3;
              } else {
                var labelWidth = tickOpts.mirror ? 0 : widestLabelSize.width + tickPadding + lineSpace;
                minSize.width = Math.min(me.maxWidth, minSize.width + labelWidth);
                me.paddingTop = firstLabelSize.height / 2;
                me.paddingBottom = lastLabelSize.height / 2;
              }
            }
            me.handleMargins();
            if (isHorizontal) {
              me.width = me._length = chart.width - me.margins.left - me.margins.right;
              me.height = minSize.height;
            } else {
              me.width = minSize.width;
              me.height = me._length = chart.height - me.margins.top - me.margins.bottom;
            }
          },
          handleMargins: function() {
            var me = this;
            if (me.margins) {
              me.margins.left = Math.max(me.paddingLeft, me.margins.left);
              me.margins.top = Math.max(me.paddingTop, me.margins.top);
              me.margins.right = Math.max(me.paddingRight, me.margins.right);
              me.margins.bottom = Math.max(me.paddingBottom, me.margins.bottom);
            }
          },
          afterFit: function() {
            helpers$1.callback(this.options.afterFit, [this]);
          },
          isHorizontal: function() {
            var pos = this.options.position;
            return pos === "top" || pos === "bottom";
          },
          isFullWidth: function() {
            return this.options.fullWidth;
          },
          getRightValue: function(rawValue) {
            if (isNullOrUndef(rawValue)) {
              return NaN;
            }
            if ((typeof rawValue === "number" || rawValue instanceof Number) && !isFinite(rawValue)) {
              return NaN;
            }
            if (rawValue) {
              if (this.isHorizontal()) {
                if (rawValue.x !== void 0) {
                  return this.getRightValue(rawValue.x);
                }
              } else if (rawValue.y !== void 0) {
                return this.getRightValue(rawValue.y);
              }
            }
            return rawValue;
          },
          _convertTicksToLabels: function(ticks) {
            var me = this;
            var labels, i, ilen;
            me.ticks = ticks.map(function(tick2) {
              return tick2.value;
            });
            me.beforeTickToLabelConversion();
            labels = me.convertTicksToLabels(ticks) || me.ticks;
            me.afterTickToLabelConversion();
            for (i = 0, ilen = ticks.length; i < ilen; ++i) {
              ticks[i].label = labels[i];
            }
            return labels;
          },
          _getLabelSizes: function() {
            var me = this;
            var labelSizes = me._labelSizes;
            if (!labelSizes) {
              me._labelSizes = labelSizes = computeLabelSizes(me.ctx, parseTickFontOptions(me.options.ticks), me.getTicks(), me.longestTextCache);
              me.longestLabelWidth = labelSizes.widest.width;
            }
            return labelSizes;
          },
          _parseValue: function(value) {
            var start2, end, min, max;
            if (isArray(value)) {
              start2 = +this.getRightValue(value[0]);
              end = +this.getRightValue(value[1]);
              min = Math.min(start2, end);
              max = Math.max(start2, end);
            } else {
              value = +this.getRightValue(value);
              start2 = void 0;
              end = value;
              min = value;
              max = value;
            }
            return {
              min,
              max,
              start: start2,
              end
            };
          },
          _getScaleLabel: function(rawValue) {
            var v = this._parseValue(rawValue);
            if (v.start !== void 0) {
              return "[" + v.start + ", " + v.end + "]";
            }
            return +this.getRightValue(rawValue);
          },
          getLabelForIndex: helpers$1.noop,
          getPixelForValue: helpers$1.noop,
          getValueForPixel: helpers$1.noop,
          getPixelForTick: function(index) {
            var me = this;
            var offset = me.options.offset;
            var numTicks = me._ticks.length;
            var tickWidth = 1 / Math.max(numTicks - (offset ? 0 : 1), 1);
            return index < 0 || index > numTicks - 1 ? null : me.getPixelForDecimal(index * tickWidth + (offset ? tickWidth / 2 : 0));
          },
          getPixelForDecimal: function(decimal) {
            var me = this;
            if (me._reversePixels) {
              decimal = 1 - decimal;
            }
            return me._startPixel + decimal * me._length;
          },
          getDecimalForPixel: function(pixel) {
            var decimal = (pixel - this._startPixel) / this._length;
            return this._reversePixels ? 1 - decimal : decimal;
          },
          getBasePixel: function() {
            return this.getPixelForValue(this.getBaseValue());
          },
          getBaseValue: function() {
            var me = this;
            var min = me.min;
            var max = me.max;
            return me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
          },
          _autoSkip: function(ticks) {
            var me = this;
            var tickOpts = me.options.ticks;
            var axisLength = me._length;
            var ticksLimit = tickOpts.maxTicksLimit || axisLength / me._tickSize() + 1;
            var majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
            var numMajorIndices = majorIndices.length;
            var first = majorIndices[0];
            var last = majorIndices[numMajorIndices - 1];
            var i, ilen, spacing, avgMajorSpacing;
            if (numMajorIndices > ticksLimit) {
              skipMajors(ticks, majorIndices, numMajorIndices / ticksLimit);
              return nonSkipped(ticks);
            }
            spacing = calculateSpacing(majorIndices, ticks, axisLength, ticksLimit);
            if (numMajorIndices > 0) {
              for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {
                skip(ticks, spacing, majorIndices[i], majorIndices[i + 1]);
              }
              avgMajorSpacing = numMajorIndices > 1 ? (last - first) / (numMajorIndices - 1) : null;
              skip(ticks, spacing, helpers$1.isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
              skip(ticks, spacing, last, helpers$1.isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
              return nonSkipped(ticks);
            }
            skip(ticks, spacing);
            return nonSkipped(ticks);
          },
          _tickSize: function() {
            var me = this;
            var optionTicks = me.options.ticks;
            var rot = helpers$1.toRadians(me.labelRotation);
            var cos = Math.abs(Math.cos(rot));
            var sin = Math.abs(Math.sin(rot));
            var labelSizes = me._getLabelSizes();
            var padding = optionTicks.autoSkipPadding || 0;
            var w = labelSizes ? labelSizes.widest.width + padding : 0;
            var h = labelSizes ? labelSizes.highest.height + padding : 0;
            return me.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
          },
          _isVisible: function() {
            var me = this;
            var chart = me.chart;
            var display = me.options.display;
            var i, ilen, meta;
            if (display !== "auto") {
              return !!display;
            }
            for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
              if (chart.isDatasetVisible(i)) {
                meta = chart.getDatasetMeta(i);
                if (meta.xAxisID === me.id || meta.yAxisID === me.id) {
                  return true;
                }
              }
            }
            return false;
          },
          _computeGridLineItems: function(chartArea) {
            var me = this;
            var chart = me.chart;
            var options2 = me.options;
            var gridLines = options2.gridLines;
            var position = options2.position;
            var offsetGridLines = gridLines.offsetGridLines;
            var isHorizontal = me.isHorizontal();
            var ticks = me._ticksToDraw;
            var ticksLength = ticks.length + (offsetGridLines ? 1 : 0);
            var tl = getTickMarkLength(gridLines);
            var items = [];
            var axisWidth = gridLines.drawBorder ? valueAtIndexOrDefault(gridLines.lineWidth, 0, 0) : 0;
            var axisHalfWidth = axisWidth / 2;
            var alignPixel = helpers$1._alignPixel;
            var alignBorderValue = function(pixel) {
              return alignPixel(chart, pixel, axisWidth);
            };
            var borderValue, i, tick2, lineValue, alignedLineValue;
            var tx1, ty1, tx2, ty2, x1, y1, x2, y2, lineWidth, lineColor, borderDash, borderDashOffset;
            if (position === "top") {
              borderValue = alignBorderValue(me.bottom);
              ty1 = me.bottom - tl;
              ty2 = borderValue - axisHalfWidth;
              y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
              y2 = chartArea.bottom;
            } else if (position === "bottom") {
              borderValue = alignBorderValue(me.top);
              y1 = chartArea.top;
              y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
              ty1 = borderValue + axisHalfWidth;
              ty2 = me.top + tl;
            } else if (position === "left") {
              borderValue = alignBorderValue(me.right);
              tx1 = me.right - tl;
              tx2 = borderValue - axisHalfWidth;
              x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
              x2 = chartArea.right;
            } else {
              borderValue = alignBorderValue(me.left);
              x1 = chartArea.left;
              x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
              tx1 = borderValue + axisHalfWidth;
              tx2 = me.left + tl;
            }
            for (i = 0; i < ticksLength; ++i) {
              tick2 = ticks[i] || {};
              if (isNullOrUndef(tick2.label) && i < ticks.length) {
                continue;
              }
              if (i === me.zeroLineIndex && options2.offset === offsetGridLines) {
                lineWidth = gridLines.zeroLineWidth;
                lineColor = gridLines.zeroLineColor;
                borderDash = gridLines.zeroLineBorderDash || [];
                borderDashOffset = gridLines.zeroLineBorderDashOffset || 0;
              } else {
                lineWidth = valueAtIndexOrDefault(gridLines.lineWidth, i, 1);
                lineColor = valueAtIndexOrDefault(gridLines.color, i, "rgba(0,0,0,0.1)");
                borderDash = gridLines.borderDash || [];
                borderDashOffset = gridLines.borderDashOffset || 0;
              }
              lineValue = getPixelForGridLine(me, tick2._index || i, offsetGridLines);
              if (lineValue === void 0) {
                continue;
              }
              alignedLineValue = alignPixel(chart, lineValue, lineWidth);
              if (isHorizontal) {
                tx1 = tx2 = x1 = x2 = alignedLineValue;
              } else {
                ty1 = ty2 = y1 = y2 = alignedLineValue;
              }
              items.push({
                tx1,
                ty1,
                tx2,
                ty2,
                x1,
                y1,
                x2,
                y2,
                width: lineWidth,
                color: lineColor,
                borderDash,
                borderDashOffset
              });
            }
            items.ticksLength = ticksLength;
            items.borderValue = borderValue;
            return items;
          },
          _computeLabelItems: function() {
            var me = this;
            var options2 = me.options;
            var optionTicks = options2.ticks;
            var position = options2.position;
            var isMirrored = optionTicks.mirror;
            var isHorizontal = me.isHorizontal();
            var ticks = me._ticksToDraw;
            var fonts = parseTickFontOptions(optionTicks);
            var tickPadding = optionTicks.padding;
            var tl = getTickMarkLength(options2.gridLines);
            var rotation = -helpers$1.toRadians(me.labelRotation);
            var items = [];
            var i, ilen, tick2, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
            if (position === "top") {
              y = me.bottom - tl - tickPadding;
              textAlign = !rotation ? "center" : "left";
            } else if (position === "bottom") {
              y = me.top + tl + tickPadding;
              textAlign = !rotation ? "center" : "right";
            } else if (position === "left") {
              x = me.right - (isMirrored ? 0 : tl) - tickPadding;
              textAlign = isMirrored ? "left" : "right";
            } else {
              x = me.left + (isMirrored ? 0 : tl) + tickPadding;
              textAlign = isMirrored ? "right" : "left";
            }
            for (i = 0, ilen = ticks.length; i < ilen; ++i) {
              tick2 = ticks[i];
              label = tick2.label;
              if (isNullOrUndef(label)) {
                continue;
              }
              pixel = me.getPixelForTick(tick2._index || i) + optionTicks.labelOffset;
              font = tick2.major ? fonts.major : fonts.minor;
              lineHeight = font.lineHeight;
              lineCount = isArray(label) ? label.length : 1;
              if (isHorizontal) {
                x = pixel;
                textOffset = position === "top" ? ((!rotation ? 0.5 : 1) - lineCount) * lineHeight : (!rotation ? 0.5 : 0) * lineHeight;
              } else {
                y = pixel;
                textOffset = (1 - lineCount) * lineHeight / 2;
              }
              items.push({
                x,
                y,
                rotation,
                label,
                font,
                textOffset,
                textAlign
              });
            }
            return items;
          },
          _drawGrid: function(chartArea) {
            var me = this;
            var gridLines = me.options.gridLines;
            if (!gridLines.display) {
              return;
            }
            var ctx = me.ctx;
            var chart = me.chart;
            var alignPixel = helpers$1._alignPixel;
            var axisWidth = gridLines.drawBorder ? valueAtIndexOrDefault(gridLines.lineWidth, 0, 0) : 0;
            var items = me._gridLineItems || (me._gridLineItems = me._computeGridLineItems(chartArea));
            var width, color, i, ilen, item2;
            for (i = 0, ilen = items.length; i < ilen; ++i) {
              item2 = items[i];
              width = item2.width;
              color = item2.color;
              if (width && color) {
                ctx.save();
                ctx.lineWidth = width;
                ctx.strokeStyle = color;
                if (ctx.setLineDash) {
                  ctx.setLineDash(item2.borderDash);
                  ctx.lineDashOffset = item2.borderDashOffset;
                }
                ctx.beginPath();
                if (gridLines.drawTicks) {
                  ctx.moveTo(item2.tx1, item2.ty1);
                  ctx.lineTo(item2.tx2, item2.ty2);
                }
                if (gridLines.drawOnChartArea) {
                  ctx.moveTo(item2.x1, item2.y1);
                  ctx.lineTo(item2.x2, item2.y2);
                }
                ctx.stroke();
                ctx.restore();
              }
            }
            if (axisWidth) {
              var firstLineWidth = axisWidth;
              var lastLineWidth = valueAtIndexOrDefault(gridLines.lineWidth, items.ticksLength - 1, 1);
              var borderValue = items.borderValue;
              var x1, x2, y1, y2;
              if (me.isHorizontal()) {
                x1 = alignPixel(chart, me.left, firstLineWidth) - firstLineWidth / 2;
                x2 = alignPixel(chart, me.right, lastLineWidth) + lastLineWidth / 2;
                y1 = y2 = borderValue;
              } else {
                y1 = alignPixel(chart, me.top, firstLineWidth) - firstLineWidth / 2;
                y2 = alignPixel(chart, me.bottom, lastLineWidth) + lastLineWidth / 2;
                x1 = x2 = borderValue;
              }
              ctx.lineWidth = axisWidth;
              ctx.strokeStyle = valueAtIndexOrDefault(gridLines.color, 0);
              ctx.beginPath();
              ctx.moveTo(x1, y1);
              ctx.lineTo(x2, y2);
              ctx.stroke();
            }
          },
          _drawLabels: function() {
            var me = this;
            var optionTicks = me.options.ticks;
            if (!optionTicks.display) {
              return;
            }
            var ctx = me.ctx;
            var items = me._labelItems || (me._labelItems = me._computeLabelItems());
            var i, j, ilen, jlen, item2, tickFont, label, y;
            for (i = 0, ilen = items.length; i < ilen; ++i) {
              item2 = items[i];
              tickFont = item2.font;
              ctx.save();
              ctx.translate(item2.x, item2.y);
              ctx.rotate(item2.rotation);
              ctx.font = tickFont.string;
              ctx.fillStyle = tickFont.color;
              ctx.textBaseline = "middle";
              ctx.textAlign = item2.textAlign;
              label = item2.label;
              y = item2.textOffset;
              if (isArray(label)) {
                for (j = 0, jlen = label.length; j < jlen; ++j) {
                  ctx.fillText("" + label[j], 0, y);
                  y += tickFont.lineHeight;
                }
              } else {
                ctx.fillText(label, 0, y);
              }
              ctx.restore();
            }
          },
          _drawTitle: function() {
            var me = this;
            var ctx = me.ctx;
            var options2 = me.options;
            var scaleLabel = options2.scaleLabel;
            if (!scaleLabel.display) {
              return;
            }
            var scaleLabelFontColor = valueOrDefault$a(scaleLabel.fontColor, core_defaults.global.defaultFontColor);
            var scaleLabelFont = helpers$1.options._parseFont(scaleLabel);
            var scaleLabelPadding = helpers$1.options.toPadding(scaleLabel.padding);
            var halfLineHeight = scaleLabelFont.lineHeight / 2;
            var position = options2.position;
            var rotation = 0;
            var scaleLabelX, scaleLabelY;
            if (me.isHorizontal()) {
              scaleLabelX = me.left + me.width / 2;
              scaleLabelY = position === "bottom" ? me.bottom - halfLineHeight - scaleLabelPadding.bottom : me.top + halfLineHeight + scaleLabelPadding.top;
            } else {
              var isLeft = position === "left";
              scaleLabelX = isLeft ? me.left + halfLineHeight + scaleLabelPadding.top : me.right - halfLineHeight - scaleLabelPadding.top;
              scaleLabelY = me.top + me.height / 2;
              rotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;
            }
            ctx.save();
            ctx.translate(scaleLabelX, scaleLabelY);
            ctx.rotate(rotation);
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillStyle = scaleLabelFontColor;
            ctx.font = scaleLabelFont.string;
            ctx.fillText(scaleLabel.labelString, 0, 0);
            ctx.restore();
          },
          draw: function(chartArea) {
            var me = this;
            if (!me._isVisible()) {
              return;
            }
            me._drawGrid(chartArea);
            me._drawTitle();
            me._drawLabels();
          },
          _layers: function() {
            var me = this;
            var opts = me.options;
            var tz = opts.ticks && opts.ticks.z || 0;
            var gz = opts.gridLines && opts.gridLines.z || 0;
            if (!me._isVisible() || tz === gz || me.draw !== me._draw) {
              return [{
                z: tz,
                draw: function() {
                  me.draw.apply(me, arguments);
                }
              }];
            }
            return [{
              z: gz,
              draw: function() {
                me._drawGrid.apply(me, arguments);
                me._drawTitle.apply(me, arguments);
              }
            }, {
              z: tz,
              draw: function() {
                me._drawLabels.apply(me, arguments);
              }
            }];
          },
          _getMatchingVisibleMetas: function(type) {
            var me = this;
            var isHorizontal = me.isHorizontal();
            return me.chart._getSortedVisibleDatasetMetas().filter(function(meta) {
              return (!type || meta.type === type) && (isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id);
            });
          }
        });
        Scale.prototype._draw = Scale.prototype.draw;
        var core_scale = Scale;
        var isNullOrUndef$1 = helpers$1.isNullOrUndef;
        var defaultConfig = {
          position: "bottom"
        };
        var scale_category = core_scale.extend({
          determineDataLimits: function() {
            var me = this;
            var labels = me._getLabels();
            var ticksOpts = me.options.ticks;
            var min = ticksOpts.min;
            var max = ticksOpts.max;
            var minIndex = 0;
            var maxIndex = labels.length - 1;
            var findIndex;
            if (min !== void 0) {
              findIndex = labels.indexOf(min);
              if (findIndex >= 0) {
                minIndex = findIndex;
              }
            }
            if (max !== void 0) {
              findIndex = labels.indexOf(max);
              if (findIndex >= 0) {
                maxIndex = findIndex;
              }
            }
            me.minIndex = minIndex;
            me.maxIndex = maxIndex;
            me.min = labels[minIndex];
            me.max = labels[maxIndex];
          },
          buildTicks: function() {
            var me = this;
            var labels = me._getLabels();
            var minIndex = me.minIndex;
            var maxIndex = me.maxIndex;
            me.ticks = minIndex === 0 && maxIndex === labels.length - 1 ? labels : labels.slice(minIndex, maxIndex + 1);
          },
          getLabelForIndex: function(index, datasetIndex) {
            var me = this;
            var chart = me.chart;
            if (chart.getDatasetMeta(datasetIndex).controller._getValueScaleId() === me.id) {
              return me.getRightValue(chart.data.datasets[datasetIndex].data[index]);
            }
            return me._getLabels()[index];
          },
          _configure: function() {
            var me = this;
            var offset = me.options.offset;
            var ticks = me.ticks;
            core_scale.prototype._configure.call(me);
            if (!me.isHorizontal()) {
              me._reversePixels = !me._reversePixels;
            }
            if (!ticks) {
              return;
            }
            me._startValue = me.minIndex - (offset ? 0.5 : 0);
            me._valueRange = Math.max(ticks.length - (offset ? 0 : 1), 1);
          },
          getPixelForValue: function(value, index, datasetIndex) {
            var me = this;
            var valueCategory, labels, idx;
            if (!isNullOrUndef$1(index) && !isNullOrUndef$1(datasetIndex)) {
              value = me.chart.data.datasets[datasetIndex].data[index];
            }
            if (!isNullOrUndef$1(value)) {
              valueCategory = me.isHorizontal() ? value.x : value.y;
            }
            if (valueCategory !== void 0 || value !== void 0 && isNaN(index)) {
              labels = me._getLabels();
              value = helpers$1.valueOrDefault(valueCategory, value);
              idx = labels.indexOf(value);
              index = idx !== -1 ? idx : index;
              if (isNaN(index)) {
                index = value;
              }
            }
            return me.getPixelForDecimal((index - me._startValue) / me._valueRange);
          },
          getPixelForTick: function(index) {
            var ticks = this.ticks;
            return index < 0 || index > ticks.length - 1 ? null : this.getPixelForValue(ticks[index], index + this.minIndex);
          },
          getValueForPixel: function(pixel) {
            var me = this;
            var value = Math.round(me._startValue + me.getDecimalForPixel(pixel) * me._valueRange);
            return Math.min(Math.max(value, 0), me.ticks.length - 1);
          },
          getBasePixel: function() {
            return this.bottom;
          }
        });
        var _defaults = defaultConfig;
        scale_category._defaults = _defaults;
        var noop2 = helpers$1.noop;
        var isNullOrUndef$2 = helpers$1.isNullOrUndef;
        function generateTicks(generationOptions, dataRange) {
          var ticks = [];
          var MIN_SPACING = 1e-14;
          var stepSize = generationOptions.stepSize;
          var unit = stepSize || 1;
          var maxNumSpaces = generationOptions.maxTicks - 1;
          var min = generationOptions.min;
          var max = generationOptions.max;
          var precision = generationOptions.precision;
          var rmin = dataRange.min;
          var rmax = dataRange.max;
          var spacing = helpers$1.niceNum((rmax - rmin) / maxNumSpaces / unit) * unit;
          var factor, niceMin, niceMax, numSpaces;
          if (spacing < MIN_SPACING && isNullOrUndef$2(min) && isNullOrUndef$2(max)) {
            return [rmin, rmax];
          }
          numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
          if (numSpaces > maxNumSpaces) {
            spacing = helpers$1.niceNum(numSpaces * spacing / maxNumSpaces / unit) * unit;
          }
          if (stepSize || isNullOrUndef$2(precision)) {
            factor = Math.pow(10, helpers$1._decimalPlaces(spacing));
          } else {
            factor = Math.pow(10, precision);
            spacing = Math.ceil(spacing * factor) / factor;
          }
          niceMin = Math.floor(rmin / spacing) * spacing;
          niceMax = Math.ceil(rmax / spacing) * spacing;
          if (stepSize) {
            if (!isNullOrUndef$2(min) && helpers$1.almostWhole(min / spacing, spacing / 1e3)) {
              niceMin = min;
            }
            if (!isNullOrUndef$2(max) && helpers$1.almostWhole(max / spacing, spacing / 1e3)) {
              niceMax = max;
            }
          }
          numSpaces = (niceMax - niceMin) / spacing;
          if (helpers$1.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
            numSpaces = Math.round(numSpaces);
          } else {
            numSpaces = Math.ceil(numSpaces);
          }
          niceMin = Math.round(niceMin * factor) / factor;
          niceMax = Math.round(niceMax * factor) / factor;
          ticks.push(isNullOrUndef$2(min) ? niceMin : min);
          for (var j = 1; j < numSpaces; ++j) {
            ticks.push(Math.round((niceMin + j * spacing) * factor) / factor);
          }
          ticks.push(isNullOrUndef$2(max) ? niceMax : max);
          return ticks;
        }
        var scale_linearbase = core_scale.extend({
          getRightValue: function(value) {
            if (typeof value === "string") {
              return +value;
            }
            return core_scale.prototype.getRightValue.call(this, value);
          },
          handleTickRangeOptions: function() {
            var me = this;
            var opts = me.options;
            var tickOpts = opts.ticks;
            if (tickOpts.beginAtZero) {
              var minSign = helpers$1.sign(me.min);
              var maxSign = helpers$1.sign(me.max);
              if (minSign < 0 && maxSign < 0) {
                me.max = 0;
              } else if (minSign > 0 && maxSign > 0) {
                me.min = 0;
              }
            }
            var setMin = tickOpts.min !== void 0 || tickOpts.suggestedMin !== void 0;
            var setMax = tickOpts.max !== void 0 || tickOpts.suggestedMax !== void 0;
            if (tickOpts.min !== void 0) {
              me.min = tickOpts.min;
            } else if (tickOpts.suggestedMin !== void 0) {
              if (me.min === null) {
                me.min = tickOpts.suggestedMin;
              } else {
                me.min = Math.min(me.min, tickOpts.suggestedMin);
              }
            }
            if (tickOpts.max !== void 0) {
              me.max = tickOpts.max;
            } else if (tickOpts.suggestedMax !== void 0) {
              if (me.max === null) {
                me.max = tickOpts.suggestedMax;
              } else {
                me.max = Math.max(me.max, tickOpts.suggestedMax);
              }
            }
            if (setMin !== setMax) {
              if (me.min >= me.max) {
                if (setMin) {
                  me.max = me.min + 1;
                } else {
                  me.min = me.max - 1;
                }
              }
            }
            if (me.min === me.max) {
              me.max++;
              if (!tickOpts.beginAtZero) {
                me.min--;
              }
            }
          },
          getTickLimit: function() {
            var me = this;
            var tickOpts = me.options.ticks;
            var stepSize = tickOpts.stepSize;
            var maxTicksLimit = tickOpts.maxTicksLimit;
            var maxTicks;
            if (stepSize) {
              maxTicks = Math.ceil(me.max / stepSize) - Math.floor(me.min / stepSize) + 1;
            } else {
              maxTicks = me._computeTickLimit();
              maxTicksLimit = maxTicksLimit || 11;
            }
            if (maxTicksLimit) {
              maxTicks = Math.min(maxTicksLimit, maxTicks);
            }
            return maxTicks;
          },
          _computeTickLimit: function() {
            return Number.POSITIVE_INFINITY;
          },
          handleDirectionalChanges: noop2,
          buildTicks: function() {
            var me = this;
            var opts = me.options;
            var tickOpts = opts.ticks;
            var maxTicks = me.getTickLimit();
            maxTicks = Math.max(2, maxTicks);
            var numericGeneratorOptions = {
              maxTicks,
              min: tickOpts.min,
              max: tickOpts.max,
              precision: tickOpts.precision,
              stepSize: helpers$1.valueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)
            };
            var ticks = me.ticks = generateTicks(numericGeneratorOptions, me);
            me.handleDirectionalChanges();
            me.max = helpers$1.max(ticks);
            me.min = helpers$1.min(ticks);
            if (tickOpts.reverse) {
              ticks.reverse();
              me.start = me.max;
              me.end = me.min;
            } else {
              me.start = me.min;
              me.end = me.max;
            }
          },
          convertTicksToLabels: function() {
            var me = this;
            me.ticksAsNumbers = me.ticks.slice();
            me.zeroLineIndex = me.ticks.indexOf(0);
            core_scale.prototype.convertTicksToLabels.call(me);
          },
          _configure: function() {
            var me = this;
            var ticks = me.getTicks();
            var start2 = me.min;
            var end = me.max;
            var offset;
            core_scale.prototype._configure.call(me);
            if (me.options.offset && ticks.length) {
              offset = (end - start2) / Math.max(ticks.length - 1, 1) / 2;
              start2 -= offset;
              end += offset;
            }
            me._startValue = start2;
            me._endValue = end;
            me._valueRange = end - start2;
          }
        });
        var defaultConfig$1 = {
          position: "left",
          ticks: {
            callback: core_ticks.formatters.linear
          }
        };
        var DEFAULT_MIN = 0;
        var DEFAULT_MAX = 1;
        function getOrCreateStack(stacks, stacked, meta) {
          var key = [
            meta.type,
            stacked === void 0 && meta.stack === void 0 ? meta.index : "",
            meta.stack
          ].join(".");
          if (stacks[key] === void 0) {
            stacks[key] = {
              pos: [],
              neg: []
            };
          }
          return stacks[key];
        }
        function stackData(scale2, stacks, meta, data) {
          var opts = scale2.options;
          var stacked = opts.stacked;
          var stack = getOrCreateStack(stacks, stacked, meta);
          var pos = stack.pos;
          var neg = stack.neg;
          var ilen = data.length;
          var i, value;
          for (i = 0; i < ilen; ++i) {
            value = scale2._parseValue(data[i]);
            if (isNaN(value.min) || isNaN(value.max) || meta.data[i].hidden) {
              continue;
            }
            pos[i] = pos[i] || 0;
            neg[i] = neg[i] || 0;
            if (opts.relativePoints) {
              pos[i] = 100;
            } else if (value.min < 0 || value.max < 0) {
              neg[i] += value.min;
            } else {
              pos[i] += value.max;
            }
          }
        }
        function updateMinMax(scale2, meta, data) {
          var ilen = data.length;
          var i, value;
          for (i = 0; i < ilen; ++i) {
            value = scale2._parseValue(data[i]);
            if (isNaN(value.min) || isNaN(value.max) || meta.data[i].hidden) {
              continue;
            }
            scale2.min = Math.min(scale2.min, value.min);
            scale2.max = Math.max(scale2.max, value.max);
          }
        }
        var scale_linear = scale_linearbase.extend({
          determineDataLimits: function() {
            var me = this;
            var opts = me.options;
            var chart = me.chart;
            var datasets = chart.data.datasets;
            var metasets = me._getMatchingVisibleMetas();
            var hasStacks = opts.stacked;
            var stacks = {};
            var ilen = metasets.length;
            var i, meta, data, values;
            me.min = Number.POSITIVE_INFINITY;
            me.max = Number.NEGATIVE_INFINITY;
            if (hasStacks === void 0) {
              for (i = 0; !hasStacks && i < ilen; ++i) {
                meta = metasets[i];
                hasStacks = meta.stack !== void 0;
              }
            }
            for (i = 0; i < ilen; ++i) {
              meta = metasets[i];
              data = datasets[meta.index].data;
              if (hasStacks) {
                stackData(me, stacks, meta, data);
              } else {
                updateMinMax(me, meta, data);
              }
            }
            helpers$1.each(stacks, function(stackValues) {
              values = stackValues.pos.concat(stackValues.neg);
              me.min = Math.min(me.min, helpers$1.min(values));
              me.max = Math.max(me.max, helpers$1.max(values));
            });
            me.min = helpers$1.isFinite(me.min) && !isNaN(me.min) ? me.min : DEFAULT_MIN;
            me.max = helpers$1.isFinite(me.max) && !isNaN(me.max) ? me.max : DEFAULT_MAX;
            me.handleTickRangeOptions();
          },
          _computeTickLimit: function() {
            var me = this;
            var tickFont;
            if (me.isHorizontal()) {
              return Math.ceil(me.width / 40);
            }
            tickFont = helpers$1.options._parseFont(me.options.ticks);
            return Math.ceil(me.height / tickFont.lineHeight);
          },
          handleDirectionalChanges: function() {
            if (!this.isHorizontal()) {
              this.ticks.reverse();
            }
          },
          getLabelForIndex: function(index, datasetIndex) {
            return this._getScaleLabel(this.chart.data.datasets[datasetIndex].data[index]);
          },
          getPixelForValue: function(value) {
            var me = this;
            return me.getPixelForDecimal((+me.getRightValue(value) - me._startValue) / me._valueRange);
          },
          getValueForPixel: function(pixel) {
            return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
          },
          getPixelForTick: function(index) {
            var ticks = this.ticksAsNumbers;
            if (index < 0 || index > ticks.length - 1) {
              return null;
            }
            return this.getPixelForValue(ticks[index]);
          }
        });
        var _defaults$1 = defaultConfig$1;
        scale_linear._defaults = _defaults$1;
        var valueOrDefault$b = helpers$1.valueOrDefault;
        var log10 = helpers$1.math.log10;
        function generateTicks$1(generationOptions, dataRange) {
          var ticks = [];
          var tickVal = valueOrDefault$b(generationOptions.min, Math.pow(10, Math.floor(log10(dataRange.min))));
          var endExp = Math.floor(log10(dataRange.max));
          var endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
          var exp, significand;
          if (tickVal === 0) {
            exp = Math.floor(log10(dataRange.minNotZero));
            significand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));
            ticks.push(tickVal);
            tickVal = significand * Math.pow(10, exp);
          } else {
            exp = Math.floor(log10(tickVal));
            significand = Math.floor(tickVal / Math.pow(10, exp));
          }
          var precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
          do {
            ticks.push(tickVal);
            ++significand;
            if (significand === 10) {
              significand = 1;
              ++exp;
              precision = exp >= 0 ? 1 : precision;
            }
            tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;
          } while (exp < endExp || exp === endExp && significand < endSignificand);
          var lastTick = valueOrDefault$b(generationOptions.max, tickVal);
          ticks.push(lastTick);
          return ticks;
        }
        var defaultConfig$2 = {
          position: "left",
          ticks: {
            callback: core_ticks.formatters.logarithmic
          }
        };
        function nonNegativeOrDefault(value, defaultValue) {
          return helpers$1.isFinite(value) && value >= 0 ? value : defaultValue;
        }
        var scale_logarithmic = core_scale.extend({
          determineDataLimits: function() {
            var me = this;
            var opts = me.options;
            var chart = me.chart;
            var datasets = chart.data.datasets;
            var isHorizontal = me.isHorizontal();
            function IDMatches(meta2) {
              return isHorizontal ? meta2.xAxisID === me.id : meta2.yAxisID === me.id;
            }
            var datasetIndex, meta, value, data, i, ilen;
            me.min = Number.POSITIVE_INFINITY;
            me.max = Number.NEGATIVE_INFINITY;
            me.minNotZero = Number.POSITIVE_INFINITY;
            var hasStacks = opts.stacked;
            if (hasStacks === void 0) {
              for (datasetIndex = 0; datasetIndex < datasets.length; datasetIndex++) {
                meta = chart.getDatasetMeta(datasetIndex);
                if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) && meta.stack !== void 0) {
                  hasStacks = true;
                  break;
                }
              }
            }
            if (opts.stacked || hasStacks) {
              var valuesPerStack = {};
              for (datasetIndex = 0; datasetIndex < datasets.length; datasetIndex++) {
                meta = chart.getDatasetMeta(datasetIndex);
                var key = [
                  meta.type,
                  opts.stacked === void 0 && meta.stack === void 0 ? datasetIndex : "",
                  meta.stack
                ].join(".");
                if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
                  if (valuesPerStack[key] === void 0) {
                    valuesPerStack[key] = [];
                  }
                  data = datasets[datasetIndex].data;
                  for (i = 0, ilen = data.length; i < ilen; i++) {
                    var values = valuesPerStack[key];
                    value = me._parseValue(data[i]);
                    if (isNaN(value.min) || isNaN(value.max) || meta.data[i].hidden || value.min < 0 || value.max < 0) {
                      continue;
                    }
                    values[i] = values[i] || 0;
                    values[i] += value.max;
                  }
                }
              }
              helpers$1.each(valuesPerStack, function(valuesForType) {
                if (valuesForType.length > 0) {
                  var minVal = helpers$1.min(valuesForType);
                  var maxVal = helpers$1.max(valuesForType);
                  me.min = Math.min(me.min, minVal);
                  me.max = Math.max(me.max, maxVal);
                }
              });
            } else {
              for (datasetIndex = 0; datasetIndex < datasets.length; datasetIndex++) {
                meta = chart.getDatasetMeta(datasetIndex);
                if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
                  data = datasets[datasetIndex].data;
                  for (i = 0, ilen = data.length; i < ilen; i++) {
                    value = me._parseValue(data[i]);
                    if (isNaN(value.min) || isNaN(value.max) || meta.data[i].hidden || value.min < 0 || value.max < 0) {
                      continue;
                    }
                    me.min = Math.min(value.min, me.min);
                    me.max = Math.max(value.max, me.max);
                    if (value.min !== 0) {
                      me.minNotZero = Math.min(value.min, me.minNotZero);
                    }
                  }
                }
              }
            }
            me.min = helpers$1.isFinite(me.min) ? me.min : null;
            me.max = helpers$1.isFinite(me.max) ? me.max : null;
            me.minNotZero = helpers$1.isFinite(me.minNotZero) ? me.minNotZero : null;
            this.handleTickRangeOptions();
          },
          handleTickRangeOptions: function() {
            var me = this;
            var tickOpts = me.options.ticks;
            var DEFAULT_MIN2 = 1;
            var DEFAULT_MAX2 = 10;
            me.min = nonNegativeOrDefault(tickOpts.min, me.min);
            me.max = nonNegativeOrDefault(tickOpts.max, me.max);
            if (me.min === me.max) {
              if (me.min !== 0 && me.min !== null) {
                me.min = Math.pow(10, Math.floor(log10(me.min)) - 1);
                me.max = Math.pow(10, Math.floor(log10(me.max)) + 1);
              } else {
                me.min = DEFAULT_MIN2;
                me.max = DEFAULT_MAX2;
              }
            }
            if (me.min === null) {
              me.min = Math.pow(10, Math.floor(log10(me.max)) - 1);
            }
            if (me.max === null) {
              me.max = me.min !== 0 ? Math.pow(10, Math.floor(log10(me.min)) + 1) : DEFAULT_MAX2;
            }
            if (me.minNotZero === null) {
              if (me.min > 0) {
                me.minNotZero = me.min;
              } else if (me.max < 1) {
                me.minNotZero = Math.pow(10, Math.floor(log10(me.max)));
              } else {
                me.minNotZero = DEFAULT_MIN2;
              }
            }
          },
          buildTicks: function() {
            var me = this;
            var tickOpts = me.options.ticks;
            var reverse = !me.isHorizontal();
            var generationOptions = {
              min: nonNegativeOrDefault(tickOpts.min),
              max: nonNegativeOrDefault(tickOpts.max)
            };
            var ticks = me.ticks = generateTicks$1(generationOptions, me);
            me.max = helpers$1.max(ticks);
            me.min = helpers$1.min(ticks);
            if (tickOpts.reverse) {
              reverse = !reverse;
              me.start = me.max;
              me.end = me.min;
            } else {
              me.start = me.min;
              me.end = me.max;
            }
            if (reverse) {
              ticks.reverse();
            }
          },
          convertTicksToLabels: function() {
            this.tickValues = this.ticks.slice();
            core_scale.prototype.convertTicksToLabels.call(this);
          },
          getLabelForIndex: function(index, datasetIndex) {
            return this._getScaleLabel(this.chart.data.datasets[datasetIndex].data[index]);
          },
          getPixelForTick: function(index) {
            var ticks = this.tickValues;
            if (index < 0 || index > ticks.length - 1) {
              return null;
            }
            return this.getPixelForValue(ticks[index]);
          },
          _getFirstTickValue: function(value) {
            var exp = Math.floor(log10(value));
            var significand = Math.floor(value / Math.pow(10, exp));
            return significand * Math.pow(10, exp);
          },
          _configure: function() {
            var me = this;
            var start2 = me.min;
            var offset = 0;
            core_scale.prototype._configure.call(me);
            if (start2 === 0) {
              start2 = me._getFirstTickValue(me.minNotZero);
              offset = valueOrDefault$b(me.options.ticks.fontSize, core_defaults.global.defaultFontSize) / me._length;
            }
            me._startValue = log10(start2);
            me._valueOffset = offset;
            me._valueRange = (log10(me.max) - log10(start2)) / (1 - offset);
          },
          getPixelForValue: function(value) {
            var me = this;
            var decimal = 0;
            value = +me.getRightValue(value);
            if (value > me.min && value > 0) {
              decimal = (log10(value) - me._startValue) / me._valueRange + me._valueOffset;
            }
            return me.getPixelForDecimal(decimal);
          },
          getValueForPixel: function(pixel) {
            var me = this;
            var decimal = me.getDecimalForPixel(pixel);
            return decimal === 0 && me.min === 0 ? 0 : Math.pow(10, me._startValue + (decimal - me._valueOffset) * me._valueRange);
          }
        });
        var _defaults$2 = defaultConfig$2;
        scale_logarithmic._defaults = _defaults$2;
        var valueOrDefault$c = helpers$1.valueOrDefault;
        var valueAtIndexOrDefault$1 = helpers$1.valueAtIndexOrDefault;
        var resolve$4 = helpers$1.options.resolve;
        var defaultConfig$3 = {
          display: true,
          animate: true,
          position: "chartArea",
          angleLines: {
            display: true,
            color: "rgba(0,0,0,0.1)",
            lineWidth: 1,
            borderDash: [],
            borderDashOffset: 0
          },
          gridLines: {
            circular: false
          },
          ticks: {
            showLabelBackdrop: true,
            backdropColor: "rgba(255,255,255,0.75)",
            backdropPaddingY: 2,
            backdropPaddingX: 2,
            callback: core_ticks.formatters.linear
          },
          pointLabels: {
            display: true,
            fontSize: 10,
            callback: function(label) {
              return label;
            }
          }
        };
        function getTickBackdropHeight(opts) {
          var tickOpts = opts.ticks;
          if (tickOpts.display && opts.display) {
            return valueOrDefault$c(tickOpts.fontSize, core_defaults.global.defaultFontSize) + tickOpts.backdropPaddingY * 2;
          }
          return 0;
        }
        function measureLabelSize(ctx, lineHeight, label) {
          if (helpers$1.isArray(label)) {
            return {
              w: helpers$1.longestText(ctx, ctx.font, label),
              h: label.length * lineHeight
            };
          }
          return {
            w: ctx.measureText(label).width,
            h: lineHeight
          };
        }
        function determineLimits(angle, pos, size, min, max) {
          if (angle === min || angle === max) {
            return {
              start: pos - size / 2,
              end: pos + size / 2
            };
          } else if (angle < min || angle > max) {
            return {
              start: pos - size,
              end: pos
            };
          }
          return {
            start: pos,
            end: pos + size
          };
        }
        function fitWithPointLabels(scale2) {
          var plFont = helpers$1.options._parseFont(scale2.options.pointLabels);
          var furthestLimits = {
            l: 0,
            r: scale2.width,
            t: 0,
            b: scale2.height - scale2.paddingTop
          };
          var furthestAngles = {};
          var i, textSize, pointPosition;
          scale2.ctx.font = plFont.string;
          scale2._pointLabelSizes = [];
          var valueCount = scale2.chart.data.labels.length;
          for (i = 0; i < valueCount; i++) {
            pointPosition = scale2.getPointPosition(i, scale2.drawingArea + 5);
            textSize = measureLabelSize(scale2.ctx, plFont.lineHeight, scale2.pointLabels[i]);
            scale2._pointLabelSizes[i] = textSize;
            var angleRadians = scale2.getIndexAngle(i);
            var angle = helpers$1.toDegrees(angleRadians) % 360;
            var hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
            var vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
            if (hLimits.start < furthestLimits.l) {
              furthestLimits.l = hLimits.start;
              furthestAngles.l = angleRadians;
            }
            if (hLimits.end > furthestLimits.r) {
              furthestLimits.r = hLimits.end;
              furthestAngles.r = angleRadians;
            }
            if (vLimits.start < furthestLimits.t) {
              furthestLimits.t = vLimits.start;
              furthestAngles.t = angleRadians;
            }
            if (vLimits.end > furthestLimits.b) {
              furthestLimits.b = vLimits.end;
              furthestAngles.b = angleRadians;
            }
          }
          scale2.setReductions(scale2.drawingArea, furthestLimits, furthestAngles);
        }
        function getTextAlignForAngle(angle) {
          if (angle === 0 || angle === 180) {
            return "center";
          } else if (angle < 180) {
            return "left";
          }
          return "right";
        }
        function fillText(ctx, text2, position, lineHeight) {
          var y = position.y + lineHeight / 2;
          var i, ilen;
          if (helpers$1.isArray(text2)) {
            for (i = 0, ilen = text2.length; i < ilen; ++i) {
              ctx.fillText(text2[i], position.x, y);
              y += lineHeight;
            }
          } else {
            ctx.fillText(text2, position.x, y);
          }
        }
        function adjustPointPositionForLabelHeight(angle, textSize, position) {
          if (angle === 90 || angle === 270) {
            position.y -= textSize.h / 2;
          } else if (angle > 270 || angle < 90) {
            position.y -= textSize.h;
          }
        }
        function drawPointLabels(scale2) {
          var ctx = scale2.ctx;
          var opts = scale2.options;
          var pointLabelOpts = opts.pointLabels;
          var tickBackdropHeight = getTickBackdropHeight(opts);
          var outerDistance = scale2.getDistanceFromCenterForValue(opts.ticks.reverse ? scale2.min : scale2.max);
          var plFont = helpers$1.options._parseFont(pointLabelOpts);
          ctx.save();
          ctx.font = plFont.string;
          ctx.textBaseline = "middle";
          for (var i = scale2.chart.data.labels.length - 1; i >= 0; i--) {
            var extra = i === 0 ? tickBackdropHeight / 2 : 0;
            var pointLabelPosition = scale2.getPointPosition(i, outerDistance + extra + 5);
            var pointLabelFontColor = valueAtIndexOrDefault$1(pointLabelOpts.fontColor, i, core_defaults.global.defaultFontColor);
            ctx.fillStyle = pointLabelFontColor;
            var angleRadians = scale2.getIndexAngle(i);
            var angle = helpers$1.toDegrees(angleRadians);
            ctx.textAlign = getTextAlignForAngle(angle);
            adjustPointPositionForLabelHeight(angle, scale2._pointLabelSizes[i], pointLabelPosition);
            fillText(ctx, scale2.pointLabels[i], pointLabelPosition, plFont.lineHeight);
          }
          ctx.restore();
        }
        function drawRadiusLine(scale2, gridLineOpts, radius, index) {
          var ctx = scale2.ctx;
          var circular = gridLineOpts.circular;
          var valueCount = scale2.chart.data.labels.length;
          var lineColor = valueAtIndexOrDefault$1(gridLineOpts.color, index - 1);
          var lineWidth = valueAtIndexOrDefault$1(gridLineOpts.lineWidth, index - 1);
          var pointPosition;
          if (!circular && !valueCount || !lineColor || !lineWidth) {
            return;
          }
          ctx.save();
          ctx.strokeStyle = lineColor;
          ctx.lineWidth = lineWidth;
          if (ctx.setLineDash) {
            ctx.setLineDash(gridLineOpts.borderDash || []);
            ctx.lineDashOffset = gridLineOpts.borderDashOffset || 0;
          }
          ctx.beginPath();
          if (circular) {
            ctx.arc(scale2.xCenter, scale2.yCenter, radius, 0, Math.PI * 2);
          } else {
            pointPosition = scale2.getPointPosition(0, radius);
            ctx.moveTo(pointPosition.x, pointPosition.y);
            for (var i = 1; i < valueCount; i++) {
              pointPosition = scale2.getPointPosition(i, radius);
              ctx.lineTo(pointPosition.x, pointPosition.y);
            }
          }
          ctx.closePath();
          ctx.stroke();
          ctx.restore();
        }
        function numberOrZero(param) {
          return helpers$1.isNumber(param) ? param : 0;
        }
        var scale_radialLinear = scale_linearbase.extend({
          setDimensions: function() {
            var me = this;
            me.width = me.maxWidth;
            me.height = me.maxHeight;
            me.paddingTop = getTickBackdropHeight(me.options) / 2;
            me.xCenter = Math.floor(me.width / 2);
            me.yCenter = Math.floor((me.height - me.paddingTop) / 2);
            me.drawingArea = Math.min(me.height - me.paddingTop, me.width) / 2;
          },
          determineDataLimits: function() {
            var me = this;
            var chart = me.chart;
            var min = Number.POSITIVE_INFINITY;
            var max = Number.NEGATIVE_INFINITY;
            helpers$1.each(chart.data.datasets, function(dataset, datasetIndex) {
              if (chart.isDatasetVisible(datasetIndex)) {
                var meta = chart.getDatasetMeta(datasetIndex);
                helpers$1.each(dataset.data, function(rawValue, index) {
                  var value = +me.getRightValue(rawValue);
                  if (isNaN(value) || meta.data[index].hidden) {
                    return;
                  }
                  min = Math.min(value, min);
                  max = Math.max(value, max);
                });
              }
            });
            me.min = min === Number.POSITIVE_INFINITY ? 0 : min;
            me.max = max === Number.NEGATIVE_INFINITY ? 0 : max;
            me.handleTickRangeOptions();
          },
          _computeTickLimit: function() {
            return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
          },
          convertTicksToLabels: function() {
            var me = this;
            scale_linearbase.prototype.convertTicksToLabels.call(me);
            me.pointLabels = me.chart.data.labels.map(function() {
              var label = helpers$1.callback(me.options.pointLabels.callback, arguments, me);
              return label || label === 0 ? label : "";
            });
          },
          getLabelForIndex: function(index, datasetIndex) {
            return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
          },
          fit: function() {
            var me = this;
            var opts = me.options;
            if (opts.display && opts.pointLabels.display) {
              fitWithPointLabels(me);
            } else {
              me.setCenterPoint(0, 0, 0, 0);
            }
          },
          setReductions: function(largestPossibleRadius, furthestLimits, furthestAngles) {
            var me = this;
            var radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);
            var radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);
            var radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);
            var radiusReductionBottom = -Math.max(furthestLimits.b - (me.height - me.paddingTop), 0) / Math.cos(furthestAngles.b);
            radiusReductionLeft = numberOrZero(radiusReductionLeft);
            radiusReductionRight = numberOrZero(radiusReductionRight);
            radiusReductionTop = numberOrZero(radiusReductionTop);
            radiusReductionBottom = numberOrZero(radiusReductionBottom);
            me.drawingArea = Math.min(Math.floor(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2), Math.floor(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));
            me.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);
          },
          setCenterPoint: function(leftMovement, rightMovement, topMovement, bottomMovement) {
            var me = this;
            var maxRight = me.width - rightMovement - me.drawingArea;
            var maxLeft = leftMovement + me.drawingArea;
            var maxTop = topMovement + me.drawingArea;
            var maxBottom = me.height - me.paddingTop - bottomMovement - me.drawingArea;
            me.xCenter = Math.floor((maxLeft + maxRight) / 2 + me.left);
            me.yCenter = Math.floor((maxTop + maxBottom) / 2 + me.top + me.paddingTop);
          },
          getIndexAngle: function(index) {
            var chart = this.chart;
            var angleMultiplier = 360 / chart.data.labels.length;
            var options2 = chart.options || {};
            var startAngle = options2.startAngle || 0;
            var angle = (index * angleMultiplier + startAngle) % 360;
            return (angle < 0 ? angle + 360 : angle) * Math.PI * 2 / 360;
          },
          getDistanceFromCenterForValue: function(value) {
            var me = this;
            if (helpers$1.isNullOrUndef(value)) {
              return NaN;
            }
            var scalingFactor = me.drawingArea / (me.max - me.min);
            if (me.options.ticks.reverse) {
              return (me.max - value) * scalingFactor;
            }
            return (value - me.min) * scalingFactor;
          },
          getPointPosition: function(index, distanceFromCenter) {
            var me = this;
            var thisAngle = me.getIndexAngle(index) - Math.PI / 2;
            return {
              x: Math.cos(thisAngle) * distanceFromCenter + me.xCenter,
              y: Math.sin(thisAngle) * distanceFromCenter + me.yCenter
            };
          },
          getPointPositionForValue: function(index, value) {
            return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
          },
          getBasePosition: function(index) {
            var me = this;
            var min = me.min;
            var max = me.max;
            return me.getPointPositionForValue(index || 0, me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0);
          },
          _drawGrid: function() {
            var me = this;
            var ctx = me.ctx;
            var opts = me.options;
            var gridLineOpts = opts.gridLines;
            var angleLineOpts = opts.angleLines;
            var lineWidth = valueOrDefault$c(angleLineOpts.lineWidth, gridLineOpts.lineWidth);
            var lineColor = valueOrDefault$c(angleLineOpts.color, gridLineOpts.color);
            var i, offset, position;
            if (opts.pointLabels.display) {
              drawPointLabels(me);
            }
            if (gridLineOpts.display) {
              helpers$1.each(me.ticks, function(label, index) {
                if (index !== 0) {
                  offset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);
                  drawRadiusLine(me, gridLineOpts, offset, index);
                }
              });
            }
            if (angleLineOpts.display && lineWidth && lineColor) {
              ctx.save();
              ctx.lineWidth = lineWidth;
              ctx.strokeStyle = lineColor;
              if (ctx.setLineDash) {
                ctx.setLineDash(resolve$4([angleLineOpts.borderDash, gridLineOpts.borderDash, []]));
                ctx.lineDashOffset = resolve$4([angleLineOpts.borderDashOffset, gridLineOpts.borderDashOffset, 0]);
              }
              for (i = me.chart.data.labels.length - 1; i >= 0; i--) {
                offset = me.getDistanceFromCenterForValue(opts.ticks.reverse ? me.min : me.max);
                position = me.getPointPosition(i, offset);
                ctx.beginPath();
                ctx.moveTo(me.xCenter, me.yCenter);
                ctx.lineTo(position.x, position.y);
                ctx.stroke();
              }
              ctx.restore();
            }
          },
          _drawLabels: function() {
            var me = this;
            var ctx = me.ctx;
            var opts = me.options;
            var tickOpts = opts.ticks;
            if (!tickOpts.display) {
              return;
            }
            var startAngle = me.getIndexAngle(0);
            var tickFont = helpers$1.options._parseFont(tickOpts);
            var tickFontColor = valueOrDefault$c(tickOpts.fontColor, core_defaults.global.defaultFontColor);
            var offset, width;
            ctx.save();
            ctx.font = tickFont.string;
            ctx.translate(me.xCenter, me.yCenter);
            ctx.rotate(startAngle);
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            helpers$1.each(me.ticks, function(label, index) {
              if (index === 0 && !tickOpts.reverse) {
                return;
              }
              offset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);
              if (tickOpts.showLabelBackdrop) {
                width = ctx.measureText(label).width;
                ctx.fillStyle = tickOpts.backdropColor;
                ctx.fillRect(-width / 2 - tickOpts.backdropPaddingX, -offset - tickFont.size / 2 - tickOpts.backdropPaddingY, width + tickOpts.backdropPaddingX * 2, tickFont.size + tickOpts.backdropPaddingY * 2);
              }
              ctx.fillStyle = tickFontColor;
              ctx.fillText(label, 0, -offset);
            });
            ctx.restore();
          },
          _drawTitle: helpers$1.noop
        });
        var _defaults$3 = defaultConfig$3;
        scale_radialLinear._defaults = _defaults$3;
        var deprecated$1 = helpers$1._deprecated;
        var resolve$5 = helpers$1.options.resolve;
        var valueOrDefault$d = helpers$1.valueOrDefault;
        var MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;
        var MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
        var INTERVALS = {
          millisecond: {
            common: true,
            size: 1,
            steps: 1e3
          },
          second: {
            common: true,
            size: 1e3,
            steps: 60
          },
          minute: {
            common: true,
            size: 6e4,
            steps: 60
          },
          hour: {
            common: true,
            size: 36e5,
            steps: 24
          },
          day: {
            common: true,
            size: 864e5,
            steps: 30
          },
          week: {
            common: false,
            size: 6048e5,
            steps: 4
          },
          month: {
            common: true,
            size: 2628e6,
            steps: 12
          },
          quarter: {
            common: false,
            size: 7884e6,
            steps: 4
          },
          year: {
            common: true,
            size: 3154e7
          }
        };
        var UNITS = Object.keys(INTERVALS);
        function sorter(a, b) {
          return a - b;
        }
        function arrayUnique(items) {
          var hash = {};
          var out = [];
          var i, ilen, item2;
          for (i = 0, ilen = items.length; i < ilen; ++i) {
            item2 = items[i];
            if (!hash[item2]) {
              hash[item2] = true;
              out.push(item2);
            }
          }
          return out;
        }
        function getMin(options2) {
          return helpers$1.valueOrDefault(options2.time.min, options2.ticks.min);
        }
        function getMax(options2) {
          return helpers$1.valueOrDefault(options2.time.max, options2.ticks.max);
        }
        function buildLookupTable(timestamps, min, max, distribution) {
          if (distribution === "linear" || !timestamps.length) {
            return [
              { time: min, pos: 0 },
              { time: max, pos: 1 }
            ];
          }
          var table = [];
          var items = [min];
          var i, ilen, prev, curr, next;
          for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
            curr = timestamps[i];
            if (curr > min && curr < max) {
              items.push(curr);
            }
          }
          items.push(max);
          for (i = 0, ilen = items.length; i < ilen; ++i) {
            next = items[i + 1];
            prev = items[i - 1];
            curr = items[i];
            if (prev === void 0 || next === void 0 || Math.round((next + prev) / 2) !== curr) {
              table.push({ time: curr, pos: i / (ilen - 1) });
            }
          }
          return table;
        }
        function lookup(table, key, value) {
          var lo = 0;
          var hi = table.length - 1;
          var mid, i0, i1;
          while (lo >= 0 && lo <= hi) {
            mid = lo + hi >> 1;
            i0 = table[mid - 1] || null;
            i1 = table[mid];
            if (!i0) {
              return { lo: null, hi: i1 };
            } else if (i1[key] < value) {
              lo = mid + 1;
            } else if (i0[key] > value) {
              hi = mid - 1;
            } else {
              return { lo: i0, hi: i1 };
            }
          }
          return { lo: i1, hi: null };
        }
        function interpolate$1(table, skey, sval, tkey) {
          var range = lookup(table, skey, sval);
          var prev = !range.lo ? table[0] : !range.hi ? table[table.length - 2] : range.lo;
          var next = !range.lo ? table[1] : !range.hi ? table[table.length - 1] : range.hi;
          var span = next[skey] - prev[skey];
          var ratio = span ? (sval - prev[skey]) / span : 0;
          var offset = (next[tkey] - prev[tkey]) * ratio;
          return prev[tkey] + offset;
        }
        function toTimestamp(scale2, input) {
          var adapter = scale2._adapter;
          var options2 = scale2.options.time;
          var parser = options2.parser;
          var format = parser || options2.format;
          var value = input;
          if (typeof parser === "function") {
            value = parser(value);
          }
          if (!helpers$1.isFinite(value)) {
            value = typeof format === "string" ? adapter.parse(value, format) : adapter.parse(value);
          }
          if (value !== null) {
            return +value;
          }
          if (!parser && typeof format === "function") {
            value = format(input);
            if (!helpers$1.isFinite(value)) {
              value = adapter.parse(value);
            }
          }
          return value;
        }
        function parse(scale2, input) {
          if (helpers$1.isNullOrUndef(input)) {
            return null;
          }
          var options2 = scale2.options.time;
          var value = toTimestamp(scale2, scale2.getRightValue(input));
          if (value === null) {
            return value;
          }
          if (options2.round) {
            value = +scale2._adapter.startOf(value, options2.round);
          }
          return value;
        }
        function determineUnitForAutoTicks(minUnit, min, max, capacity) {
          var ilen = UNITS.length;
          var i, interval, factor;
          for (i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
            interval = INTERVALS[UNITS[i]];
            factor = interval.steps ? interval.steps : MAX_INTEGER;
            if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
              return UNITS[i];
            }
          }
          return UNITS[ilen - 1];
        }
        function determineUnitForFormatting(scale2, numTicks, minUnit, min, max) {
          var i, unit;
          for (i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
            unit = UNITS[i];
            if (INTERVALS[unit].common && scale2._adapter.diff(max, min, unit) >= numTicks - 1) {
              return unit;
            }
          }
          return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
        }
        function determineMajorUnit(unit) {
          for (var i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
            if (INTERVALS[UNITS[i]].common) {
              return UNITS[i];
            }
          }
        }
        function generate(scale2, min, max, capacity) {
          var adapter = scale2._adapter;
          var options2 = scale2.options;
          var timeOpts = options2.time;
          var minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, capacity);
          var stepSize = resolve$5([timeOpts.stepSize, timeOpts.unitStepSize, 1]);
          var weekday = minor === "week" ? timeOpts.isoWeekday : false;
          var first = min;
          var ticks = [];
          var time;
          if (weekday) {
            first = +adapter.startOf(first, "isoWeek", weekday);
          }
          first = +adapter.startOf(first, weekday ? "day" : minor);
          if (adapter.diff(max, min, minor) > 1e5 * stepSize) {
            throw min + " and " + max + " are too far apart with stepSize of " + stepSize + " " + minor;
          }
          for (time = first; time < max; time = +adapter.add(time, stepSize, minor)) {
            ticks.push(time);
          }
          if (time === max || options2.bounds === "ticks") {
            ticks.push(time);
          }
          return ticks;
        }
        function computeOffsets(table, ticks, min, max, options2) {
          var start2 = 0;
          var end = 0;
          var first, last;
          if (options2.offset && ticks.length) {
            first = interpolate$1(table, "time", ticks[0], "pos");
            if (ticks.length === 1) {
              start2 = 1 - first;
            } else {
              start2 = (interpolate$1(table, "time", ticks[1], "pos") - first) / 2;
            }
            last = interpolate$1(table, "time", ticks[ticks.length - 1], "pos");
            if (ticks.length === 1) {
              end = last;
            } else {
              end = (last - interpolate$1(table, "time", ticks[ticks.length - 2], "pos")) / 2;
            }
          }
          return { start: start2, end, factor: 1 / (start2 + 1 + end) };
        }
        function setMajorTicks(scale2, ticks, map, majorUnit) {
          var adapter = scale2._adapter;
          var first = +adapter.startOf(ticks[0].value, majorUnit);
          var last = ticks[ticks.length - 1].value;
          var major, index;
          for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
            index = map[major];
            if (index >= 0) {
              ticks[index].major = true;
            }
          }
          return ticks;
        }
        function ticksFromTimestamps(scale2, values, majorUnit) {
          var ticks = [];
          var map = {};
          var ilen = values.length;
          var i, value;
          for (i = 0; i < ilen; ++i) {
            value = values[i];
            map[value] = i;
            ticks.push({
              value,
              major: false
            });
          }
          return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale2, ticks, map, majorUnit);
        }
        var defaultConfig$4 = {
          position: "bottom",
          distribution: "linear",
          bounds: "data",
          adapters: {},
          time: {
            parser: false,
            unit: false,
            round: false,
            displayFormat: false,
            isoWeekday: false,
            minUnit: "millisecond",
            displayFormats: {}
          },
          ticks: {
            autoSkip: false,
            source: "auto",
            major: {
              enabled: false
            }
          }
        };
        var scale_time = core_scale.extend({
          initialize: function() {
            this.mergeTicksOptions();
            core_scale.prototype.initialize.call(this);
          },
          update: function() {
            var me = this;
            var options2 = me.options;
            var time = options2.time || (options2.time = {});
            var adapter = me._adapter = new core_adapters._date(options2.adapters.date);
            deprecated$1("time scale", time.format, "time.format", "time.parser");
            deprecated$1("time scale", time.min, "time.min", "ticks.min");
            deprecated$1("time scale", time.max, "time.max", "ticks.max");
            helpers$1.mergeIf(time.displayFormats, adapter.formats());
            return core_scale.prototype.update.apply(me, arguments);
          },
          getRightValue: function(rawValue) {
            if (rawValue && rawValue.t !== void 0) {
              rawValue = rawValue.t;
            }
            return core_scale.prototype.getRightValue.call(this, rawValue);
          },
          determineDataLimits: function() {
            var me = this;
            var chart = me.chart;
            var adapter = me._adapter;
            var options2 = me.options;
            var unit = options2.time.unit || "day";
            var min = MAX_INTEGER;
            var max = MIN_INTEGER;
            var timestamps = [];
            var datasets = [];
            var labels = [];
            var i, j, ilen, jlen, data, timestamp, labelsAdded;
            var dataLabels = me._getLabels();
            for (i = 0, ilen = dataLabels.length; i < ilen; ++i) {
              labels.push(parse(me, dataLabels[i]));
            }
            for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
              if (chart.isDatasetVisible(i)) {
                data = chart.data.datasets[i].data;
                if (helpers$1.isObject(data[0])) {
                  datasets[i] = [];
                  for (j = 0, jlen = data.length; j < jlen; ++j) {
                    timestamp = parse(me, data[j]);
                    timestamps.push(timestamp);
                    datasets[i][j] = timestamp;
                  }
                } else {
                  datasets[i] = labels.slice(0);
                  if (!labelsAdded) {
                    timestamps = timestamps.concat(labels);
                    labelsAdded = true;
                  }
                }
              } else {
                datasets[i] = [];
              }
            }
            if (labels.length) {
              min = Math.min(min, labels[0]);
              max = Math.max(max, labels[labels.length - 1]);
            }
            if (timestamps.length) {
              timestamps = ilen > 1 ? arrayUnique(timestamps).sort(sorter) : timestamps.sort(sorter);
              min = Math.min(min, timestamps[0]);
              max = Math.max(max, timestamps[timestamps.length - 1]);
            }
            min = parse(me, getMin(options2)) || min;
            max = parse(me, getMax(options2)) || max;
            min = min === MAX_INTEGER ? +adapter.startOf(Date.now(), unit) : min;
            max = max === MIN_INTEGER ? +adapter.endOf(Date.now(), unit) + 1 : max;
            me.min = Math.min(min, max);
            me.max = Math.max(min + 1, max);
            me._table = [];
            me._timestamps = {
              data: timestamps,
              datasets,
              labels
            };
          },
          buildTicks: function() {
            var me = this;
            var min = me.min;
            var max = me.max;
            var options2 = me.options;
            var tickOpts = options2.ticks;
            var timeOpts = options2.time;
            var timestamps = me._timestamps;
            var ticks = [];
            var capacity = me.getLabelCapacity(min);
            var source = tickOpts.source;
            var distribution = options2.distribution;
            var i, ilen, timestamp;
            if (source === "data" || source === "auto" && distribution === "series") {
              timestamps = timestamps.data;
            } else if (source === "labels") {
              timestamps = timestamps.labels;
            } else {
              timestamps = generate(me, min, max, capacity);
            }
            if (options2.bounds === "ticks" && timestamps.length) {
              min = timestamps[0];
              max = timestamps[timestamps.length - 1];
            }
            min = parse(me, getMin(options2)) || min;
            max = parse(me, getMax(options2)) || max;
            for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
              timestamp = timestamps[i];
              if (timestamp >= min && timestamp <= max) {
                ticks.push(timestamp);
              }
            }
            me.min = min;
            me.max = max;
            me._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, me.min, me.max, capacity) : determineUnitForFormatting(me, ticks.length, timeOpts.minUnit, me.min, me.max));
            me._majorUnit = !tickOpts.major.enabled || me._unit === "year" ? void 0 : determineMajorUnit(me._unit);
            me._table = buildLookupTable(me._timestamps.data, min, max, distribution);
            me._offsets = computeOffsets(me._table, ticks, min, max, options2);
            if (tickOpts.reverse) {
              ticks.reverse();
            }
            return ticksFromTimestamps(me, ticks, me._majorUnit);
          },
          getLabelForIndex: function(index, datasetIndex) {
            var me = this;
            var adapter = me._adapter;
            var data = me.chart.data;
            var timeOpts = me.options.time;
            var label = data.labels && index < data.labels.length ? data.labels[index] : "";
            var value = data.datasets[datasetIndex].data[index];
            if (helpers$1.isObject(value)) {
              label = me.getRightValue(value);
            }
            if (timeOpts.tooltipFormat) {
              return adapter.format(toTimestamp(me, label), timeOpts.tooltipFormat);
            }
            if (typeof label === "string") {
              return label;
            }
            return adapter.format(toTimestamp(me, label), timeOpts.displayFormats.datetime);
          },
          tickFormatFunction: function(time, index, ticks, format) {
            var me = this;
            var adapter = me._adapter;
            var options2 = me.options;
            var formats = options2.time.displayFormats;
            var minorFormat = formats[me._unit];
            var majorUnit = me._majorUnit;
            var majorFormat = formats[majorUnit];
            var tick2 = ticks[index];
            var tickOpts = options2.ticks;
            var major = majorUnit && majorFormat && tick2 && tick2.major;
            var label = adapter.format(time, format ? format : major ? majorFormat : minorFormat);
            var nestedTickOpts = major ? tickOpts.major : tickOpts.minor;
            var formatter = resolve$5([
              nestedTickOpts.callback,
              nestedTickOpts.userCallback,
              tickOpts.callback,
              tickOpts.userCallback
            ]);
            return formatter ? formatter(label, index, ticks) : label;
          },
          convertTicksToLabels: function(ticks) {
            var labels = [];
            var i, ilen;
            for (i = 0, ilen = ticks.length; i < ilen; ++i) {
              labels.push(this.tickFormatFunction(ticks[i].value, i, ticks));
            }
            return labels;
          },
          getPixelForOffset: function(time) {
            var me = this;
            var offsets = me._offsets;
            var pos = interpolate$1(me._table, "time", time, "pos");
            return me.getPixelForDecimal((offsets.start + pos) * offsets.factor);
          },
          getPixelForValue: function(value, index, datasetIndex) {
            var me = this;
            var time = null;
            if (index !== void 0 && datasetIndex !== void 0) {
              time = me._timestamps.datasets[datasetIndex][index];
            }
            if (time === null) {
              time = parse(me, value);
            }
            if (time !== null) {
              return me.getPixelForOffset(time);
            }
          },
          getPixelForTick: function(index) {
            var ticks = this.getTicks();
            return index >= 0 && index < ticks.length ? this.getPixelForOffset(ticks[index].value) : null;
          },
          getValueForPixel: function(pixel) {
            var me = this;
            var offsets = me._offsets;
            var pos = me.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
            var time = interpolate$1(me._table, "pos", pos, "time");
            return me._adapter._create(time);
          },
          _getLabelSize: function(label) {
            var me = this;
            var ticksOpts = me.options.ticks;
            var tickLabelWidth = me.ctx.measureText(label).width;
            var angle = helpers$1.toRadians(me.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
            var cosRotation = Math.cos(angle);
            var sinRotation = Math.sin(angle);
            var tickFontSize = valueOrDefault$d(ticksOpts.fontSize, core_defaults.global.defaultFontSize);
            return {
              w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
              h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
            };
          },
          getLabelWidth: function(label) {
            return this._getLabelSize(label).w;
          },
          getLabelCapacity: function(exampleTime) {
            var me = this;
            var timeOpts = me.options.time;
            var displayFormats = timeOpts.displayFormats;
            var format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
            var exampleLabel = me.tickFormatFunction(exampleTime, 0, ticksFromTimestamps(me, [exampleTime], me._majorUnit), format);
            var size = me._getLabelSize(exampleLabel);
            var capacity = Math.floor(me.isHorizontal() ? me.width / size.w : me.height / size.h);
            if (me.options.offset) {
              capacity--;
            }
            return capacity > 0 ? capacity : 1;
          }
        });
        var _defaults$4 = defaultConfig$4;
        scale_time._defaults = _defaults$4;
        var scales = {
          category: scale_category,
          linear: scale_linear,
          logarithmic: scale_logarithmic,
          radialLinear: scale_radialLinear,
          time: scale_time
        };
        var FORMATS = {
          datetime: "MMM D, YYYY, h:mm:ss a",
          millisecond: "h:mm:ss.SSS a",
          second: "h:mm:ss a",
          minute: "h:mm a",
          hour: "hA",
          day: "MMM D",
          week: "ll",
          month: "MMM YYYY",
          quarter: "[Q]Q - YYYY",
          year: "YYYY"
        };
        core_adapters._date.override(typeof moment === "function" ? {
          _id: "moment",
          formats: function() {
            return FORMATS;
          },
          parse: function(value, format) {
            if (typeof value === "string" && typeof format === "string") {
              value = moment(value, format);
            } else if (!(value instanceof moment)) {
              value = moment(value);
            }
            return value.isValid() ? value.valueOf() : null;
          },
          format: function(time, format) {
            return moment(time).format(format);
          },
          add: function(time, amount, unit) {
            return moment(time).add(amount, unit).valueOf();
          },
          diff: function(max, min, unit) {
            return moment(max).diff(moment(min), unit);
          },
          startOf: function(time, unit, weekday) {
            time = moment(time);
            if (unit === "isoWeek") {
              return time.isoWeekday(weekday).valueOf();
            }
            return time.startOf(unit).valueOf();
          },
          endOf: function(time, unit) {
            return moment(time).endOf(unit).valueOf();
          },
          _create: function(time) {
            return moment(time);
          }
        } : {});
        core_defaults._set("global", {
          plugins: {
            filler: {
              propagate: true
            }
          }
        });
        var mappers = {
          dataset: function(source) {
            var index = source.fill;
            var chart = source.chart;
            var meta = chart.getDatasetMeta(index);
            var visible = meta && chart.isDatasetVisible(index);
            var points = visible && meta.dataset._children || [];
            var length = points.length || 0;
            return !length ? null : function(point, i) {
              return i < length && points[i]._view || null;
            };
          },
          boundary: function(source) {
            var boundary = source.boundary;
            var x = boundary ? boundary.x : null;
            var y = boundary ? boundary.y : null;
            if (helpers$1.isArray(boundary)) {
              return function(point, i) {
                return boundary[i];
              };
            }
            return function(point) {
              return {
                x: x === null ? point.x : x,
                y: y === null ? point.y : y
              };
            };
          }
        };
        function decodeFill(el, index, count) {
          var model = el._model || {};
          var fill = model.fill;
          var target;
          if (fill === void 0) {
            fill = !!model.backgroundColor;
          }
          if (fill === false || fill === null) {
            return false;
          }
          if (fill === true) {
            return "origin";
          }
          target = parseFloat(fill, 10);
          if (isFinite(target) && Math.floor(target) === target) {
            if (fill[0] === "-" || fill[0] === "+") {
              target = index + target;
            }
            if (target === index || target < 0 || target >= count) {
              return false;
            }
            return target;
          }
          switch (fill) {
            case "bottom":
              return "start";
            case "top":
              return "end";
            case "zero":
              return "origin";
            case "origin":
            case "start":
            case "end":
              return fill;
            default:
              return false;
          }
        }
        function computeLinearBoundary(source) {
          var model = source.el._model || {};
          var scale2 = source.el._scale || {};
          var fill = source.fill;
          var target = null;
          var horizontal;
          if (isFinite(fill)) {
            return null;
          }
          if (fill === "start") {
            target = model.scaleBottom === void 0 ? scale2.bottom : model.scaleBottom;
          } else if (fill === "end") {
            target = model.scaleTop === void 0 ? scale2.top : model.scaleTop;
          } else if (model.scaleZero !== void 0) {
            target = model.scaleZero;
          } else if (scale2.getBasePixel) {
            target = scale2.getBasePixel();
          }
          if (target !== void 0 && target !== null) {
            if (target.x !== void 0 && target.y !== void 0) {
              return target;
            }
            if (helpers$1.isFinite(target)) {
              horizontal = scale2.isHorizontal();
              return {
                x: horizontal ? target : null,
                y: horizontal ? null : target
              };
            }
          }
          return null;
        }
        function computeCircularBoundary(source) {
          var scale2 = source.el._scale;
          var options2 = scale2.options;
          var length = scale2.chart.data.labels.length;
          var fill = source.fill;
          var target = [];
          var start2, end, center, i, point;
          if (!length) {
            return null;
          }
          start2 = options2.ticks.reverse ? scale2.max : scale2.min;
          end = options2.ticks.reverse ? scale2.min : scale2.max;
          center = scale2.getPointPositionForValue(0, start2);
          for (i = 0; i < length; ++i) {
            point = fill === "start" || fill === "end" ? scale2.getPointPositionForValue(i, fill === "start" ? start2 : end) : scale2.getBasePosition(i);
            if (options2.gridLines.circular) {
              point.cx = center.x;
              point.cy = center.y;
              point.angle = scale2.getIndexAngle(i) - Math.PI / 2;
            }
            target.push(point);
          }
          return target;
        }
        function computeBoundary(source) {
          var scale2 = source.el._scale || {};
          if (scale2.getPointPositionForValue) {
            return computeCircularBoundary(source);
          }
          return computeLinearBoundary(source);
        }
        function resolveTarget(sources, index, propagate) {
          var source = sources[index];
          var fill = source.fill;
          var visited = [index];
          var target;
          if (!propagate) {
            return fill;
          }
          while (fill !== false && visited.indexOf(fill) === -1) {
            if (!isFinite(fill)) {
              return fill;
            }
            target = sources[fill];
            if (!target) {
              return false;
            }
            if (target.visible) {
              return fill;
            }
            visited.push(fill);
            fill = target.fill;
          }
          return false;
        }
        function createMapper(source) {
          var fill = source.fill;
          var type = "dataset";
          if (fill === false) {
            return null;
          }
          if (!isFinite(fill)) {
            type = "boundary";
          }
          return mappers[type](source);
        }
        function isDrawable(point) {
          return point && !point.skip;
        }
        function drawArea(ctx, curve0, curve1, len0, len1) {
          var i, cx, cy, r;
          if (!len0 || !len1) {
            return;
          }
          ctx.moveTo(curve0[0].x, curve0[0].y);
          for (i = 1; i < len0; ++i) {
            helpers$1.canvas.lineTo(ctx, curve0[i - 1], curve0[i]);
          }
          if (curve1[0].angle !== void 0) {
            cx = curve1[0].cx;
            cy = curve1[0].cy;
            r = Math.sqrt(Math.pow(curve1[0].x - cx, 2) + Math.pow(curve1[0].y - cy, 2));
            for (i = len1 - 1; i > 0; --i) {
              ctx.arc(cx, cy, r, curve1[i].angle, curve1[i - 1].angle, true);
            }
            return;
          }
          ctx.lineTo(curve1[len1 - 1].x, curve1[len1 - 1].y);
          for (i = len1 - 1; i > 0; --i) {
            helpers$1.canvas.lineTo(ctx, curve1[i], curve1[i - 1], true);
          }
        }
        function doFill(ctx, points, mapper, view, color, loop) {
          var count = points.length;
          var span = view.spanGaps;
          var curve0 = [];
          var curve1 = [];
          var len0 = 0;
          var len1 = 0;
          var i, ilen, index, p0, p1, d0, d1, loopOffset;
          ctx.beginPath();
          for (i = 0, ilen = count; i < ilen; ++i) {
            index = i % count;
            p0 = points[index]._view;
            p1 = mapper(p0, index, view);
            d0 = isDrawable(p0);
            d1 = isDrawable(p1);
            if (loop && loopOffset === void 0 && d0) {
              loopOffset = i + 1;
              ilen = count + loopOffset;
            }
            if (d0 && d1) {
              len0 = curve0.push(p0);
              len1 = curve1.push(p1);
            } else if (len0 && len1) {
              if (!span) {
                drawArea(ctx, curve0, curve1, len0, len1);
                len0 = len1 = 0;
                curve0 = [];
                curve1 = [];
              } else {
                if (d0) {
                  curve0.push(p0);
                }
                if (d1) {
                  curve1.push(p1);
                }
              }
            }
          }
          drawArea(ctx, curve0, curve1, len0, len1);
          ctx.closePath();
          ctx.fillStyle = color;
          ctx.fill();
        }
        var plugin_filler = {
          id: "filler",
          afterDatasetsUpdate: function(chart, options2) {
            var count = (chart.data.datasets || []).length;
            var propagate = options2.propagate;
            var sources = [];
            var meta, i, el, source;
            for (i = 0; i < count; ++i) {
              meta = chart.getDatasetMeta(i);
              el = meta.dataset;
              source = null;
              if (el && el._model && el instanceof elements.Line) {
                source = {
                  visible: chart.isDatasetVisible(i),
                  fill: decodeFill(el, i, count),
                  chart,
                  el
                };
              }
              meta.$filler = source;
              sources.push(source);
            }
            for (i = 0; i < count; ++i) {
              source = sources[i];
              if (!source) {
                continue;
              }
              source.fill = resolveTarget(sources, i, propagate);
              source.boundary = computeBoundary(source);
              source.mapper = createMapper(source);
            }
          },
          beforeDatasetsDraw: function(chart) {
            var metasets = chart._getSortedVisibleDatasetMetas();
            var ctx = chart.ctx;
            var meta, i, el, view, points, mapper, color;
            for (i = metasets.length - 1; i >= 0; --i) {
              meta = metasets[i].$filler;
              if (!meta || !meta.visible) {
                continue;
              }
              el = meta.el;
              view = el._view;
              points = el._children || [];
              mapper = meta.mapper;
              color = view.backgroundColor || core_defaults.global.defaultColor;
              if (mapper && color && points.length) {
                helpers$1.canvas.clipArea(ctx, chart.chartArea);
                doFill(ctx, points, mapper, view, color, el._loop);
                helpers$1.canvas.unclipArea(ctx);
              }
            }
          }
        };
        var getRtlHelper$1 = helpers$1.rtl.getRtlAdapter;
        var noop$1 = helpers$1.noop;
        var valueOrDefault$e = helpers$1.valueOrDefault;
        core_defaults._set("global", {
          legend: {
            display: true,
            position: "top",
            align: "center",
            fullWidth: true,
            reverse: false,
            weight: 1e3,
            onClick: function(e, legendItem) {
              var index = legendItem.datasetIndex;
              var ci = this.chart;
              var meta = ci.getDatasetMeta(index);
              meta.hidden = meta.hidden === null ? !ci.data.datasets[index].hidden : null;
              ci.update();
            },
            onHover: null,
            onLeave: null,
            labels: {
              boxWidth: 40,
              padding: 10,
              generateLabels: function(chart) {
                var datasets = chart.data.datasets;
                var options2 = chart.options.legend || {};
                var usePointStyle = options2.labels && options2.labels.usePointStyle;
                return chart._getSortedDatasetMetas().map(function(meta) {
                  var style = meta.controller.getStyle(usePointStyle ? 0 : void 0);
                  return {
                    text: datasets[meta.index].label,
                    fillStyle: style.backgroundColor,
                    hidden: !chart.isDatasetVisible(meta.index),
                    lineCap: style.borderCapStyle,
                    lineDash: style.borderDash,
                    lineDashOffset: style.borderDashOffset,
                    lineJoin: style.borderJoinStyle,
                    lineWidth: style.borderWidth,
                    strokeStyle: style.borderColor,
                    pointStyle: style.pointStyle,
                    rotation: style.rotation,
                    datasetIndex: meta.index
                  };
                }, this);
              }
            }
          },
          legendCallback: function(chart) {
            var list = document.createElement("ul");
            var datasets = chart.data.datasets;
            var i, ilen, listItem, listItemSpan;
            list.setAttribute("class", chart.id + "-legend");
            for (i = 0, ilen = datasets.length; i < ilen; i++) {
              listItem = list.appendChild(document.createElement("li"));
              listItemSpan = listItem.appendChild(document.createElement("span"));
              listItemSpan.style.backgroundColor = datasets[i].backgroundColor;
              if (datasets[i].label) {
                listItem.appendChild(document.createTextNode(datasets[i].label));
              }
            }
            return list.outerHTML;
          }
        });
        function getBoxWidth(labelOpts, fontSize) {
          return labelOpts.usePointStyle && labelOpts.boxWidth > fontSize ? fontSize : labelOpts.boxWidth;
        }
        var Legend = core_element.extend({
          initialize: function(config) {
            var me = this;
            helpers$1.extend(me, config);
            me.legendHitBoxes = [];
            me._hoveredItem = null;
            me.doughnutMode = false;
          },
          beforeUpdate: noop$1,
          update: function(maxWidth, maxHeight, margins) {
            var me = this;
            me.beforeUpdate();
            me.maxWidth = maxWidth;
            me.maxHeight = maxHeight;
            me.margins = margins;
            me.beforeSetDimensions();
            me.setDimensions();
            me.afterSetDimensions();
            me.beforeBuildLabels();
            me.buildLabels();
            me.afterBuildLabels();
            me.beforeFit();
            me.fit();
            me.afterFit();
            me.afterUpdate();
            return me.minSize;
          },
          afterUpdate: noop$1,
          beforeSetDimensions: noop$1,
          setDimensions: function() {
            var me = this;
            if (me.isHorizontal()) {
              me.width = me.maxWidth;
              me.left = 0;
              me.right = me.width;
            } else {
              me.height = me.maxHeight;
              me.top = 0;
              me.bottom = me.height;
            }
            me.paddingLeft = 0;
            me.paddingTop = 0;
            me.paddingRight = 0;
            me.paddingBottom = 0;
            me.minSize = {
              width: 0,
              height: 0
            };
          },
          afterSetDimensions: noop$1,
          beforeBuildLabels: noop$1,
          buildLabels: function() {
            var me = this;
            var labelOpts = me.options.labels || {};
            var legendItems = helpers$1.callback(labelOpts.generateLabels, [me.chart], me) || [];
            if (labelOpts.filter) {
              legendItems = legendItems.filter(function(item2) {
                return labelOpts.filter(item2, me.chart.data);
              });
            }
            if (me.options.reverse) {
              legendItems.reverse();
            }
            me.legendItems = legendItems;
          },
          afterBuildLabels: noop$1,
          beforeFit: noop$1,
          fit: function() {
            var me = this;
            var opts = me.options;
            var labelOpts = opts.labels;
            var display = opts.display;
            var ctx = me.ctx;
            var labelFont = helpers$1.options._parseFont(labelOpts);
            var fontSize = labelFont.size;
            var hitboxes = me.legendHitBoxes = [];
            var minSize = me.minSize;
            var isHorizontal = me.isHorizontal();
            if (isHorizontal) {
              minSize.width = me.maxWidth;
              minSize.height = display ? 10 : 0;
            } else {
              minSize.width = display ? 10 : 0;
              minSize.height = me.maxHeight;
            }
            if (!display) {
              me.width = minSize.width = me.height = minSize.height = 0;
              return;
            }
            ctx.font = labelFont.string;
            if (isHorizontal) {
              var lineWidths = me.lineWidths = [0];
              var totalHeight = 0;
              ctx.textAlign = "left";
              ctx.textBaseline = "middle";
              helpers$1.each(me.legendItems, function(legendItem, i) {
                var boxWidth = getBoxWidth(labelOpts, fontSize);
                var width = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
                if (i === 0 || lineWidths[lineWidths.length - 1] + width + 2 * labelOpts.padding > minSize.width) {
                  totalHeight += fontSize + labelOpts.padding;
                  lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
                }
                hitboxes[i] = {
                  left: 0,
                  top: 0,
                  width,
                  height: fontSize
                };
                lineWidths[lineWidths.length - 1] += width + labelOpts.padding;
              });
              minSize.height += totalHeight;
            } else {
              var vPadding = labelOpts.padding;
              var columnWidths = me.columnWidths = [];
              var columnHeights = me.columnHeights = [];
              var totalWidth = labelOpts.padding;
              var currentColWidth = 0;
              var currentColHeight = 0;
              helpers$1.each(me.legendItems, function(legendItem, i) {
                var boxWidth = getBoxWidth(labelOpts, fontSize);
                var itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
                if (i > 0 && currentColHeight + fontSize + 2 * vPadding > minSize.height) {
                  totalWidth += currentColWidth + labelOpts.padding;
                  columnWidths.push(currentColWidth);
                  columnHeights.push(currentColHeight);
                  currentColWidth = 0;
                  currentColHeight = 0;
                }
                currentColWidth = Math.max(currentColWidth, itemWidth);
                currentColHeight += fontSize + vPadding;
                hitboxes[i] = {
                  left: 0,
                  top: 0,
                  width: itemWidth,
                  height: fontSize
                };
              });
              totalWidth += currentColWidth;
              columnWidths.push(currentColWidth);
              columnHeights.push(currentColHeight);
              minSize.width += totalWidth;
            }
            me.width = minSize.width;
            me.height = minSize.height;
          },
          afterFit: noop$1,
          isHorizontal: function() {
            return this.options.position === "top" || this.options.position === "bottom";
          },
          draw: function() {
            var me = this;
            var opts = me.options;
            var labelOpts = opts.labels;
            var globalDefaults = core_defaults.global;
            var defaultColor2 = globalDefaults.defaultColor;
            var lineDefault = globalDefaults.elements.line;
            var legendHeight = me.height;
            var columnHeights = me.columnHeights;
            var legendWidth = me.width;
            var lineWidths = me.lineWidths;
            if (!opts.display) {
              return;
            }
            var rtlHelper = getRtlHelper$1(opts.rtl, me.left, me.minSize.width);
            var ctx = me.ctx;
            var fontColor = valueOrDefault$e(labelOpts.fontColor, globalDefaults.defaultFontColor);
            var labelFont = helpers$1.options._parseFont(labelOpts);
            var fontSize = labelFont.size;
            var cursor;
            ctx.textAlign = rtlHelper.textAlign("left");
            ctx.textBaseline = "middle";
            ctx.lineWidth = 0.5;
            ctx.strokeStyle = fontColor;
            ctx.fillStyle = fontColor;
            ctx.font = labelFont.string;
            var boxWidth = getBoxWidth(labelOpts, fontSize);
            var hitboxes = me.legendHitBoxes;
            var drawLegendBox = function(x, y, legendItem) {
              if (isNaN(boxWidth) || boxWidth <= 0) {
                return;
              }
              ctx.save();
              var lineWidth = valueOrDefault$e(legendItem.lineWidth, lineDefault.borderWidth);
              ctx.fillStyle = valueOrDefault$e(legendItem.fillStyle, defaultColor2);
              ctx.lineCap = valueOrDefault$e(legendItem.lineCap, lineDefault.borderCapStyle);
              ctx.lineDashOffset = valueOrDefault$e(legendItem.lineDashOffset, lineDefault.borderDashOffset);
              ctx.lineJoin = valueOrDefault$e(legendItem.lineJoin, lineDefault.borderJoinStyle);
              ctx.lineWidth = lineWidth;
              ctx.strokeStyle = valueOrDefault$e(legendItem.strokeStyle, defaultColor2);
              if (ctx.setLineDash) {
                ctx.setLineDash(valueOrDefault$e(legendItem.lineDash, lineDefault.borderDash));
              }
              if (labelOpts && labelOpts.usePointStyle) {
                var radius = boxWidth * Math.SQRT2 / 2;
                var centerX = rtlHelper.xPlus(x, boxWidth / 2);
                var centerY = y + fontSize / 2;
                helpers$1.canvas.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY, legendItem.rotation);
              } else {
                ctx.fillRect(rtlHelper.leftForLtr(x, boxWidth), y, boxWidth, fontSize);
                if (lineWidth !== 0) {
                  ctx.strokeRect(rtlHelper.leftForLtr(x, boxWidth), y, boxWidth, fontSize);
                }
              }
              ctx.restore();
            };
            var fillText2 = function(x, y, legendItem, textWidth) {
              var halfFontSize = fontSize / 2;
              var xLeft = rtlHelper.xPlus(x, boxWidth + halfFontSize);
              var yMiddle = y + halfFontSize;
              ctx.fillText(legendItem.text, xLeft, yMiddle);
              if (legendItem.hidden) {
                ctx.beginPath();
                ctx.lineWidth = 2;
                ctx.moveTo(xLeft, yMiddle);
                ctx.lineTo(rtlHelper.xPlus(xLeft, textWidth), yMiddle);
                ctx.stroke();
              }
            };
            var alignmentOffset = function(dimension, blockSize) {
              switch (opts.align) {
                case "start":
                  return labelOpts.padding;
                case "end":
                  return dimension - blockSize;
                default:
                  return (dimension - blockSize + labelOpts.padding) / 2;
              }
            };
            var isHorizontal = me.isHorizontal();
            if (isHorizontal) {
              cursor = {
                x: me.left + alignmentOffset(legendWidth, lineWidths[0]),
                y: me.top + labelOpts.padding,
                line: 0
              };
            } else {
              cursor = {
                x: me.left + labelOpts.padding,
                y: me.top + alignmentOffset(legendHeight, columnHeights[0]),
                line: 0
              };
            }
            helpers$1.rtl.overrideTextDirection(me.ctx, opts.textDirection);
            var itemHeight = fontSize + labelOpts.padding;
            helpers$1.each(me.legendItems, function(legendItem, i) {
              var textWidth = ctx.measureText(legendItem.text).width;
              var width = boxWidth + fontSize / 2 + textWidth;
              var x = cursor.x;
              var y = cursor.y;
              rtlHelper.setWidth(me.minSize.width);
              if (isHorizontal) {
                if (i > 0 && x + width + labelOpts.padding > me.left + me.minSize.width) {
                  y = cursor.y += itemHeight;
                  cursor.line++;
                  x = cursor.x = me.left + alignmentOffset(legendWidth, lineWidths[cursor.line]);
                }
              } else if (i > 0 && y + itemHeight > me.top + me.minSize.height) {
                x = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;
                cursor.line++;
                y = cursor.y = me.top + alignmentOffset(legendHeight, columnHeights[cursor.line]);
              }
              var realX = rtlHelper.x(x);
              drawLegendBox(realX, y, legendItem);
              hitboxes[i].left = rtlHelper.leftForLtr(realX, hitboxes[i].width);
              hitboxes[i].top = y;
              fillText2(realX, y, legendItem, textWidth);
              if (isHorizontal) {
                cursor.x += width + labelOpts.padding;
              } else {
                cursor.y += itemHeight;
              }
            });
            helpers$1.rtl.restoreTextDirection(me.ctx, opts.textDirection);
          },
          _getLegendItemAt: function(x, y) {
            var me = this;
            var i, hitBox, lh;
            if (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {
              lh = me.legendHitBoxes;
              for (i = 0; i < lh.length; ++i) {
                hitBox = lh[i];
                if (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {
                  return me.legendItems[i];
                }
              }
            }
            return null;
          },
          handleEvent: function(e) {
            var me = this;
            var opts = me.options;
            var type = e.type === "mouseup" ? "click" : e.type;
            var hoveredItem;
            if (type === "mousemove") {
              if (!opts.onHover && !opts.onLeave) {
                return;
              }
            } else if (type === "click") {
              if (!opts.onClick) {
                return;
              }
            } else {
              return;
            }
            hoveredItem = me._getLegendItemAt(e.x, e.y);
            if (type === "click") {
              if (hoveredItem && opts.onClick) {
                opts.onClick.call(me, e.native, hoveredItem);
              }
            } else {
              if (opts.onLeave && hoveredItem !== me._hoveredItem) {
                if (me._hoveredItem) {
                  opts.onLeave.call(me, e.native, me._hoveredItem);
                }
                me._hoveredItem = hoveredItem;
              }
              if (opts.onHover && hoveredItem) {
                opts.onHover.call(me, e.native, hoveredItem);
              }
            }
          }
        });
        function createNewLegendAndAttach(chart, legendOpts) {
          var legend2 = new Legend({
            ctx: chart.ctx,
            options: legendOpts,
            chart
          });
          core_layouts.configure(chart, legend2, legendOpts);
          core_layouts.addBox(chart, legend2);
          chart.legend = legend2;
        }
        var plugin_legend = {
          id: "legend",
          _element: Legend,
          beforeInit: function(chart) {
            var legendOpts = chart.options.legend;
            if (legendOpts) {
              createNewLegendAndAttach(chart, legendOpts);
            }
          },
          beforeUpdate: function(chart) {
            var legendOpts = chart.options.legend;
            var legend2 = chart.legend;
            if (legendOpts) {
              helpers$1.mergeIf(legendOpts, core_defaults.global.legend);
              if (legend2) {
                core_layouts.configure(chart, legend2, legendOpts);
                legend2.options = legendOpts;
              } else {
                createNewLegendAndAttach(chart, legendOpts);
              }
            } else if (legend2) {
              core_layouts.removeBox(chart, legend2);
              delete chart.legend;
            }
          },
          afterEvent: function(chart, e) {
            var legend2 = chart.legend;
            if (legend2) {
              legend2.handleEvent(e);
            }
          }
        };
        var noop$2 = helpers$1.noop;
        core_defaults._set("global", {
          title: {
            display: false,
            fontStyle: "bold",
            fullWidth: true,
            padding: 10,
            position: "top",
            text: "",
            weight: 2e3
          }
        });
        var Title = core_element.extend({
          initialize: function(config) {
            var me = this;
            helpers$1.extend(me, config);
            me.legendHitBoxes = [];
          },
          beforeUpdate: noop$2,
          update: function(maxWidth, maxHeight, margins) {
            var me = this;
            me.beforeUpdate();
            me.maxWidth = maxWidth;
            me.maxHeight = maxHeight;
            me.margins = margins;
            me.beforeSetDimensions();
            me.setDimensions();
            me.afterSetDimensions();
            me.beforeBuildLabels();
            me.buildLabels();
            me.afterBuildLabels();
            me.beforeFit();
            me.fit();
            me.afterFit();
            me.afterUpdate();
            return me.minSize;
          },
          afterUpdate: noop$2,
          beforeSetDimensions: noop$2,
          setDimensions: function() {
            var me = this;
            if (me.isHorizontal()) {
              me.width = me.maxWidth;
              me.left = 0;
              me.right = me.width;
            } else {
              me.height = me.maxHeight;
              me.top = 0;
              me.bottom = me.height;
            }
            me.paddingLeft = 0;
            me.paddingTop = 0;
            me.paddingRight = 0;
            me.paddingBottom = 0;
            me.minSize = {
              width: 0,
              height: 0
            };
          },
          afterSetDimensions: noop$2,
          beforeBuildLabels: noop$2,
          buildLabels: noop$2,
          afterBuildLabels: noop$2,
          beforeFit: noop$2,
          fit: function() {
            var me = this;
            var opts = me.options;
            var minSize = me.minSize = {};
            var isHorizontal = me.isHorizontal();
            var lineCount, textSize;
            if (!opts.display) {
              me.width = minSize.width = me.height = minSize.height = 0;
              return;
            }
            lineCount = helpers$1.isArray(opts.text) ? opts.text.length : 1;
            textSize = lineCount * helpers$1.options._parseFont(opts).lineHeight + opts.padding * 2;
            me.width = minSize.width = isHorizontal ? me.maxWidth : textSize;
            me.height = minSize.height = isHorizontal ? textSize : me.maxHeight;
          },
          afterFit: noop$2,
          isHorizontal: function() {
            var pos = this.options.position;
            return pos === "top" || pos === "bottom";
          },
          draw: function() {
            var me = this;
            var ctx = me.ctx;
            var opts = me.options;
            if (!opts.display) {
              return;
            }
            var fontOpts = helpers$1.options._parseFont(opts);
            var lineHeight = fontOpts.lineHeight;
            var offset = lineHeight / 2 + opts.padding;
            var rotation = 0;
            var top = me.top;
            var left = me.left;
            var bottom = me.bottom;
            var right = me.right;
            var maxWidth, titleX, titleY;
            ctx.fillStyle = helpers$1.valueOrDefault(opts.fontColor, core_defaults.global.defaultFontColor);
            ctx.font = fontOpts.string;
            if (me.isHorizontal()) {
              titleX = left + (right - left) / 2;
              titleY = top + offset;
              maxWidth = right - left;
            } else {
              titleX = opts.position === "left" ? left + offset : right - offset;
              titleY = top + (bottom - top) / 2;
              maxWidth = bottom - top;
              rotation = Math.PI * (opts.position === "left" ? -0.5 : 0.5);
            }
            ctx.save();
            ctx.translate(titleX, titleY);
            ctx.rotate(rotation);
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            var text2 = opts.text;
            if (helpers$1.isArray(text2)) {
              var y = 0;
              for (var i = 0; i < text2.length; ++i) {
                ctx.fillText(text2[i], 0, y, maxWidth);
                y += lineHeight;
              }
            } else {
              ctx.fillText(text2, 0, 0, maxWidth);
            }
            ctx.restore();
          }
        });
        function createNewTitleBlockAndAttach(chart, titleOpts) {
          var title3 = new Title({
            ctx: chart.ctx,
            options: titleOpts,
            chart
          });
          core_layouts.configure(chart, title3, titleOpts);
          core_layouts.addBox(chart, title3);
          chart.titleBlock = title3;
        }
        var plugin_title = {
          id: "title",
          _element: Title,
          beforeInit: function(chart) {
            var titleOpts = chart.options.title;
            if (titleOpts) {
              createNewTitleBlockAndAttach(chart, titleOpts);
            }
          },
          beforeUpdate: function(chart) {
            var titleOpts = chart.options.title;
            var titleBlock = chart.titleBlock;
            if (titleOpts) {
              helpers$1.mergeIf(titleOpts, core_defaults.global.title);
              if (titleBlock) {
                core_layouts.configure(chart, titleBlock, titleOpts);
                titleBlock.options = titleOpts;
              } else {
                createNewTitleBlockAndAttach(chart, titleOpts);
              }
            } else if (titleBlock) {
              core_layouts.removeBox(chart, titleBlock);
              delete chart.titleBlock;
            }
          }
        };
        var plugins = {};
        var filler = plugin_filler;
        var legend = plugin_legend;
        var title2 = plugin_title;
        plugins.filler = filler;
        plugins.legend = legend;
        plugins.title = title2;
        core_controller.helpers = helpers$1;
        core_helpers();
        core_controller._adapters = core_adapters;
        core_controller.Animation = core_animation;
        core_controller.animationService = core_animations;
        core_controller.controllers = controllers;
        core_controller.DatasetController = core_datasetController;
        core_controller.defaults = core_defaults;
        core_controller.Element = core_element;
        core_controller.elements = elements;
        core_controller.Interaction = core_interaction;
        core_controller.layouts = core_layouts;
        core_controller.platform = platform;
        core_controller.plugins = core_plugins;
        core_controller.Scale = core_scale;
        core_controller.scaleService = core_scaleService;
        core_controller.Ticks = core_ticks;
        core_controller.Tooltip = core_tooltip;
        core_controller.helpers.each(scales, function(scale2, type) {
          core_controller.scaleService.registerScaleType(type, scale2, scale2._defaults);
        });
        for (var k in plugins) {
          if (plugins.hasOwnProperty(k)) {
            core_controller.plugins.register(plugins[k]);
          }
        }
        core_controller.platform.initialize();
        var src = core_controller;
        if (typeof window !== "undefined") {
          window.Chart = core_controller;
        }
        core_controller.Chart = core_controller;
        core_controller.Legend = plugins.legend._element;
        core_controller.Title = plugins.title._element;
        core_controller.pluginService = core_controller.plugins;
        core_controller.PluginBase = core_controller.Element.extend({});
        core_controller.canvasHelpers = core_controller.helpers.canvas;
        core_controller.layoutService = core_controller.layouts;
        core_controller.LinearScaleBase = scale_linearbase;
        core_controller.helpers.each([
          "Bar",
          "Bubble",
          "Doughnut",
          "Line",
          "PolarArea",
          "Radar",
          "Scatter"
        ], function(klass) {
          core_controller[klass] = function(ctx, cfg) {
            return new core_controller(ctx, core_controller.helpers.merge(cfg || {}, {
              type: klass.charAt(0).toLowerCase() + klass.slice(1)
            }));
          };
        });
        return src;
      });
    }
  });

  // elos-web/node_modules/deep-diff/index.js
  var require_deep_diff = __commonJS({
    "elos-web/node_modules/deep-diff/index.js"(exports, module) {
      (function(root, factory) {
        var deepDiff = factory(root);
        if (typeof define === "function" && define.amd) {
          define("DeepDiff", function() {
            return deepDiff;
          });
        } else if (typeof exports === "object" || typeof navigator === "object" && navigator.product.match(/ReactNative/i)) {
          module.exports = deepDiff;
        } else {
          var _deepdiff = root.DeepDiff;
          deepDiff.noConflict = function() {
            if (root.DeepDiff === deepDiff) {
              root.DeepDiff = _deepdiff;
            }
            return deepDiff;
          };
          root.DeepDiff = deepDiff;
        }
      })(exports, function(root) {
        var validKinds = ["N", "E", "A", "D"];
        function inherits(ctor, superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
        function Diff(kind, path) {
          Object.defineProperty(this, "kind", {
            value: kind,
            enumerable: true
          });
          if (path && path.length) {
            Object.defineProperty(this, "path", {
              value: path,
              enumerable: true
            });
          }
        }
        function DiffEdit(path, origin, value) {
          DiffEdit.super_.call(this, "E", path);
          Object.defineProperty(this, "lhs", {
            value: origin,
            enumerable: true
          });
          Object.defineProperty(this, "rhs", {
            value,
            enumerable: true
          });
        }
        inherits(DiffEdit, Diff);
        function DiffNew(path, value) {
          DiffNew.super_.call(this, "N", path);
          Object.defineProperty(this, "rhs", {
            value,
            enumerable: true
          });
        }
        inherits(DiffNew, Diff);
        function DiffDeleted(path, value) {
          DiffDeleted.super_.call(this, "D", path);
          Object.defineProperty(this, "lhs", {
            value,
            enumerable: true
          });
        }
        inherits(DiffDeleted, Diff);
        function DiffArray(path, index, item2) {
          DiffArray.super_.call(this, "A", path);
          Object.defineProperty(this, "index", {
            value: index,
            enumerable: true
          });
          Object.defineProperty(this, "item", {
            value: item2,
            enumerable: true
          });
        }
        inherits(DiffArray, Diff);
        function arrayRemove(arr, from, to) {
          var rest = arr.slice((to || from) + 1 || arr.length);
          arr.length = from < 0 ? arr.length + from : from;
          arr.push.apply(arr, rest);
          return arr;
        }
        function realTypeOf(subject) {
          var type = typeof subject;
          if (type !== "object") {
            return type;
          }
          if (subject === Math) {
            return "math";
          } else if (subject === null) {
            return "null";
          } else if (Array.isArray(subject)) {
            return "array";
          } else if (Object.prototype.toString.call(subject) === "[object Date]") {
            return "date";
          } else if (typeof subject.toString === "function" && /^\/.*\//.test(subject.toString())) {
            return "regexp";
          }
          return "object";
        }
        function hashThisString(string) {
          var hash = 0;
          if (string.length === 0) {
            return hash;
          }
          for (var i = 0; i < string.length; i++) {
            var char = string.charCodeAt(i);
            hash = (hash << 5) - hash + char;
            hash = hash & hash;
          }
          return hash;
        }
        function getOrderIndependentHash(object) {
          var accum = 0;
          var type = realTypeOf(object);
          if (type === "array") {
            object.forEach(function(item2) {
              accum += getOrderIndependentHash(item2);
            });
            var arrayString = "[type: array, hash: " + accum + "]";
            return accum + hashThisString(arrayString);
          }
          if (type === "object") {
            for (var key in object) {
              if (object.hasOwnProperty(key)) {
                var keyValueString = "[ type: object, key: " + key + ", value hash: " + getOrderIndependentHash(object[key]) + "]";
                accum += hashThisString(keyValueString);
              }
            }
            return accum;
          }
          var stringToHash = "[ type: " + type + " ; value: " + object + "]";
          return accum + hashThisString(stringToHash);
        }
        function deepDiff(lhs, rhs, changes, prefilter, path, key, stack, orderIndependent) {
          changes = changes || [];
          path = path || [];
          stack = stack || [];
          var currentPath = path.slice(0);
          if (typeof key !== "undefined" && key !== null) {
            if (prefilter) {
              if (typeof prefilter === "function" && prefilter(currentPath, key)) {
                return;
              } else if (typeof prefilter === "object") {
                if (prefilter.prefilter && prefilter.prefilter(currentPath, key)) {
                  return;
                }
                if (prefilter.normalize) {
                  var alt = prefilter.normalize(currentPath, key, lhs, rhs);
                  if (alt) {
                    lhs = alt[0];
                    rhs = alt[1];
                  }
                }
              }
            }
            currentPath.push(key);
          }
          if (realTypeOf(lhs) === "regexp" && realTypeOf(rhs) === "regexp") {
            lhs = lhs.toString();
            rhs = rhs.toString();
          }
          var ltype = typeof lhs;
          var rtype = typeof rhs;
          var i, j, k, other;
          var ldefined = ltype !== "undefined" || stack && stack.length > 0 && stack[stack.length - 1].lhs && Object.getOwnPropertyDescriptor(stack[stack.length - 1].lhs, key);
          var rdefined = rtype !== "undefined" || stack && stack.length > 0 && stack[stack.length - 1].rhs && Object.getOwnPropertyDescriptor(stack[stack.length - 1].rhs, key);
          if (!ldefined && rdefined) {
            changes.push(new DiffNew(currentPath, rhs));
          } else if (!rdefined && ldefined) {
            changes.push(new DiffDeleted(currentPath, lhs));
          } else if (realTypeOf(lhs) !== realTypeOf(rhs)) {
            changes.push(new DiffEdit(currentPath, lhs, rhs));
          } else if (realTypeOf(lhs) === "date" && lhs - rhs !== 0) {
            changes.push(new DiffEdit(currentPath, lhs, rhs));
          } else if (ltype === "object" && lhs !== null && rhs !== null) {
            for (i = stack.length - 1; i > -1; --i) {
              if (stack[i].lhs === lhs) {
                other = true;
                break;
              }
            }
            if (!other) {
              stack.push({ lhs, rhs });
              if (Array.isArray(lhs)) {
                if (orderIndependent) {
                  lhs.sort(function(a, b) {
                    return getOrderIndependentHash(a) - getOrderIndependentHash(b);
                  });
                  rhs.sort(function(a, b) {
                    return getOrderIndependentHash(a) - getOrderIndependentHash(b);
                  });
                }
                i = rhs.length - 1;
                j = lhs.length - 1;
                while (i > j) {
                  changes.push(new DiffArray(currentPath, i, new DiffNew(void 0, rhs[i--])));
                }
                while (j > i) {
                  changes.push(new DiffArray(currentPath, j, new DiffDeleted(void 0, lhs[j--])));
                }
                for (; i >= 0; --i) {
                  deepDiff(lhs[i], rhs[i], changes, prefilter, currentPath, i, stack, orderIndependent);
                }
              } else {
                var akeys = Object.keys(lhs);
                var pkeys = Object.keys(rhs);
                for (i = 0; i < akeys.length; ++i) {
                  k = akeys[i];
                  other = pkeys.indexOf(k);
                  if (other >= 0) {
                    deepDiff(lhs[k], rhs[k], changes, prefilter, currentPath, k, stack, orderIndependent);
                    pkeys[other] = null;
                  } else {
                    deepDiff(lhs[k], void 0, changes, prefilter, currentPath, k, stack, orderIndependent);
                  }
                }
                for (i = 0; i < pkeys.length; ++i) {
                  k = pkeys[i];
                  if (k) {
                    deepDiff(void 0, rhs[k], changes, prefilter, currentPath, k, stack, orderIndependent);
                  }
                }
              }
              stack.length = stack.length - 1;
            } else if (lhs !== rhs) {
              changes.push(new DiffEdit(currentPath, lhs, rhs));
            }
          } else if (lhs !== rhs) {
            if (!(ltype === "number" && isNaN(lhs) && isNaN(rhs))) {
              changes.push(new DiffEdit(currentPath, lhs, rhs));
            }
          }
        }
        function observableDiff(lhs, rhs, observer, prefilter, orderIndependent) {
          var changes = [];
          deepDiff(lhs, rhs, changes, prefilter, null, null, null, orderIndependent);
          if (observer) {
            for (var i = 0; i < changes.length; ++i) {
              observer(changes[i]);
            }
          }
          return changes;
        }
        function orderIndependentDeepDiff(lhs, rhs, changes, prefilter, path, key, stack) {
          return deepDiff(lhs, rhs, changes, prefilter, path, key, stack, true);
        }
        function accumulateDiff(lhs, rhs, prefilter, accum) {
          var observer = accum ? function(difference) {
            if (difference) {
              accum.push(difference);
            }
          } : void 0;
          var changes = observableDiff(lhs, rhs, observer, prefilter);
          return accum ? accum : changes.length ? changes : void 0;
        }
        function accumulateOrderIndependentDiff(lhs, rhs, prefilter, accum) {
          var observer = accum ? function(difference) {
            if (difference) {
              accum.push(difference);
            }
          } : void 0;
          var changes = observableDiff(lhs, rhs, observer, prefilter, true);
          return accum ? accum : changes.length ? changes : void 0;
        }
        function applyArrayChange(arr, index, change) {
          if (change.path && change.path.length) {
            var it = arr[index], i, u = change.path.length - 1;
            for (i = 0; i < u; i++) {
              it = it[change.path[i]];
            }
            switch (change.kind) {
              case "A":
                applyArrayChange(it[change.path[i]], change.index, change.item);
                break;
              case "D":
                delete it[change.path[i]];
                break;
              case "E":
              case "N":
                it[change.path[i]] = change.rhs;
                break;
            }
          } else {
            switch (change.kind) {
              case "A":
                applyArrayChange(arr[index], change.index, change.item);
                break;
              case "D":
                arr = arrayRemove(arr, index);
                break;
              case "E":
              case "N":
                arr[index] = change.rhs;
                break;
            }
          }
          return arr;
        }
        function applyChange(target, source, change) {
          if (typeof change === "undefined" && source && ~validKinds.indexOf(source.kind)) {
            change = source;
          }
          if (target && change && change.kind) {
            var it = target, i = -1, last = change.path ? change.path.length - 1 : 0;
            while (++i < last) {
              if (typeof it[change.path[i]] === "undefined") {
                it[change.path[i]] = typeof change.path[i + 1] !== "undefined" && typeof change.path[i + 1] === "number" ? [] : {};
              }
              it = it[change.path[i]];
            }
            switch (change.kind) {
              case "A":
                if (change.path && typeof it[change.path[i]] === "undefined") {
                  it[change.path[i]] = [];
                }
                applyArrayChange(change.path ? it[change.path[i]] : it, change.index, change.item);
                break;
              case "D":
                delete it[change.path[i]];
                break;
              case "E":
              case "N":
                it[change.path[i]] = change.rhs;
                break;
            }
          }
        }
        function revertArrayChange(arr, index, change) {
          if (change.path && change.path.length) {
            var it = arr[index], i, u = change.path.length - 1;
            for (i = 0; i < u; i++) {
              it = it[change.path[i]];
            }
            switch (change.kind) {
              case "A":
                revertArrayChange(it[change.path[i]], change.index, change.item);
                break;
              case "D":
                it[change.path[i]] = change.lhs;
                break;
              case "E":
                it[change.path[i]] = change.lhs;
                break;
              case "N":
                delete it[change.path[i]];
                break;
            }
          } else {
            switch (change.kind) {
              case "A":
                revertArrayChange(arr[index], change.index, change.item);
                break;
              case "D":
                arr[index] = change.lhs;
                break;
              case "E":
                arr[index] = change.lhs;
                break;
              case "N":
                arr = arrayRemove(arr, index);
                break;
            }
          }
          return arr;
        }
        function revertChange(target, source, change) {
          if (target && source && change && change.kind) {
            var it = target, i, u;
            u = change.path.length - 1;
            for (i = 0; i < u; i++) {
              if (typeof it[change.path[i]] === "undefined") {
                it[change.path[i]] = {};
              }
              it = it[change.path[i]];
            }
            switch (change.kind) {
              case "A":
                revertArrayChange(it[change.path[i]], change.index, change.item);
                break;
              case "D":
                it[change.path[i]] = change.lhs;
                break;
              case "E":
                it[change.path[i]] = change.lhs;
                break;
              case "N":
                delete it[change.path[i]];
                break;
            }
          }
        }
        function applyDiff(target, source, filter) {
          if (target && source) {
            var onChange = function(change) {
              if (!filter || filter(target, source, change)) {
                applyChange(target, source, change);
              }
            };
            observableDiff(target, source, onChange);
          }
        }
        Object.defineProperties(accumulateDiff, {
          diff: {
            value: accumulateDiff,
            enumerable: true
          },
          orderIndependentDiff: {
            value: accumulateOrderIndependentDiff,
            enumerable: true
          },
          observableDiff: {
            value: observableDiff,
            enumerable: true
          },
          orderIndependentObservableDiff: {
            value: orderIndependentDeepDiff,
            enumerable: true
          },
          orderIndepHash: {
            value: getOrderIndependentHash,
            enumerable: true
          },
          applyDiff: {
            value: applyDiff,
            enumerable: true
          },
          applyChange: {
            value: applyChange,
            enumerable: true
          },
          revertChange: {
            value: revertChange,
            enumerable: true
          },
          isConflict: {
            value: function() {
              return typeof $conflict !== "undefined";
            },
            enumerable: true
          }
        });
        accumulateDiff.DeepDiff = accumulateDiff;
        if (root) {
          root.DeepDiff = accumulateDiff;
        }
        return accumulateDiff;
      });
    }
  });

  // elos-web/node_modules/svelte-data-grid/index.js
  var require_svelte_data_grid = __commonJS({
    "elos-web/node_modules/svelte-data-grid/index.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory(require_deep_diff()) : typeof define === "function" && define.amd ? define(["deep-diff"], factory) : (global2 = global2 || self, global2.DataGrid = factory(global2.DeepDiff));
      })(exports, function(DeepDiff) {
        "use strict";
        function noop2() {
        }
        function run2(fn) {
          return fn();
        }
        function blank_object2() {
          return Object.create(null);
        }
        function run_all2(fns) {
          fns.forEach(run2);
        }
        function is_function2(thing) {
          return typeof thing === "function";
        }
        function safe_not_equal2(a, b) {
          return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
        }
        function append2(target, node) {
          target.appendChild(node);
        }
        function insert2(target, node, anchor) {
          target.insertBefore(node, anchor || null);
        }
        function detach2(node) {
          node.parentNode.removeChild(node);
        }
        function destroy_each2(iterations, detaching) {
          for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
              iterations[i].d(detaching);
          }
        }
        function element2(name) {
          return document.createElement(name);
        }
        function text2(data) {
          return document.createTextNode(data);
        }
        function space2() {
          return text2(" ");
        }
        function empty2() {
          return text2("");
        }
        function listen2(node, event, handler, options) {
          node.addEventListener(event, handler, options);
          return () => node.removeEventListener(event, handler, options);
        }
        function attr2(node, attribute, value) {
          if (value == null)
            node.removeAttribute(attribute);
          else
            node.setAttribute(attribute, value);
        }
        function children2(element3) {
          return Array.from(element3.childNodes);
        }
        function set_data2(text3, data) {
          data = "" + data;
          if (text3.data !== data)
            text3.data = data;
        }
        function set_style2(node, key, value, important) {
          node.style.setProperty(key, value, important ? "important" : "");
        }
        function add_resize_listener2(element3, fn) {
          if (getComputedStyle(element3).position === "static") {
            element3.style.position = "relative";
          }
          const object = document.createElement("object");
          object.setAttribute("style", "display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; pointer-events: none; z-index: -1;");
          object.type = "text/html";
          object.tabIndex = -1;
          let win;
          object.onload = () => {
            win = object.contentDocument.defaultView;
            win.addEventListener("resize", fn);
          };
          if (/Trident/.test(navigator.userAgent)) {
            element3.appendChild(object);
            object.data = "about:blank";
          } else {
            object.data = "about:blank";
            element3.appendChild(object);
          }
          return {
            cancel: () => {
              win && win.removeEventListener && win.removeEventListener("resize", fn);
              element3.removeChild(object);
            }
          };
        }
        function custom_event2(type, detail) {
          const e = document.createEvent("CustomEvent");
          e.initCustomEvent(type, false, false, detail);
          return e;
        }
        let current_component2;
        function set_current_component2(component) {
          current_component2 = component;
        }
        function get_current_component2() {
          if (!current_component2)
            throw new Error(`Function called outside component initialization`);
          return current_component2;
        }
        function onMount2(fn) {
          get_current_component2().$$.on_mount.push(fn);
        }
        function createEventDispatcher2() {
          const component = current_component2;
          return (type, detail) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
              const event = custom_event2(type, detail);
              callbacks.slice().forEach((fn) => {
                fn.call(component, event);
              });
            }
          };
        }
        const dirty_components2 = [];
        const binding_callbacks2 = [];
        const render_callbacks2 = [];
        const flush_callbacks2 = [];
        const resolved_promise2 = Promise.resolve();
        let update_scheduled2 = false;
        function schedule_update2() {
          if (!update_scheduled2) {
            update_scheduled2 = true;
            resolved_promise2.then(flush2);
          }
        }
        function add_render_callback2(fn) {
          render_callbacks2.push(fn);
        }
        function flush2() {
          const seen_callbacks2 = new Set();
          do {
            while (dirty_components2.length) {
              const component = dirty_components2.shift();
              set_current_component2(component);
              update2(component.$$);
            }
            while (binding_callbacks2.length)
              binding_callbacks2.pop()();
            for (let i = 0; i < render_callbacks2.length; i += 1) {
              const callback = render_callbacks2[i];
              if (!seen_callbacks2.has(callback)) {
                callback();
                seen_callbacks2.add(callback);
              }
            }
            render_callbacks2.length = 0;
          } while (dirty_components2.length);
          while (flush_callbacks2.length) {
            flush_callbacks2.pop()();
          }
          update_scheduled2 = false;
        }
        function update2($$) {
          if ($$.fragment) {
            $$.update($$.dirty);
            run_all2($$.before_update);
            $$.fragment.p($$.dirty, $$.ctx);
            $$.dirty = null;
            $$.after_update.forEach(add_render_callback2);
          }
        }
        const outroing2 = new Set();
        let outros2;
        function group_outros2() {
          outros2 = {
            r: 0,
            c: [],
            p: outros2
          };
        }
        function check_outros2() {
          if (!outros2.r) {
            run_all2(outros2.c);
          }
          outros2 = outros2.p;
        }
        function transition_in2(block, local) {
          if (block && block.i) {
            outroing2.delete(block);
            block.i(local);
          }
        }
        function transition_out2(block, local, detach3, callback) {
          if (block && block.o) {
            if (outroing2.has(block))
              return;
            outroing2.add(block);
            outros2.c.push(() => {
              outroing2.delete(block);
              if (callback) {
                if (detach3)
                  block.d(1);
                callback();
              }
            });
            block.o(local);
          }
        }
        const globals2 = typeof window !== "undefined" ? window : global;
        function outro_and_destroy_block2(block, lookup) {
          transition_out2(block, 1, 1, () => {
            lookup.delete(block.key);
          });
        }
        function update_keyed_each2(old_blocks, changed, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block13, next, get_context) {
          let o = old_blocks.length;
          let n = list.length;
          let i = o;
          const old_indexes = {};
          while (i--)
            old_indexes[old_blocks[i].key] = i;
          const new_blocks = [];
          const new_lookup = new Map();
          const deltas = new Map();
          i = n;
          while (i--) {
            const child_ctx = get_context(ctx, list, i);
            const key = get_key(child_ctx);
            let block = lookup.get(key);
            if (!block) {
              block = create_each_block13(key, child_ctx);
              block.c();
            } else if (dynamic) {
              block.p(changed, child_ctx);
            }
            new_lookup.set(key, new_blocks[i] = block);
            if (key in old_indexes)
              deltas.set(key, Math.abs(i - old_indexes[key]));
          }
          const will_move = new Set();
          const did_move = new Set();
          function insert3(block) {
            transition_in2(block, 1);
            block.m(node, next);
            lookup.set(block.key, block);
            next = block.first;
            n--;
          }
          while (o && n) {
            const new_block = new_blocks[n - 1];
            const old_block = old_blocks[o - 1];
            const new_key = new_block.key;
            const old_key = old_block.key;
            if (new_block === old_block) {
              next = new_block.first;
              o--;
              n--;
            } else if (!new_lookup.has(old_key)) {
              destroy(old_block, lookup);
              o--;
            } else if (!lookup.has(new_key) || will_move.has(new_key)) {
              insert3(new_block);
            } else if (did_move.has(old_key)) {
              o--;
            } else if (deltas.get(new_key) > deltas.get(old_key)) {
              did_move.add(new_key);
              insert3(new_block);
            } else {
              will_move.add(old_key);
              o--;
            }
          }
          while (o--) {
            const old_block = old_blocks[o];
            if (!new_lookup.has(old_block.key))
              destroy(old_block, lookup);
          }
          while (n)
            insert3(new_blocks[n - 1]);
          return new_blocks;
        }
        function mount_component2(component, target, anchor) {
          const { fragment, on_mount, on_destroy, after_update } = component.$$;
          fragment.m(target, anchor);
          add_render_callback2(() => {
            const new_on_destroy = on_mount.map(run2).filter(is_function2);
            if (on_destroy) {
              on_destroy.push(...new_on_destroy);
            } else {
              run_all2(new_on_destroy);
            }
            component.$$.on_mount = [];
          });
          after_update.forEach(add_render_callback2);
        }
        function destroy_component2(component, detaching) {
          if (component.$$.fragment) {
            run_all2(component.$$.on_destroy);
            component.$$.fragment.d(detaching);
            component.$$.on_destroy = component.$$.fragment = null;
            component.$$.ctx = {};
          }
        }
        function make_dirty2(component, key) {
          if (!component.$$.dirty) {
            dirty_components2.push(component);
            schedule_update2();
            component.$$.dirty = blank_object2();
          }
          component.$$.dirty[key] = true;
        }
        function init2(component, options, instance87, create_fragment89, not_equal, prop_names) {
          const parent_component = current_component2;
          set_current_component2(component);
          const props = options.props || {};
          const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            props: prop_names,
            update: noop2,
            not_equal,
            bound: blank_object2(),
            on_mount: [],
            on_destroy: [],
            before_update: [],
            after_update: [],
            context: new Map(parent_component ? parent_component.$$.context : []),
            callbacks: blank_object2(),
            dirty: null
          };
          let ready = false;
          $$.ctx = instance87 ? instance87(component, props, (key, ret, value = ret) => {
            if ($$.ctx && not_equal($$.ctx[key], $$.ctx[key] = value)) {
              if ($$.bound[key])
                $$.bound[key](value);
              if (ready)
                make_dirty2(component, key);
            }
            return ret;
          }) : props;
          $$.update();
          ready = true;
          run_all2($$.before_update);
          $$.fragment = create_fragment89($$.ctx);
          if (options.target) {
            if (options.hydrate) {
              $$.fragment.l(children2(options.target));
            } else {
              $$.fragment.c();
            }
            if (options.intro)
              transition_in2(component.$$.fragment);
            mount_component2(component, options.target, options.anchor);
            flush2();
          }
          set_current_component2(parent_component);
        }
        class SvelteComponent2 {
          $destroy() {
            destroy_component2(this, 1);
            this.$destroy = noop2;
          }
          $on(type, callback) {
            const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
            callbacks.push(callback);
            return () => {
              const index = callbacks.indexOf(callback);
              if (index !== -1)
                callbacks.splice(index, 1);
            };
          }
          $set() {
          }
        }
        const applyChange = DeepDiff.applyChange;
        const diff = DeepDiff.diff;
        class EditHistory {
          constructor(obj) {
            this.obj = JSON.parse(JSON.stringify(obj));
            this.forward = [];
            this.backward = [];
          }
          clear() {
            this.forward = [];
            this.backward = [];
          }
          recordChange(newObj) {
            const patch = {
              redo: diff(this.obj, newObj),
              undo: diff(newObj, this.obj)
            };
            if (!patch.redo || !patch.undo) {
              console.warn("Objects could not be diffed");
            } else {
              this.obj = JSON.parse(JSON.stringify(newObj));
              this.backward.push(patch);
            }
          }
          undo() {
            if (this.backward.length === 0) {
              return null;
            }
            const patch = this.backward.pop();
            patch.undo.forEach((x) => applyChange(this.obj, x));
            this.forward.push(patch);
            return JSON.parse(JSON.stringify(this.obj));
          }
          redo() {
            if (this.forward.length === 0) {
              return null;
            }
            const patch = this.forward.pop();
            patch.redo.forEach((x) => applyChange(this.obj, x));
            this.backward.push(patch);
            return JSON.parse(JSON.stringify(this.obj));
          }
          undoAll() {
            while (this.backward.length > 0) {
              this.undo();
            }
            return this.obj;
          }
          redoAll() {
            while (this.forward.length > 0) {
              this.redo();
            }
            return this.obj;
          }
        }
        const { document: document_1, window: window_1 } = globals2;
        function add_css() {
          var style = element2("style");
          style.id = "svelte-b58rik-style";
          style.textContent = ".row-action-line.svelte-b58rik{position:absolute;left:0;width:100%;height:4px;z-index:6;background:#aaa}.row-affix-marker.svelte-b58rik{display:none;position:absolute;left:0;height:4px;z-index:6;background:white;border-top:1px solid #999;border-bottom:1px solid #999;cursor:ns-resize}.column-affix-marker.svelte-b58rik{position:absolute;top:0;width:4px;z-index:5;background:white;border-left:1px solid #999;border-right:1px solid #999;cursor:ew-resize;transform:translateX(-50%)}.resizing.svelte-b58rik .svelte-b58rik{user-select:none}.resizing.svelte-b58rik .grid-inner.svelte-b58rik{overflow-y:hidden}.resizing.svelte-b58rik .grid-space.svelte-b58rik{pointer-events:all}.grid-cell.svelte-b58rik>.svelte-b58rik{height:100%}.cell-default.svelte-b58rik{padding:0 5px;background:white;overflow:hidden;text-overflow:ellipsis}.data-grid-wrapper.svelte-b58rik{position:relative;width:100%;height:100%}.column-action-line.svelte-b58rik{position:absolute;top:0;bottom:17px;z-index:3;width:4px;background:#aaa;cursor:ew-resize}.grid-cell-size-capture.svelte-b58rik{position:absolute;top:0;bottom:0;z-index:5;background:transparent;cursor:ew-resize;pointer-events:all}.grid-inner.svelte-b58rik{overflow:auto}.grid-space.svelte-b58rik{position:absolute;top:0;left:0;background:transparent;pointer-events:none;z-index:3}.grid-headers.svelte-b58rik{position:absolute;overflow:hidden;max-width:100%;width:100%;top:0;left:0;border-bottom:2px solid black}.grid-headers.svelte-b58rik .grid-cell.svelte-b58rik{text-align:center;font-weight:bold;cursor:pointer}.grid-headers.svelte-b58rik .cell-default.svelte-b58rik:hover{background:#eee}.grid-header-row.svelte-b58rik{position:absolute;overflow:hidden;top:0}.grid-row.svelte-b58rik{position:absolute;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}.grid-row.svelte-b58rik:not(:last-child){border-bottom:1px solid #666}.grid-cell.svelte-b58rik{position:absolute;top:0;text-overflow:ellipsis;overflow:hidden}.grid-cell.svelte-b58rik>.svelte-b58rik{width:100%}.grid-cell.svelte-b58rik:not(:last-child){border-right:1px solid #666}";
          append2(document_1.head, style);
        }
        function get_each_context_14(ctx, list, i) {
          const child_ctx = Object.create(ctx);
          child_ctx.column = list[i];
          child_ctx.j = i;
          return child_ctx;
        }
        function get_each_context12(ctx, list, i) {
          const child_ctx = Object.create(ctx);
          child_ctx.row = list[i];
          child_ctx.i = i;
          return child_ctx;
        }
        function get_each_context_23(ctx, list, i) {
          const child_ctx = Object.create(ctx);
          child_ctx.column = list[i];
          child_ctx.i = i;
          return child_ctx;
        }
        function get_each_context_3(ctx, list, i) {
          const child_ctx = Object.create(ctx);
          child_ctx.column = list[i];
          child_ctx.i = i;
          return child_ctx;
        }
        function create_if_block_72(ctx) {
          var div;
          return {
            c() {
              div = element2("div");
              attr2(div, "class", "column-action-line svelte-b58rik");
              set_style2(div, "left", "" + (ctx.__columnActionLineLeft - 2) + "px");
            },
            m(target, anchor) {
              insert2(target, div, anchor);
            },
            p(changed, ctx2) {
              if (changed.__columnActionLineLeft) {
                set_style2(div, "left", "" + (ctx2.__columnActionLineLeft - 2) + "px");
              }
            },
            d(detaching) {
              if (detaching) {
                detach2(div);
              }
            }
          };
        }
        function create_if_block_62(ctx) {
          var div;
          return {
            c() {
              div = element2("div");
              attr2(div, "class", "row-action-line svelte-b58rik");
              set_style2(div, "top", "" + (ctx.__rowActionLineTop - 2) + "px");
            },
            m(target, anchor) {
              insert2(target, div, anchor);
            },
            p(changed, ctx2) {
              if (changed.__rowActionLineTop) {
                set_style2(div, "top", "" + (ctx2.__rowActionLineTop - 2) + "px");
              }
            },
            d(detaching) {
              if (detaching) {
                detach2(div);
              }
            }
          };
        }
        function create_else_block_15(ctx) {
          var div, t_value = ctx.column.display || "", t;
          return {
            c() {
              div = element2("div");
              t = text2(t_value);
              attr2(div, "class", "cell-default svelte-b58rik");
            },
            m(target, anchor) {
              insert2(target, div, anchor);
              append2(div, t);
            },
            p(changed, ctx2) {
              if (changed.columns && t_value !== (t_value = ctx2.column.display || "")) {
                set_data2(t, t_value);
              }
            },
            i: noop2,
            o: noop2,
            d(detaching) {
              if (detaching) {
                detach2(div);
              }
            }
          };
        }
        function create_if_block_52(ctx) {
          var switch_instance_anchor, current;
          var switch_value = ctx.column.headerComponent;
          function switch_props(ctx2) {
            return { props: { column: ctx2.column } };
          }
          if (switch_value) {
            var switch_instance = new switch_value(switch_props(ctx));
          }
          return {
            c() {
              if (switch_instance)
                switch_instance.$$.fragment.c();
              switch_instance_anchor = empty2();
            },
            m(target, anchor) {
              if (switch_instance) {
                mount_component2(switch_instance, target, anchor);
              }
              insert2(target, switch_instance_anchor, anchor);
              current = true;
            },
            p(changed, ctx2) {
              var switch_instance_changes = {};
              if (changed.columns)
                switch_instance_changes.column = ctx2.column;
              if (switch_value !== (switch_value = ctx2.column.headerComponent)) {
                if (switch_instance) {
                  group_outros2();
                  const old_component = switch_instance;
                  transition_out2(old_component.$$.fragment, 1, 0, () => {
                    destroy_component2(old_component, 1);
                  });
                  check_outros2();
                }
                if (switch_value) {
                  switch_instance = new switch_value(switch_props(ctx2));
                  switch_instance.$$.fragment.c();
                  transition_in2(switch_instance.$$.fragment, 1);
                  mount_component2(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
                } else {
                  switch_instance = null;
                }
              } else if (switch_value) {
                switch_instance.$set(switch_instance_changes);
              }
            },
            i(local) {
              if (current)
                return;
              if (switch_instance)
                transition_in2(switch_instance.$$.fragment, local);
              current = true;
            },
            o(local) {
              if (switch_instance)
                transition_out2(switch_instance.$$.fragment, local);
              current = false;
            },
            d(detaching) {
              if (detaching) {
                detach2(switch_instance_anchor);
              }
              if (switch_instance)
                destroy_component2(switch_instance, detaching);
            }
          };
        }
        function create_if_block_42(ctx) {
          var div, dispose;
          function mousedown_handler_1(...args) {
            return ctx.mousedown_handler_1(ctx, ...args);
          }
          return {
            c() {
              div = element2("div");
              attr2(div, "class", "grid-cell-size-capture svelte-b58rik");
              set_style2(div, "left", "" + (getCellLeft({
                i: ctx.i,
                columnWidths: ctx.columnWidths,
                __affixedColumnIndices: ctx.__affixedColumnIndices,
                __scrollLeft: ctx.__scrollLeft
              }) + ctx.columnWidths[ctx.i] - ctx.Math.floor(ctx.__columnHeaderResizeCaptureWidth / 2)) + "px");
              set_style2(div, "width", "" + ctx.__columnHeaderResizeCaptureWidth + "px");
              dispose = listen2(div, "mousedown", mousedown_handler_1);
            },
            m(target, anchor) {
              insert2(target, div, anchor);
            },
            p(changed, new_ctx) {
              ctx = new_ctx;
              if (changed.columns || changed.columnWidths || changed.__affixedColumnIndices || changed.__scrollLeft || changed.__columnHeaderResizeCaptureWidth) {
                set_style2(div, "left", "" + (getCellLeft({
                  i: ctx.i,
                  columnWidths: ctx.columnWidths,
                  __affixedColumnIndices: ctx.__affixedColumnIndices,
                  __scrollLeft: ctx.__scrollLeft
                }) + ctx.columnWidths[ctx.i] - ctx.Math.floor(ctx.__columnHeaderResizeCaptureWidth / 2)) + "px");
              }
              if (changed.__columnHeaderResizeCaptureWidth) {
                set_style2(div, "width", "" + ctx.__columnHeaderResizeCaptureWidth + "px");
              }
            },
            d(detaching) {
              if (detaching) {
                detach2(div);
              }
              dispose();
            }
          };
        }
        function create_each_block_3(key_1, ctx) {
          var div, current_block_type_index, if_block0, div_title_value, dragCopy_action, t, if_block1_anchor, current, dispose;
          var if_block_creators = [
            create_if_block_52,
            create_else_block_15
          ];
          var if_blocks = [];
          function select_block_type(changed, ctx2) {
            if (ctx2.column.headerComponent)
              return 0;
            return 1;
          }
          current_block_type_index = select_block_type(null, ctx);
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          function mousedown_handler(...args) {
            return ctx.mousedown_handler(ctx, ...args);
          }
          var if_block1 = ctx.allowResizeFromTableHeaders && !ctx.column.disallowResize && create_if_block_42(ctx);
          return {
            key: key_1,
            first: null,
            c() {
              div = element2("div");
              if_block0.c();
              t = space2();
              if (if_block1)
                if_block1.c();
              if_block1_anchor = empty2();
              attr2(div, "class", "grid-cell svelte-b58rik");
              set_style2(div, "z-index", ctx.getCellZIndex(ctx.__affixedColumnIndices, ctx.i));
              set_style2(div, "left", "" + getCellLeft({ i: ctx.i, columnWidths: ctx.columnWidths, __affixedColumnIndices: ctx.__affixedColumnIndices, __scrollLeft: ctx.__scrollLeft }) + "px");
              set_style2(div, "width", "" + ctx.columnWidths[ctx.i] + "px");
              set_style2(div, "height", "" + ctx.rowHeight + "px");
              set_style2(div, "line-height", "" + ctx.rowHeight + "px");
              attr2(div, "title", div_title_value = ctx.column.display || "");
              attr2(div, "role", "columnheader");
              dispose = listen2(div, "mousedown", mousedown_handler);
              this.first = div;
            },
            m(target, anchor) {
              insert2(target, div, anchor);
              if_blocks[current_block_type_index].m(div, null);
              dragCopy_action = dragCopy.call(null, div, ctx.allowColumnReordering) || {};
              insert2(target, t, anchor);
              if (if_block1)
                if_block1.m(target, anchor);
              insert2(target, if_block1_anchor, anchor);
              current = true;
            },
            p(changed, new_ctx) {
              ctx = new_ctx;
              var previous_block_index = current_block_type_index;
              current_block_type_index = select_block_type(changed, ctx);
              if (current_block_type_index === previous_block_index) {
                if_blocks[current_block_type_index].p(changed, ctx);
              } else {
                group_outros2();
                transition_out2(if_blocks[previous_block_index], 1, 1, () => {
                  if_blocks[previous_block_index] = null;
                });
                check_outros2();
                if_block0 = if_blocks[current_block_type_index];
                if (!if_block0) {
                  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
                  if_block0.c();
                }
                transition_in2(if_block0, 1);
                if_block0.m(div, null);
              }
              if (!current || changed.__affixedColumnIndices || changed.columns) {
                set_style2(div, "z-index", ctx.getCellZIndex(ctx.__affixedColumnIndices, ctx.i));
              }
              if (!current || changed.columns || changed.columnWidths || changed.__affixedColumnIndices || changed.__scrollLeft) {
                set_style2(div, "left", "" + getCellLeft({ i: ctx.i, columnWidths: ctx.columnWidths, __affixedColumnIndices: ctx.__affixedColumnIndices, __scrollLeft: ctx.__scrollLeft }) + "px");
              }
              if (!current || changed.columnWidths || changed.columns) {
                set_style2(div, "width", "" + ctx.columnWidths[ctx.i] + "px");
              }
              if (!current || changed.rowHeight) {
                set_style2(div, "height", "" + ctx.rowHeight + "px");
                set_style2(div, "line-height", "" + ctx.rowHeight + "px");
              }
              if ((!current || changed.columns) && div_title_value !== (div_title_value = ctx.column.display || "")) {
                attr2(div, "title", div_title_value);
              }
              if (typeof dragCopy_action.update === "function" && changed.allowColumnReordering) {
                dragCopy_action.update.call(null, ctx.allowColumnReordering);
              }
              if (ctx.allowResizeFromTableHeaders && !ctx.column.disallowResize) {
                if (if_block1) {
                  if_block1.p(changed, ctx);
                } else {
                  if_block1 = create_if_block_42(ctx);
                  if_block1.c();
                  if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
                }
              } else if (if_block1) {
                if_block1.d(1);
                if_block1 = null;
              }
            },
            i(local) {
              if (current)
                return;
              transition_in2(if_block0);
              current = true;
            },
            o(local) {
              transition_out2(if_block0);
              current = false;
            },
            d(detaching) {
              if (detaching) {
                detach2(div);
              }
              if_blocks[current_block_type_index].d();
              if (dragCopy_action && typeof dragCopy_action.destroy === "function")
                dragCopy_action.destroy();
              if (detaching) {
                detach2(t);
              }
              if (if_block1)
                if_block1.d(detaching);
              if (detaching) {
                detach2(if_block1_anchor);
              }
              dispose();
            }
          };
        }
        function create_if_block_33(ctx) {
          var div, dispose;
          return {
            c() {
              div = element2("div");
              attr2(div, "class", "column-affix-marker svelte-b58rik");
              set_style2(div, "left", "" + ctx.columnAffixLineLeft + "px");
              set_style2(div, "height", "" + ctx.gridSpaceHeight + "px");
              dispose = listen2(div, "mousedown", ctx.onColumnAffixStart);
            },
            m(target, anchor) {
              insert2(target, div, anchor);
            },
            p(changed, ctx2) {
              if (changed.columnAffixLineLeft) {
                set_style2(div, "left", "" + ctx2.columnAffixLineLeft + "px");
              }
              if (changed.gridSpaceHeight) {
                set_style2(div, "height", "" + ctx2.gridSpaceHeight + "px");
              }
            },
            d(detaching) {
              if (detaching) {
                detach2(div);
              }
              dispose();
            }
          };
        }
        function create_if_block_17(ctx) {
          var each_1_anchor;
          let each_value_2 = ctx.columns;
          let each_blocks = [];
          for (let i = 0; i < each_value_2.length; i += 1) {
            each_blocks[i] = create_each_block_23(get_each_context_23(ctx, each_value_2, i));
          }
          return {
            c() {
              for (let i = 0; i < each_blocks.length; i += 1) {
                each_blocks[i].c();
              }
              each_1_anchor = empty2();
            },
            m(target, anchor) {
              for (let i = 0; i < each_blocks.length; i += 1) {
                each_blocks[i].m(target, anchor);
              }
              insert2(target, each_1_anchor, anchor);
            },
            p(changed, ctx2) {
              if (changed.columns || changed.getCellLeft || changed.columnWidths || changed.__affixedColumnIndices || changed.__scrollLeft || changed.Math || changed.__columnHeaderResizeCaptureWidth) {
                each_value_2 = ctx2.columns;
                let i;
                for (i = 0; i < each_value_2.length; i += 1) {
                  const child_ctx = get_each_context_23(ctx2, each_value_2, i);
                  if (each_blocks[i]) {
                    each_blocks[i].p(changed, child_ctx);
                  } else {
                    each_blocks[i] = create_each_block_23(child_ctx);
                    each_blocks[i].c();
                    each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
                  }
                }
                for (; i < each_blocks.length; i += 1) {
                  each_blocks[i].d(1);
                }
                each_blocks.length = each_value_2.length;
              }
            },
            d(detaching) {
              destroy_each2(each_blocks, detaching);
              if (detaching) {
                detach2(each_1_anchor);
              }
            }
          };
        }
        function create_if_block_25(ctx) {
          var div, dispose;
          function mousedown_handler_2(...args) {
            return ctx.mousedown_handler_2(ctx, ...args);
          }
          return {
            c() {
              div = element2("div");
              attr2(div, "class", "grid-cell-size-capture svelte-b58rik");
              set_style2(div, "left", "" + (getCellLeft({
                i: ctx.i + 1,
                columnWidths: ctx.columnWidths,
                __affixedColumnIndices: ctx.__affixedColumnIndices,
                __scrollLeft: ctx.__scrollLeft
              }) - ctx.Math.floor(ctx.__columnHeaderResizeCaptureWidth / 2)) + "px");
              set_style2(div, "width", "" + ctx.__columnHeaderResizeCaptureWidth + "px");
              dispose = listen2(div, "mousedown", mousedown_handler_2);
            },
            m(target, anchor) {
              insert2(target, div, anchor);
            },
            p(changed, new_ctx) {
              ctx = new_ctx;
              if (changed.columnWidths || changed.__affixedColumnIndices || changed.__scrollLeft || changed.__columnHeaderResizeCaptureWidth) {
                set_style2(div, "left", "" + (getCellLeft({
                  i: ctx.i + 1,
                  columnWidths: ctx.columnWidths,
                  __affixedColumnIndices: ctx.__affixedColumnIndices,
                  __scrollLeft: ctx.__scrollLeft
                }) - ctx.Math.floor(ctx.__columnHeaderResizeCaptureWidth / 2)) + "px");
              }
              if (changed.__columnHeaderResizeCaptureWidth) {
                set_style2(div, "width", "" + ctx.__columnHeaderResizeCaptureWidth + "px");
              }
            },
            d(detaching) {
              if (detaching) {
                detach2(div);
              }
              dispose();
            }
          };
        }
        function create_each_block_23(ctx) {
          var if_block_anchor;
          var if_block = !ctx.column.disallowResize && create_if_block_25(ctx);
          return {
            c() {
              if (if_block)
                if_block.c();
              if_block_anchor = empty2();
            },
            m(target, anchor) {
              if (if_block)
                if_block.m(target, anchor);
              insert2(target, if_block_anchor, anchor);
            },
            p(changed, ctx2) {
              if (!ctx2.column.disallowResize) {
                if (if_block) {
                  if_block.p(changed, ctx2);
                } else {
                  if_block = create_if_block_25(ctx2);
                  if_block.c();
                  if_block.m(if_block_anchor.parentNode, if_block_anchor);
                }
              } else if (if_block) {
                if_block.d(1);
                if_block = null;
              }
            },
            d(detaching) {
              if (if_block)
                if_block.d(detaching);
              if (detaching) {
                detach2(if_block_anchor);
              }
            }
          };
        }
        function create_else_block8(ctx) {
          var div, t_value = ctx.row.data[ctx.column.dataName] || "", t;
          return {
            c() {
              div = element2("div");
              t = text2(t_value);
              attr2(div, "class", "cell-default svelte-b58rik");
            },
            m(target, anchor) {
              insert2(target, div, anchor);
              append2(div, t);
            },
            p(changed, ctx2) {
              if ((changed.visibleRows || changed.columns) && t_value !== (t_value = ctx2.row.data[ctx2.column.dataName] || "")) {
                set_data2(t, t_value);
              }
            },
            i: noop2,
            o: noop2,
            d(detaching) {
              if (detaching) {
                detach2(div);
              }
            }
          };
        }
        function create_if_block64(ctx) {
          var switch_instance_anchor, current;
          var switch_value = ctx.column.cellComponent;
          function switch_props(ctx2) {
            return {
              props: {
                rowNumber: ctx2.row.i,
                column: ctx2.column,
                row: ctx2.row
              }
            };
          }
          if (switch_value) {
            var switch_instance = new switch_value(switch_props(ctx));
            switch_instance.$on("valueupdate", ctx.onCellUpdated);
          }
          return {
            c() {
              if (switch_instance)
                switch_instance.$$.fragment.c();
              switch_instance_anchor = empty2();
            },
            m(target, anchor) {
              if (switch_instance) {
                mount_component2(switch_instance, target, anchor);
              }
              insert2(target, switch_instance_anchor, anchor);
              current = true;
            },
            p(changed, ctx2) {
              var switch_instance_changes = {};
              if (changed.visibleRows)
                switch_instance_changes.rowNumber = ctx2.row.i;
              if (changed.columns)
                switch_instance_changes.column = ctx2.column;
              if (changed.visibleRows)
                switch_instance_changes.row = ctx2.row;
              if (switch_value !== (switch_value = ctx2.column.cellComponent)) {
                if (switch_instance) {
                  group_outros2();
                  const old_component = switch_instance;
                  transition_out2(old_component.$$.fragment, 1, 0, () => {
                    destroy_component2(old_component, 1);
                  });
                  check_outros2();
                }
                if (switch_value) {
                  switch_instance = new switch_value(switch_props(ctx2));
                  switch_instance.$on("valueupdate", ctx2.onCellUpdated);
                  switch_instance.$$.fragment.c();
                  transition_in2(switch_instance.$$.fragment, 1);
                  mount_component2(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
                } else {
                  switch_instance = null;
                }
              } else if (switch_value) {
                switch_instance.$set(switch_instance_changes);
              }
            },
            i(local) {
              if (current)
                return;
              if (switch_instance)
                transition_in2(switch_instance.$$.fragment, local);
              current = true;
            },
            o(local) {
              if (switch_instance)
                transition_out2(switch_instance.$$.fragment, local);
              current = false;
            },
            d(detaching) {
              if (detaching) {
                detach2(switch_instance_anchor);
              }
              if (switch_instance)
                destroy_component2(switch_instance, detaching);
            }
          };
        }
        function create_each_block_14(ctx) {
          var div, current_block_type_index, if_block, current;
          var if_block_creators = [
            create_if_block64,
            create_else_block8
          ];
          var if_blocks = [];
          function select_block_type_1(changed, ctx2) {
            if (ctx2.column.cellComponent)
              return 0;
            return 1;
          }
          current_block_type_index = select_block_type_1(null, ctx);
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          return {
            c() {
              div = element2("div");
              if_block.c();
              attr2(div, "class", "grid-cell svelte-b58rik");
              set_style2(div, "z-index", ctx.getCellZIndex(ctx.__affixedColumnIndices, ctx.j));
              set_style2(div, "left", "" + getCellLeft({ i: ctx.j, columnWidths: ctx.columnWidths, __affixedColumnIndices: ctx.__affixedColumnIndices, __scrollLeft: ctx.__scrollLeft }) + "px");
              set_style2(div, "height", "" + ctx.rowHeight + "px");
              set_style2(div, "line-height", "" + ctx.rowHeight + "px");
              set_style2(div, "width", "" + ctx.columnWidths[ctx.j] + "px");
              attr2(div, "role", "cell");
            },
            m(target, anchor) {
              insert2(target, div, anchor);
              if_blocks[current_block_type_index].m(div, null);
              current = true;
            },
            p(changed, ctx2) {
              var previous_block_index = current_block_type_index;
              current_block_type_index = select_block_type_1(changed, ctx2);
              if (current_block_type_index === previous_block_index) {
                if_blocks[current_block_type_index].p(changed, ctx2);
              } else {
                group_outros2();
                transition_out2(if_blocks[previous_block_index], 1, 1, () => {
                  if_blocks[previous_block_index] = null;
                });
                check_outros2();
                if_block = if_blocks[current_block_type_index];
                if (!if_block) {
                  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
                  if_block.c();
                }
                transition_in2(if_block, 1);
                if_block.m(div, null);
              }
              if (!current || changed.__affixedColumnIndices) {
                set_style2(div, "z-index", ctx2.getCellZIndex(ctx2.__affixedColumnIndices, ctx2.j));
              }
              if (!current || changed.columnWidths || changed.__affixedColumnIndices || changed.__scrollLeft) {
                set_style2(div, "left", "" + getCellLeft({ i: ctx2.j, columnWidths: ctx2.columnWidths, __affixedColumnIndices: ctx2.__affixedColumnIndices, __scrollLeft: ctx2.__scrollLeft }) + "px");
              }
              if (!current || changed.rowHeight) {
                set_style2(div, "height", "" + ctx2.rowHeight + "px");
                set_style2(div, "line-height", "" + ctx2.rowHeight + "px");
              }
              if (!current || changed.columnWidths) {
                set_style2(div, "width", "" + ctx2.columnWidths[ctx2.j] + "px");
              }
            },
            i(local) {
              if (current)
                return;
              transition_in2(if_block);
              current = true;
            },
            o(local) {
              transition_out2(if_block);
              current = false;
            },
            d(detaching) {
              if (detaching) {
                detach2(div);
              }
              if_blocks[current_block_type_index].d();
            }
          };
        }
        function create_each_block12(ctx) {
          var div, t, div_aria_rowindex_value, current;
          let each_value_1 = ctx.columns;
          let each_blocks = [];
          for (let i_1 = 0; i_1 < each_value_1.length; i_1 += 1) {
            each_blocks[i_1] = create_each_block_14(get_each_context_14(ctx, each_value_1, i_1));
          }
          const out = (i) => transition_out2(each_blocks[i], 1, 1, () => {
            each_blocks[i] = null;
          });
          return {
            c() {
              div = element2("div");
              for (let i_1 = 0; i_1 < each_blocks.length; i_1 += 1) {
                each_blocks[i_1].c();
              }
              t = space2();
              attr2(div, "class", "grid-row svelte-b58rik");
              set_style2(div, "top", "" + ctx.getRowTop(ctx.row.i, ctx.rowHeight) + "px");
              set_style2(div, "height", "" + ctx.rowHeight + "px");
              set_style2(div, "width", "" + ctx.gridSpaceWidth + "px");
              attr2(div, "role", "row");
              attr2(div, "aria-rowindex", div_aria_rowindex_value = ctx.row.i);
            },
            m(target, anchor) {
              insert2(target, div, anchor);
              for (let i_1 = 0; i_1 < each_blocks.length; i_1 += 1) {
                each_blocks[i_1].m(div, null);
              }
              append2(div, t);
              current = true;
            },
            p(changed, ctx2) {
              if (changed.getCellZIndex || changed.__affixedColumnIndices || changed.getCellLeft || changed.columnWidths || changed.__scrollLeft || changed.rowHeight || changed.columns || changed.visibleRows) {
                each_value_1 = ctx2.columns;
                let i_1;
                for (i_1 = 0; i_1 < each_value_1.length; i_1 += 1) {
                  const child_ctx = get_each_context_14(ctx2, each_value_1, i_1);
                  if (each_blocks[i_1]) {
                    each_blocks[i_1].p(changed, child_ctx);
                    transition_in2(each_blocks[i_1], 1);
                  } else {
                    each_blocks[i_1] = create_each_block_14(child_ctx);
                    each_blocks[i_1].c();
                    transition_in2(each_blocks[i_1], 1);
                    each_blocks[i_1].m(div, t);
                  }
                }
                group_outros2();
                for (i_1 = each_value_1.length; i_1 < each_blocks.length; i_1 += 1) {
                  out(i_1);
                }
                check_outros2();
              }
              if (!current || changed.visibleRows || changed.rowHeight) {
                set_style2(div, "top", "" + ctx2.getRowTop(ctx2.row.i, ctx2.rowHeight) + "px");
              }
              if (!current || changed.rowHeight) {
                set_style2(div, "height", "" + ctx2.rowHeight + "px");
              }
              if (!current || changed.gridSpaceWidth) {
                set_style2(div, "width", "" + ctx2.gridSpaceWidth + "px");
              }
              if ((!current || changed.visibleRows) && div_aria_rowindex_value !== (div_aria_rowindex_value = ctx2.row.i)) {
                attr2(div, "aria-rowindex", div_aria_rowindex_value);
              }
            },
            i(local) {
              if (current)
                return;
              for (let i_1 = 0; i_1 < each_value_1.length; i_1 += 1) {
                transition_in2(each_blocks[i_1]);
              }
              current = true;
            },
            o(local) {
              each_blocks = each_blocks.filter(Boolean);
              for (let i_1 = 0; i_1 < each_blocks.length; i_1 += 1) {
                transition_out2(each_blocks[i_1]);
              }
              current = false;
            },
            d(detaching) {
              if (detaching) {
                detach2(div);
              }
              destroy_each2(each_blocks, detaching);
            }
          };
        }
        function create_fragment88(ctx) {
          var div5, t0, t1, div1, div0, each_blocks_1 = [], each0_lookup = new Map(), t2, div4, t3, div2, t4, div3, t5, div4_resize_listener, div5_class_value, current, dispose;
          var if_block0 = (ctx.__resizing || ctx.__columnDragging || ctx.__affixingColumn) && create_if_block_72(ctx);
          var if_block1 = ctx.__affixingRow && create_if_block_62(ctx);
          let each_value_3 = ctx.columns;
          const get_key = (ctx2) => ctx2.i;
          for (let i = 0; i < each_value_3.length; i += 1) {
            let child_ctx = get_each_context_3(ctx, each_value_3, i);
            let key = get_key(child_ctx);
            each0_lookup.set(key, each_blocks_1[i] = create_each_block_3(key, child_ctx));
          }
          var if_block2 = ctx.allowColumnAffix && create_if_block_33(ctx);
          var if_block3 = ctx.allowResizeFromTableCells && create_if_block_17(ctx);
          let each_value = ctx.visibleRows;
          let each_blocks = [];
          for (let i = 0; i < each_value.length; i += 1) {
            each_blocks[i] = create_each_block12(get_each_context12(ctx, each_value, i));
          }
          const out = (i) => transition_out2(each_blocks[i], 1, 1, () => {
            each_blocks[i] = null;
          });
          return {
            c() {
              div5 = element2("div");
              if (if_block0)
                if_block0.c();
              t0 = space2();
              if (if_block1)
                if_block1.c();
              t1 = space2();
              div1 = element2("div");
              div0 = element2("div");
              for (let i = 0; i < each_blocks_1.length; i += 1) {
                each_blocks_1[i].c();
              }
              t2 = space2();
              div4 = element2("div");
              if (if_block2)
                if_block2.c();
              t3 = space2();
              div2 = element2("div");
              t4 = space2();
              div3 = element2("div");
              if (if_block3)
                if_block3.c();
              t5 = space2();
              for (let i = 0; i < each_blocks.length; i += 1) {
                each_blocks[i].c();
              }
              attr2(div0, "class", "grid-header-row svelte-b58rik");
              set_style2(div0, "left", "-" + ctx.__scrollLeft + "px");
              set_style2(div0, "height", "" + ctx.rowHeight + "px");
              set_style2(div0, "width", "" + ctx.gridSpaceWidth + "px");
              attr2(div0, "role", "row");
              attr2(div1, "class", "grid-headers svelte-b58rik");
              set_style2(div1, "height", "" + ctx.rowHeight + "px");
              attr2(div1, "rolw", "rowgroup");
              attr2(div2, "class", "row-affix-marker svelte-b58rik");
              set_style2(div2, "top", "" + ctx.__rowAffixLineTop + "px");
              set_style2(div2, "width", "" + ctx.gridSpaceWidth + "px");
              attr2(div3, "class", "grid-space svelte-b58rik");
              set_style2(div3, "width", "" + ctx.gridSpaceWidth + "px");
              set_style2(div3, "height", "" + ctx.gridSpaceHeight + "px");
              add_render_callback2(() => ctx.div4_resize_handler.call(div4));
              attr2(div4, "class", "grid-inner svelte-b58rik");
              set_style2(div4, "height", "100%");
              attr2(div4, "role", "rowgroup");
              attr2(div5, "class", div5_class_value = "data-grid-wrapper " + (ctx.__resizing || ctx.__columnDragging ? "resizing" : "") + " svelte-b58rik");
              set_style2(div5, "padding-top", "" + ctx.rowHeight + "px");
              attr2(div5, "role", "table");
              dispose = [
                listen2(window_1, "mouseup", ctx.onMouseUp),
                listen2(window_1, "mousemove", ctx.onMouseMove),
                listen2(window_1, "keydown", ctx.onWindowKeyDown),
                listen2(div2, "mousedown", ctx.onRowAffixStart),
                listen2(div4, "scroll", ctx.onScroll)
              ];
            },
            m(target, anchor) {
              insert2(target, div5, anchor);
              if (if_block0)
                if_block0.m(div5, null);
              append2(div5, t0);
              if (if_block1)
                if_block1.m(div5, null);
              append2(div5, t1);
              append2(div5, div1);
              append2(div1, div0);
              for (let i = 0; i < each_blocks_1.length; i += 1) {
                each_blocks_1[i].m(div0, null);
              }
              append2(div5, t2);
              append2(div5, div4);
              if (if_block2)
                if_block2.m(div4, null);
              append2(div4, t3);
              append2(div4, div2);
              append2(div4, t4);
              append2(div4, div3);
              if (if_block3)
                if_block3.m(div3, null);
              append2(div4, t5);
              for (let i = 0; i < each_blocks.length; i += 1) {
                each_blocks[i].m(div4, null);
              }
              div4_resize_listener = add_resize_listener2(div4, ctx.div4_resize_handler.bind(div4));
              ctx.div4_binding(div4);
              ctx.div5_binding(div5);
              current = true;
            },
            p(changed, ctx2) {
              if (ctx2.__resizing || ctx2.__columnDragging || ctx2.__affixingColumn) {
                if (if_block0) {
                  if_block0.p(changed, ctx2);
                } else {
                  if_block0 = create_if_block_72(ctx2);
                  if_block0.c();
                  if_block0.m(div5, t0);
                }
              } else if (if_block0) {
                if_block0.d(1);
                if_block0 = null;
              }
              if (ctx2.__affixingRow) {
                if (if_block1) {
                  if_block1.p(changed, ctx2);
                } else {
                  if_block1 = create_if_block_62(ctx2);
                  if_block1.c();
                  if_block1.m(div5, t1);
                }
              } else if (if_block1) {
                if_block1.d(1);
                if_block1 = null;
              }
              const each_value_32 = ctx2.columns;
              group_outros2();
              each_blocks_1 = update_keyed_each2(each_blocks_1, changed, get_key, 1, ctx2, each_value_32, each0_lookup, div0, outro_and_destroy_block2, create_each_block_3, null, get_each_context_3);
              check_outros2();
              if (!current || changed.__scrollLeft) {
                set_style2(div0, "left", "-" + ctx2.__scrollLeft + "px");
              }
              if (!current || changed.rowHeight) {
                set_style2(div0, "height", "" + ctx2.rowHeight + "px");
              }
              if (!current || changed.gridSpaceWidth) {
                set_style2(div0, "width", "" + ctx2.gridSpaceWidth + "px");
              }
              if (!current || changed.rowHeight) {
                set_style2(div1, "height", "" + ctx2.rowHeight + "px");
              }
              if (ctx2.allowColumnAffix) {
                if (if_block2) {
                  if_block2.p(changed, ctx2);
                } else {
                  if_block2 = create_if_block_33(ctx2);
                  if_block2.c();
                  if_block2.m(div4, t3);
                }
              } else if (if_block2) {
                if_block2.d(1);
                if_block2 = null;
              }
              if (!current || changed.__rowAffixLineTop) {
                set_style2(div2, "top", "" + ctx2.__rowAffixLineTop + "px");
              }
              if (!current || changed.gridSpaceWidth) {
                set_style2(div2, "width", "" + ctx2.gridSpaceWidth + "px");
              }
              if (ctx2.allowResizeFromTableCells) {
                if (if_block3) {
                  if_block3.p(changed, ctx2);
                } else {
                  if_block3 = create_if_block_17(ctx2);
                  if_block3.c();
                  if_block3.m(div3, null);
                }
              } else if (if_block3) {
                if_block3.d(1);
                if_block3 = null;
              }
              if (!current || changed.gridSpaceWidth) {
                set_style2(div3, "width", "" + ctx2.gridSpaceWidth + "px");
              }
              if (!current || changed.gridSpaceHeight) {
                set_style2(div3, "height", "" + ctx2.gridSpaceHeight + "px");
              }
              if (changed.getRowTop || changed.visibleRows || changed.rowHeight || changed.gridSpaceWidth || changed.columns || changed.getCellZIndex || changed.__affixedColumnIndices || changed.getCellLeft || changed.columnWidths || changed.__scrollLeft) {
                each_value = ctx2.visibleRows;
                let i;
                for (i = 0; i < each_value.length; i += 1) {
                  const child_ctx = get_each_context12(ctx2, each_value, i);
                  if (each_blocks[i]) {
                    each_blocks[i].p(changed, child_ctx);
                    transition_in2(each_blocks[i], 1);
                  } else {
                    each_blocks[i] = create_each_block12(child_ctx);
                    each_blocks[i].c();
                    transition_in2(each_blocks[i], 1);
                    each_blocks[i].m(div4, null);
                  }
                }
                group_outros2();
                for (i = each_value.length; i < each_blocks.length; i += 1) {
                  out(i);
                }
                check_outros2();
              }
              if ((!current || changed.__resizing || changed.__columnDragging) && div5_class_value !== (div5_class_value = "data-grid-wrapper " + (ctx2.__resizing || ctx2.__columnDragging ? "resizing" : "") + " svelte-b58rik")) {
                attr2(div5, "class", div5_class_value);
              }
              if (!current || changed.rowHeight) {
                set_style2(div5, "padding-top", "" + ctx2.rowHeight + "px");
              }
            },
            i(local) {
              if (current)
                return;
              for (let i = 0; i < each_value_3.length; i += 1) {
                transition_in2(each_blocks_1[i]);
              }
              for (let i = 0; i < each_value.length; i += 1) {
                transition_in2(each_blocks[i]);
              }
              current = true;
            },
            o(local) {
              for (let i = 0; i < each_blocks_1.length; i += 1) {
                transition_out2(each_blocks_1[i]);
              }
              each_blocks = each_blocks.filter(Boolean);
              for (let i = 0; i < each_blocks.length; i += 1) {
                transition_out2(each_blocks[i]);
              }
              current = false;
            },
            d(detaching) {
              if (detaching) {
                detach2(div5);
              }
              if (if_block0)
                if_block0.d();
              if (if_block1)
                if_block1.d();
              for (let i = 0; i < each_blocks_1.length; i += 1) {
                each_blocks_1[i].d();
              }
              if (if_block2)
                if_block2.d();
              if (if_block3)
                if_block3.d();
              destroy_each2(each_blocks, detaching);
              div4_resize_listener.cancel();
              ctx.div4_binding(null);
              ctx.div5_binding(null);
              run_all2(dispose);
            }
          };
        }
        const MIN_COLUMN_SIZE = 30;
        function getCellLeft({
          i,
          columnWidths,
          __affixedColumnIndices,
          __scrollLeft
        }) {
          if (__affixedColumnIndices.indexOf(i) >= 0) {
            if (i === 0) {
              return __scrollLeft;
            }
            let left2 = __scrollLeft;
            for (let j = i - 1; j >= 0; j--) {
              left2 += columnWidths[j];
            }
            return left2;
          }
          let left = 0;
          for (let j = 0; j < i; j++) {
            left += columnWidths[j];
          }
          return left;
        }
        function getClosestIndex(x, columnWidths, __affixedColumnIndices, __scrollLeft) {
          let closest = 0;
          for (let i = 0; i < columnWidths.length; i++) {
            const left = getCellLeft({ i, columnWidths, __affixedColumnIndices, __scrollLeft }) + Math.floor(columnWidths[i] / 2);
            if (left < x) {
              closest = i + 1;
            }
          }
          if (__affixedColumnIndices.length > 0) {
            const firstAffixedLeft = getCellLeft({
              i: __affixedColumnIndices[0],
              columnWidths,
              __affixedColumnIndices,
              __scrollLeft
            });
            const lastAffixedLeft = getCellLeft({
              i: __affixedColumnIndices[__affixedColumnIndices.length - 1],
              columnWidths,
              __affixedColumnIndices,
              __scrollLeft
            });
            const lastAffixedRight = lastAffixedLeft + columnWidths[__affixedColumnIndices[__affixedColumnIndices.length - 1]];
            const closestLeft = getCellLeft({
              i: closest,
              columnWidths,
              __affixedColumnIndices,
              __scrollLeft
            });
            if (closestLeft > firstAffixedLeft && closestLeft < lastAffixedRight) {
              if (closestLeft < lastAffixedRight && closestLeft > lastAffixedLeft) {
                closest = __affixedColumnIndices[__affixedColumnIndices.length - 1];
              } else {
                for (let i = 0; i < __affixedColumnIndices.length; i++) {
                  const left = getCellLeft({
                    i: __affixedColumnIndices[i],
                    columnWidths,
                    __affixedColumnIndices,
                    __scrollLeft
                  }) + Math.floor(columnWidths[__affixedColumnIndices[i]] / 2);
                  if (left < x) {
                    closest = __affixedColumnIndices[i] + 1;
                  }
                }
              }
            }
          }
          return closest;
        }
        function getBodyScrollTop() {
          return window.pageYOffset || (document.documentElement.clientHeight ? document.documentElement.scrollTop : document.body.scrollTop);
        }
        function dragCopy(node, enabled) {
          let copy = null;
          let dragging = false;
          let offsetX = 0;
          function onWindowMouseMove(event) {
            if (!dragging) {
              return;
            }
            copy.style.left = event.pageX - offsetX + "px";
          }
          function onWindowMouseUp(event) {
            if (!dragging || event.which !== 1) {
              return;
            }
            dragging = false;
            document.body.removeChild(copy);
            copy = null;
          }
          function onNodeMouseDown(event) {
            if (event.which !== 1) {
              return;
            }
            dragging = true;
            if (copy) {
              document.body.removeChild(copy);
            }
            copy = createCopy();
            offsetX = event.offsetX;
            copy.style.top = node.getBoundingClientRect().top + getBodyScrollTop() + "px";
            copy.style.left = event.pageX - offsetX + "px";
            document.body.appendChild(copy);
          }
          function createCopy() {
            const copy2 = document.createElement("div");
            copy2.innerHTML = node.innerHTML;
            const { width, height, textAlign, fontWeight } = getComputedStyle(node);
            copy2.style.width = width;
            copy2.style.height = height;
            copy2.style.maxHeight = height;
            copy2.style.textAlign = textAlign;
            copy2.style.fontWeight = fontWeight;
            copy2.style.position = "absolute";
            copy2.style.opacity = "0.5";
            copy2.style.pointerEvents = "none";
            copy2.style.overflow = "hidden";
            copy2.style.background = "#dddddd";
            copy2.style["z-index"] = "99999";
            return copy2;
          }
          function attachEvents() {
            window.addEventListener("mousemove", onWindowMouseMove);
            window.addEventListener("mouseup", onWindowMouseUp);
            node.addEventListener("mousedown", onNodeMouseDown);
          }
          function detachEvents() {
            window.removeEventListener("mousemove", onWindowMouseMove);
            window.removeEventListener("mouseup", onWindowMouseUp);
            node.removeEventListener("mousedown", onNodeMouseDown);
          }
          if (enabled) {
            attachEvents();
          }
          return {
            destroy() {
              detachEvents();
            },
            update(enabled2) {
              if (enabled2) {
                attachEvents();
              } else {
                detachEvents();
              }
            }
          };
        }
        function instance86($$self, $$props, $$invalidate) {
          const dispatch = createEventDispatcher2();
          let wrapper;
          let tableSpace;
          let editHistory = null;
          let { rows: rows2 = [], columns: columns2 = [], rowHeight = 24, allowResizeFromTableCells = false, allowResizeFromTableHeaders = true, allowColumnReordering = true, allowColumnAffix = true, __extraRows = 0, __columnHeaderResizeCaptureWidth = 20, __affixedRowIndices = [], __affixedColumnIndices = [], __affixingRow = false, __affixingColumn = false, __rowActionLineTop = 0, __rowAffixLineTop = 0, __columnAffixLineLeft = 0, __columnDragging = false, __columnIndexBeingDragged = null, __columnDragOffsetX = 0, __resizing = false, __columnIndexBeingResized = null, __columnActionLineLeft = 0, __innerOffsetHeight = 0, __scrollTop = 0, __scrollLeft = 0, __scrolledAllTheWayToTheRight = false } = $$props;
          onMount2(() => {
            editHistory = new EditHistory(rows2);
          });
          function onWindowKeyDown(event) {
            if (event.ctrlKey) {
              if (event.keyCode === 90) {
                undo();
                event.preventDefault();
              }
              if (event.keyCode === 89) {
                redo();
                event.preventDefault();
              }
            }
          }
          function onMouseMove(event) {
            onColumnDragMouseMove(event);
            onColumnResizeMouseMove(event);
            onColumnAffixMouseMove(event);
          }
          function onMouseUp(event) {
            onColumnDragEnd(event);
            onColumnResizeEnd();
            onRowAffixEnd();
            onColumnAffixEnd();
          }
          function onCellUpdated(event) {
            $$invalidate("rows", rows2[event.detail.rowNumber][event.detail.column.dataName] = event.detail.value, rows2);
            dispatch("valueUpdated", event);
          }
          function undo() {
            const eRows = editHistory.undo();
            if (eRows) {
              $$invalidate("rows", rows2 = eRows);
            }
          }
          function redo() {
            const eRows = editHistory.redo();
            if (eRows) {
              $$invalidate("rows", rows2 = eRows);
            }
          }
          function onColumnAffixStart(event) {
            if (event.which !== 1) {
              return;
            }
            if (__affixedColumnIndices.length > 0) {
              $$invalidate("tableSpace", tableSpace.scrollLeft = 0, tableSpace);
              $$invalidate("__affixingColumn", __affixingColumn = true);
            } else {
              $$invalidate("__affixingColumn", __affixingColumn = true);
            }
          }
          function onColumnAffixMouseMove(event) {
            if (!__affixingColumn) {
              return;
            }
            if (event.which !== 1) {
              onColumnAffixEnd();
              return;
            }
            const { left: wrapperPageX } = wrapper.getBoundingClientRect();
            const offsetPoint = event.pageX - wrapperPageX + __scrollLeft;
            const idx = getClosestIndex(offsetPoint, columnWidths, __affixedColumnIndices, __scrollLeft);
            const indices = [];
            for (let i = 0; i < idx; i++) {
              indices.push(i);
            }
            $$invalidate("__columnActionLineLeft", __columnActionLineLeft = offsetPoint);
            $$invalidate("__affixedColumnIndices", __affixedColumnIndices = indices);
            event.preventDefault();
          }
          function onColumnAffixEnd(event) {
            $$invalidate("__affixingColumn", __affixingColumn = false);
          }
          function onRowAffixStart(event) {
            $$invalidate("__affixingRow", __affixingRow = true);
          }
          function onRowAffixEnd(event) {
            $$invalidate("__affixingRow", __affixingRow = false);
          }
          function onColumnDragStart(event, columnIndex) {
            if (event.which !== 1) {
              return;
            }
            if (!allowColumnReordering) {
              return;
            }
            $$invalidate("__columnDragging", __columnDragging = true);
            $$invalidate("__columnIndexBeingDragged", __columnIndexBeingDragged = columnIndex);
            $$invalidate("__columnDragOffsetX", __columnDragOffsetX = event.offsetX);
            $$invalidate("__columnActionLineLeft", __columnActionLineLeft = getCellLeft({
              i: columnIndex,
              columnWidths,
              __scrollLeft,
              __affixedColumnIndices
            }) - __scrollLeft);
          }
          function onColumnDragMouseMove(event) {
            if (!__columnDragging) {
              return;
            }
            if (event.which !== 1) {
              onColumnDragEnd(event);
              return;
            }
            const { left: wrapperPageX } = wrapper.getBoundingClientRect();
            const offsetPoint = event.pageX - wrapperPageX + __scrollLeft - __columnDragOffsetX;
            const idx = getClosestIndex(offsetPoint, columnWidths, __affixedColumnIndices, __scrollLeft);
            $$invalidate("__columnActionLineLeft", __columnActionLineLeft = getCellLeft({
              i: idx,
              columnWidths,
              __affixedColumnIndices,
              __scrollLeft
            }) - __scrollLeft);
          }
          function onColumnDragEnd(event) {
            if (event.which !== 1) {
              return;
            }
            if (!__columnDragging) {
              return;
            }
            const { left: wrapperPageX } = wrapper.getBoundingClientRect();
            const offsetPoint = event.pageX - wrapperPageX + __scrollLeft - __columnDragOffsetX;
            const newIdx = getClosestIndex(offsetPoint, columnWidths, __affixedColumnIndices, __scrollLeft);
            let mColumns = columns2;
            mColumns.splice(newIdx > __columnIndexBeingDragged ? newIdx - 1 : newIdx, 0, mColumns.splice(__columnIndexBeingDragged, 1)[0]);
            $$invalidate("columns", columns2 = mColumns);
            setTimeout(() => dispatch("columnOrderUpdated"), 0);
            $$invalidate("__columnDragging", __columnDragging = false);
            $$invalidate("__columnDragOffsetX", __columnDragOffsetX = 0);
            $$invalidate("__columnIndexBeingDragged", __columnIndexBeingDragged = null);
          }
          function onColumnResizeStart(event, columnIndex) {
            if (event.which !== 1) {
              return;
            }
            const { left: wrapperPageX } = wrapper.getBoundingClientRect();
            $$invalidate("__resizing", __resizing = true);
            $$invalidate("__columnActionLineLeft", __columnActionLineLeft = event.pageX - wrapperPageX - __scrollLeft);
            $$invalidate("__columnIndexBeingResized", __columnIndexBeingResized = columnIndex);
            event.stopPropagation();
          }
          function onColumnResizeMouseMove(event) {
            if (!__resizing) {
              return;
            }
            const { left: wrapperPageX } = wrapper.getBoundingClientRect();
            const resizeLineLeft = event.pageX - wrapperPageX;
            const columnLeft = getCellLeft({
              i: __columnIndexBeingResized,
              columnWidths,
              __affixedColumnIndices,
              __scrollLeft
            });
            const resizeLineMinLeft = columnLeft - __scrollLeft + MIN_COLUMN_SIZE;
            const newColumnWidth = Math.max(resizeLineLeft + __scrollLeft - columnLeft, MIN_COLUMN_SIZE);
            $$invalidate("columns", columns2[__columnIndexBeingResized].width = newColumnWidth, columns2);
            $$invalidate("__columnActionLineLeft", __columnActionLineLeft = Math.max(resizeLineLeft, resizeLineMinLeft));
            if (event.which !== 1) {
              $$invalidate("__resizing", __resizing = false);
              $$invalidate("__columnIndexBeingResized", __columnIndexBeingResized = null);
              setTimeout(() => dispatch("columnWidthUpdated", {
                idx: __columnIndexBeingResized,
                width: newColumnWidth
              }), 0);
            }
          }
          function onColumnResizeEnd(event) {
            if (!__resizing) {
              return;
            }
            dispatch("columnWidthUpdated");
            $$invalidate("__resizing", __resizing = false);
            $$invalidate("__columnIndexBeingResized", __columnIndexBeingResized = null);
          }
          function onScroll() {
            const { scrollTop: newScrollTop, scrollLeft: newScrollLeft } = tableSpace;
            if (__scrollTop !== newScrollTop) {
              $$invalidate("__scrollTop", __scrollTop = newScrollTop);
            }
            if (__scrollLeft !== newScrollLeft) {
              $$invalidate("__scrollLeft", __scrollLeft = newScrollLeft);
            }
            $$invalidate("__scrolledAllTheWayToTheRight", __scrolledAllTheWayToTheRight = Math.ceil(tableSpace.scrollWidth - tableSpace.scrollLeft) === tableSpace.clientWidth);
          }
          let columnAffixLineLeft = 0;
          let columnWidths = columns2.map((x) => x.width || MIN_COLUMN_SIZE);
          let numRows = rows2.length;
          let gridSpaceWidth = 0;
          let gridSpaceHeight = rowHeight * numRows;
          let numRowsInViewport = Math.ceil(__innerOffsetHeight / rowHeight);
          let visibleRows;
          const getCellZIndex = function(__affixedColumnIndices2, i) {
            return __affixedColumnIndices2.indexOf(i) === -1 ? 1 : 2;
          };
          const getRowTop = function(i, rowHeight2) {
            return i * rowHeight2;
          };
          const mousedown_handler = ({ i }, event) => onColumnDragStart(event, i);
          const mousedown_handler_1 = ({ i }, event) => onColumnResizeStart(event, i);
          const mousedown_handler_2 = ({ i }, event) => onColumnResizeStart(event, i);
          function div4_resize_handler() {
            __innerOffsetHeight = this.offsetHeight;
            $$invalidate("__innerOffsetHeight", __innerOffsetHeight);
          }
          function div4_binding($$value) {
            binding_callbacks2[$$value ? "unshift" : "push"](() => {
              $$invalidate("tableSpace", tableSpace = $$value);
            });
          }
          function div5_binding($$value) {
            binding_callbacks2[$$value ? "unshift" : "push"](() => {
              $$invalidate("wrapper", wrapper = $$value);
            });
          }
          $$self.$set = ($$props2) => {
            if ("rows" in $$props2)
              $$invalidate("rows", rows2 = $$props2.rows);
            if ("columns" in $$props2)
              $$invalidate("columns", columns2 = $$props2.columns);
            if ("rowHeight" in $$props2)
              $$invalidate("rowHeight", rowHeight = $$props2.rowHeight);
            if ("allowResizeFromTableCells" in $$props2)
              $$invalidate("allowResizeFromTableCells", allowResizeFromTableCells = $$props2.allowResizeFromTableCells);
            if ("allowResizeFromTableHeaders" in $$props2)
              $$invalidate("allowResizeFromTableHeaders", allowResizeFromTableHeaders = $$props2.allowResizeFromTableHeaders);
            if ("allowColumnReordering" in $$props2)
              $$invalidate("allowColumnReordering", allowColumnReordering = $$props2.allowColumnReordering);
            if ("allowColumnAffix" in $$props2)
              $$invalidate("allowColumnAffix", allowColumnAffix = $$props2.allowColumnAffix);
            if ("__extraRows" in $$props2)
              $$invalidate("__extraRows", __extraRows = $$props2.__extraRows);
            if ("__columnHeaderResizeCaptureWidth" in $$props2)
              $$invalidate("__columnHeaderResizeCaptureWidth", __columnHeaderResizeCaptureWidth = $$props2.__columnHeaderResizeCaptureWidth);
            if ("__affixedRowIndices" in $$props2)
              $$invalidate("__affixedRowIndices", __affixedRowIndices = $$props2.__affixedRowIndices);
            if ("__affixedColumnIndices" in $$props2)
              $$invalidate("__affixedColumnIndices", __affixedColumnIndices = $$props2.__affixedColumnIndices);
            if ("__affixingRow" in $$props2)
              $$invalidate("__affixingRow", __affixingRow = $$props2.__affixingRow);
            if ("__affixingColumn" in $$props2)
              $$invalidate("__affixingColumn", __affixingColumn = $$props2.__affixingColumn);
            if ("__rowActionLineTop" in $$props2)
              $$invalidate("__rowActionLineTop", __rowActionLineTop = $$props2.__rowActionLineTop);
            if ("__rowAffixLineTop" in $$props2)
              $$invalidate("__rowAffixLineTop", __rowAffixLineTop = $$props2.__rowAffixLineTop);
            if ("__columnAffixLineLeft" in $$props2)
              $$invalidate("__columnAffixLineLeft", __columnAffixLineLeft = $$props2.__columnAffixLineLeft);
            if ("__columnDragging" in $$props2)
              $$invalidate("__columnDragging", __columnDragging = $$props2.__columnDragging);
            if ("__columnIndexBeingDragged" in $$props2)
              $$invalidate("__columnIndexBeingDragged", __columnIndexBeingDragged = $$props2.__columnIndexBeingDragged);
            if ("__columnDragOffsetX" in $$props2)
              $$invalidate("__columnDragOffsetX", __columnDragOffsetX = $$props2.__columnDragOffsetX);
            if ("__resizing" in $$props2)
              $$invalidate("__resizing", __resizing = $$props2.__resizing);
            if ("__columnIndexBeingResized" in $$props2)
              $$invalidate("__columnIndexBeingResized", __columnIndexBeingResized = $$props2.__columnIndexBeingResized);
            if ("__columnActionLineLeft" in $$props2)
              $$invalidate("__columnActionLineLeft", __columnActionLineLeft = $$props2.__columnActionLineLeft);
            if ("__innerOffsetHeight" in $$props2)
              $$invalidate("__innerOffsetHeight", __innerOffsetHeight = $$props2.__innerOffsetHeight);
            if ("__scrollTop" in $$props2)
              $$invalidate("__scrollTop", __scrollTop = $$props2.__scrollTop);
            if ("__scrollLeft" in $$props2)
              $$invalidate("__scrollLeft", __scrollLeft = $$props2.__scrollLeft);
            if ("__scrolledAllTheWayToTheRight" in $$props2)
              $$invalidate("__scrolledAllTheWayToTheRight", __scrolledAllTheWayToTheRight = $$props2.__scrolledAllTheWayToTheRight);
          };
          $$self.$$.update = ($$dirty = { columns: 1, __affixedColumnIndices: 1, __scrollLeft: 1, columnWidths: 1, rows: 1, __resizing: 1, __scrolledAllTheWayToTheRight: 1, rowHeight: 1, numRows: 1, __innerOffsetHeight: 1, __scrollTop: 1, __extraRows: 1, numRowsInViewport: 1 }) => {
            if ($$dirty.columns) {
              {
                $$invalidate("columnWidths", columnWidths = columns2.map((x) => x.width || MIN_COLUMN_SIZE));
              }
            }
            if ($$dirty.__affixedColumnIndices || $$dirty.__scrollLeft || $$dirty.columnWidths) {
              {
                if (__affixedColumnIndices.length === 0) {
                  $$invalidate("columnAffixLineLeft", columnAffixLineLeft = 0);
                }
                let left = __scrollLeft;
                for (let i = 0; i < __affixedColumnIndices.length; i++) {
                  left += columnWidths[__affixedColumnIndices[i]];
                }
                $$invalidate("columnAffixLineLeft", columnAffixLineLeft = left);
              }
            }
            if ($$dirty.rows) {
              {
                $$invalidate("numRows", numRows = rows2.length);
              }
            }
            if ($$dirty.columnWidths || $$dirty.__resizing || $$dirty.__scrolledAllTheWayToTheRight) {
              {
                let sum = 0;
                for (let i = 0; i < columnWidths.length; i++) {
                  sum += columnWidths[i];
                }
                if (__resizing && __scrolledAllTheWayToTheRight) {
                  sum *= 2;
                }
                $$invalidate("gridSpaceWidth", gridSpaceWidth = sum);
              }
            }
            if ($$dirty.rowHeight || $$dirty.numRows) {
              {
                $$invalidate("gridSpaceHeight", gridSpaceHeight = rowHeight * numRows);
              }
            }
            if ($$dirty.__innerOffsetHeight || $$dirty.rowHeight) {
              {
                $$invalidate("numRowsInViewport", numRowsInViewport = Math.ceil(__innerOffsetHeight / rowHeight));
              }
            }
            if ($$dirty.__scrollTop || $$dirty.rowHeight || $$dirty.__extraRows || $$dirty.numRowsInViewport || $$dirty.rows) {
              {
                const start2 = Math.max(0, Math.floor(__scrollTop / rowHeight - __extraRows / 2));
                const end = start2 + numRowsInViewport + __extraRows;
                $$invalidate("visibleRows", visibleRows = rows2.slice(start2, end).map((x, i) => {
                  return {
                    i: i + start2,
                    data: x
                  };
                }));
              }
            }
          };
          return {
            wrapper,
            tableSpace,
            rows: rows2,
            columns: columns2,
            rowHeight,
            allowResizeFromTableCells,
            allowResizeFromTableHeaders,
            allowColumnReordering,
            allowColumnAffix,
            __extraRows,
            __columnHeaderResizeCaptureWidth,
            __affixedRowIndices,
            __affixedColumnIndices,
            __affixingRow,
            __affixingColumn,
            __rowActionLineTop,
            __rowAffixLineTop,
            __columnAffixLineLeft,
            __columnDragging,
            __columnIndexBeingDragged,
            __columnDragOffsetX,
            __resizing,
            __columnIndexBeingResized,
            __columnActionLineLeft,
            __innerOffsetHeight,
            __scrollTop,
            __scrollLeft,
            __scrolledAllTheWayToTheRight,
            onWindowKeyDown,
            onMouseMove,
            onMouseUp,
            onCellUpdated,
            onColumnAffixStart,
            onRowAffixStart,
            onColumnDragStart,
            onColumnResizeStart,
            onScroll,
            columnAffixLineLeft,
            columnWidths,
            gridSpaceWidth,
            gridSpaceHeight,
            visibleRows,
            getCellZIndex,
            getRowTop,
            Math,
            mousedown_handler,
            mousedown_handler_1,
            mousedown_handler_2,
            div4_resize_handler,
            div4_binding,
            div5_binding
          };
        }
        class Index extends SvelteComponent2 {
          constructor(options) {
            super();
            if (!document_1.getElementById("svelte-b58rik-style"))
              add_css();
            init2(this, options, instance86, create_fragment88, safe_not_equal2, ["rows", "columns", "rowHeight", "allowResizeFromTableCells", "allowResizeFromTableHeaders", "allowColumnReordering", "allowColumnAffix", "__extraRows", "__columnHeaderResizeCaptureWidth", "__affixedRowIndices", "__affixedColumnIndices", "__affixingRow", "__affixingColumn", "__rowActionLineTop", "__rowAffixLineTop", "__columnAffixLineLeft", "__columnDragging", "__columnIndexBeingDragged", "__columnDragOffsetX", "__resizing", "__columnIndexBeingResized", "__columnActionLineLeft", "__innerOffsetHeight", "__scrollTop", "__scrollLeft", "__scrolledAllTheWayToTheRight"]);
          }
        }
        return Index;
      });
    }
  });

  // elos-web/node_modules/debounce/index.js
  var require_debounce = __commonJS({
    "elos-web/node_modules/debounce/index.js"(exports, module) {
      function debounce3(func, wait, immediate) {
        var timeout, args, context, timestamp, result;
        if (wait == null)
          wait = 100;
        function later() {
          var last = Date.now() - timestamp;
          if (last < wait && last >= 0) {
            timeout = setTimeout(later, wait - last);
          } else {
            timeout = null;
            if (!immediate) {
              result = func.apply(context, args);
              context = args = null;
            }
          }
        }
        ;
        var debounced = function() {
          context = this;
          args = arguments;
          timestamp = Date.now();
          var callNow = immediate && !timeout;
          if (!timeout)
            timeout = setTimeout(later, wait);
          if (callNow) {
            result = func.apply(context, args);
            context = args = null;
          }
          return result;
        };
        debounced.clear = function() {
          if (timeout) {
            clearTimeout(timeout);
            timeout = null;
          }
        };
        debounced.flush = function() {
          if (timeout) {
            result = func.apply(context, args);
            context = args = null;
            clearTimeout(timeout);
            timeout = null;
          }
        };
        return debounced;
      }
      debounce3.debounce = debounce3;
      module.exports = debounce3;
    }
  });

  // elos-web/node_modules/svelte/internal/index.mjs
  function noop() {
  }
  function assign(tar, src) {
    for (const k in src)
      tar[k] = src[k];
    return tar;
  }
  function run(fn) {
    return fn();
  }
  function blank_object() {
    return Object.create(null);
  }
  function run_all(fns) {
    fns.forEach(run);
  }
  function is_function(thing) {
    return typeof thing === "function";
  }
  function safe_not_equal(a, b) {
    return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
  }
  var src_url_equal_anchor;
  function src_url_equal(element_src, url) {
    if (!src_url_equal_anchor) {
      src_url_equal_anchor = document.createElement("a");
    }
    src_url_equal_anchor.href = url;
    return element_src === src_url_equal_anchor.href;
  }
  function is_empty(obj) {
    return Object.keys(obj).length === 0;
  }
  function subscribe(store, ...callbacks) {
    if (store == null) {
      return noop;
    }
    const unsub = store.subscribe(...callbacks);
    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
  }
  function get_store_value(store) {
    let value;
    subscribe(store, (_) => value = _)();
    return value;
  }
  function create_slot(definition, ctx, $$scope, fn) {
    if (definition) {
      const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
      return definition[0](slot_ctx);
    }
  }
  function get_slot_context(definition, ctx, $$scope, fn) {
    return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
  }
  function get_slot_changes(definition, $$scope, dirty, fn) {
    if (definition[2] && fn) {
      const lets = definition[2](fn(dirty));
      if ($$scope.dirty === void 0) {
        return lets;
      }
      if (typeof lets === "object") {
        const merged = [];
        const len = Math.max($$scope.dirty.length, lets.length);
        for (let i = 0; i < len; i += 1) {
          merged[i] = $$scope.dirty[i] | lets[i];
        }
        return merged;
      }
      return $$scope.dirty | lets;
    }
    return $$scope.dirty;
  }
  function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
    if (slot_changes) {
      const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
      slot.p(slot_context, slot_changes);
    }
  }
  function get_all_dirty_from_scope($$scope) {
    if ($$scope.ctx.length > 32) {
      const dirty = [];
      const length = $$scope.ctx.length / 32;
      for (let i = 0; i < length; i++) {
        dirty[i] = -1;
      }
      return dirty;
    }
    return -1;
  }
  function exclude_internal_props(props) {
    const result = {};
    for (const k in props)
      if (k[0] !== "$")
        result[k] = props[k];
    return result;
  }
  function compute_rest_props(props, keys) {
    const rest = {};
    keys = new Set(keys);
    for (const k in props)
      if (!keys.has(k) && k[0] !== "$")
        rest[k] = props[k];
    return rest;
  }
  function action_destroyer(action_result) {
    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
  }
  var tasks = new Set();
  var is_hydrating = false;
  function start_hydrating() {
    is_hydrating = true;
  }
  function end_hydrating() {
    is_hydrating = false;
  }
  function append(target, node) {
    target.appendChild(node);
  }
  function insert(target, node, anchor) {
    target.insertBefore(node, anchor || null);
  }
  function detach(node) {
    node.parentNode.removeChild(node);
  }
  function destroy_each(iterations, detaching) {
    for (let i = 0; i < iterations.length; i += 1) {
      if (iterations[i])
        iterations[i].d(detaching);
    }
  }
  function element(name) {
    return document.createElement(name);
  }
  function svg_element(name) {
    return document.createElementNS("http://www.w3.org/2000/svg", name);
  }
  function text(data) {
    return document.createTextNode(data);
  }
  function space() {
    return text(" ");
  }
  function empty() {
    return text("");
  }
  function listen(node, event, handler, options) {
    node.addEventListener(event, handler, options);
    return () => node.removeEventListener(event, handler, options);
  }
  function prevent_default(fn) {
    return function(event) {
      event.preventDefault();
      return fn.call(this, event);
    };
  }
  function stop_propagation(fn) {
    return function(event) {
      event.stopPropagation();
      return fn.call(this, event);
    };
  }
  function attr(node, attribute, value) {
    if (value == null)
      node.removeAttribute(attribute);
    else if (node.getAttribute(attribute) !== value)
      node.setAttribute(attribute, value);
  }
  function set_svg_attributes(node, attributes) {
    for (const key in attributes) {
      attr(node, key, attributes[key]);
    }
  }
  function to_number(value) {
    return value === "" ? null : +value;
  }
  function children(element2) {
    return Array.from(element2.childNodes);
  }
  function set_data(text2, data) {
    data = "" + data;
    if (text2.wholeText !== data)
      text2.data = data;
  }
  function set_input_value(input, value) {
    input.value = value == null ? "" : value;
  }
  function set_style(node, key, value, important) {
    node.style.setProperty(key, value, important ? "important" : "");
  }
  function select_option(select, value) {
    for (let i = 0; i < select.options.length; i += 1) {
      const option = select.options[i];
      if (option.__value === value) {
        option.selected = true;
        return;
      }
    }
    select.selectedIndex = -1;
  }
  function select_value(select) {
    const selected_option = select.querySelector(":checked") || select.options[0];
    return selected_option && selected_option.__value;
  }
  var crossorigin;
  function is_crossorigin() {
    if (crossorigin === void 0) {
      crossorigin = false;
      try {
        if (typeof window !== "undefined" && window.parent) {
          void window.parent.document;
        }
      } catch (error) {
        crossorigin = true;
      }
    }
    return crossorigin;
  }
  function add_resize_listener(node, fn) {
    const computed_style = getComputedStyle(node);
    if (computed_style.position === "static") {
      node.style.position = "relative";
    }
    const iframe = element("iframe");
    iframe.setAttribute("style", "display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;");
    iframe.setAttribute("aria-hidden", "true");
    iframe.tabIndex = -1;
    const crossorigin2 = is_crossorigin();
    let unsubscribe;
    if (crossorigin2) {
      iframe.src = "data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}<\/script>";
      unsubscribe = listen(window, "message", (event) => {
        if (event.source === iframe.contentWindow)
          fn();
      });
    } else {
      iframe.src = "about:blank";
      iframe.onload = () => {
        unsubscribe = listen(iframe.contentWindow, "resize", fn);
      };
    }
    append(node, iframe);
    return () => {
      if (crossorigin2) {
        unsubscribe();
      } else if (unsubscribe && iframe.contentWindow) {
        unsubscribe();
      }
      detach(iframe);
    };
  }
  function toggle_class(element2, name, toggle) {
    element2.classList[toggle ? "add" : "remove"](name);
  }
  function custom_event(type, detail, bubbles = false) {
    const e = document.createEvent("CustomEvent");
    e.initCustomEvent(type, bubbles, false, detail);
    return e;
  }
  var HtmlTag = class {
    constructor() {
      this.e = this.n = null;
    }
    c(html) {
      this.h(html);
    }
    m(html, target, anchor = null) {
      if (!this.e) {
        this.e = element(target.nodeName);
        this.t = target;
        this.c(html);
      }
      this.i(anchor);
    }
    h(html) {
      this.e.innerHTML = html;
      this.n = Array.from(this.e.childNodes);
    }
    i(anchor) {
      for (let i = 0; i < this.n.length; i += 1) {
        insert(this.t, this.n[i], anchor);
      }
    }
    p(html) {
      this.d();
      this.h(html);
      this.i(this.a);
    }
    d() {
      this.n.forEach(detach);
    }
  };
  var active_docs = new Set();
  var current_component;
  function set_current_component(component) {
    current_component = component;
  }
  function get_current_component() {
    if (!current_component)
      throw new Error("Function called outside component initialization");
    return current_component;
  }
  function beforeUpdate(fn) {
    get_current_component().$$.before_update.push(fn);
  }
  function onMount(fn) {
    get_current_component().$$.on_mount.push(fn);
  }
  function afterUpdate(fn) {
    get_current_component().$$.after_update.push(fn);
  }
  function createEventDispatcher() {
    const component = get_current_component();
    return (type, detail) => {
      const callbacks = component.$$.callbacks[type];
      if (callbacks) {
        const event = custom_event(type, detail);
        callbacks.slice().forEach((fn) => {
          fn.call(component, event);
        });
      }
    };
  }
  function bubble(component, event) {
    const callbacks = component.$$.callbacks[event.type];
    if (callbacks) {
      callbacks.slice().forEach((fn) => fn.call(this, event));
    }
  }
  var dirty_components = [];
  var binding_callbacks = [];
  var render_callbacks = [];
  var flush_callbacks = [];
  var resolved_promise = Promise.resolve();
  var update_scheduled = false;
  function schedule_update() {
    if (!update_scheduled) {
      update_scheduled = true;
      resolved_promise.then(flush);
    }
  }
  function add_render_callback(fn) {
    render_callbacks.push(fn);
  }
  function add_flush_callback(fn) {
    flush_callbacks.push(fn);
  }
  var flushing = false;
  var seen_callbacks = new Set();
  function flush() {
    if (flushing)
      return;
    flushing = true;
    do {
      for (let i = 0; i < dirty_components.length; i += 1) {
        const component = dirty_components[i];
        set_current_component(component);
        update(component.$$);
      }
      set_current_component(null);
      dirty_components.length = 0;
      while (binding_callbacks.length)
        binding_callbacks.pop()();
      for (let i = 0; i < render_callbacks.length; i += 1) {
        const callback = render_callbacks[i];
        if (!seen_callbacks.has(callback)) {
          seen_callbacks.add(callback);
          callback();
        }
      }
      render_callbacks.length = 0;
    } while (dirty_components.length);
    while (flush_callbacks.length) {
      flush_callbacks.pop()();
    }
    update_scheduled = false;
    flushing = false;
    seen_callbacks.clear();
  }
  function update($$) {
    if ($$.fragment !== null) {
      $$.update();
      run_all($$.before_update);
      const dirty = $$.dirty;
      $$.dirty = [-1];
      $$.fragment && $$.fragment.p($$.ctx, dirty);
      $$.after_update.forEach(add_render_callback);
    }
  }
  var outroing = new Set();
  var outros;
  function group_outros() {
    outros = {
      r: 0,
      c: [],
      p: outros
    };
  }
  function check_outros() {
    if (!outros.r) {
      run_all(outros.c);
    }
    outros = outros.p;
  }
  function transition_in(block, local) {
    if (block && block.i) {
      outroing.delete(block);
      block.i(local);
    }
  }
  function transition_out(block, local, detach2, callback) {
    if (block && block.o) {
      if (outroing.has(block))
        return;
      outroing.add(block);
      outros.c.push(() => {
        outroing.delete(block);
        if (callback) {
          if (detach2)
            block.d(1);
          callback();
        }
      });
      block.o(local);
    }
  }
  var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
  function destroy_block(block, lookup) {
    block.d(1);
    lookup.delete(block.key);
  }
  function outro_and_destroy_block(block, lookup) {
    transition_out(block, 1, 1, () => {
      lookup.delete(block.key);
    });
  }
  function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block12, next, get_context) {
    let o = old_blocks.length;
    let n = list.length;
    let i = o;
    const old_indexes = {};
    while (i--)
      old_indexes[old_blocks[i].key] = i;
    const new_blocks = [];
    const new_lookup = new Map();
    const deltas = new Map();
    i = n;
    while (i--) {
      const child_ctx = get_context(ctx, list, i);
      const key = get_key(child_ctx);
      let block = lookup.get(key);
      if (!block) {
        block = create_each_block12(key, child_ctx);
        block.c();
      } else if (dynamic) {
        block.p(child_ctx, dirty);
      }
      new_lookup.set(key, new_blocks[i] = block);
      if (key in old_indexes)
        deltas.set(key, Math.abs(i - old_indexes[key]));
    }
    const will_move = new Set();
    const did_move = new Set();
    function insert2(block) {
      transition_in(block, 1);
      block.m(node, next);
      lookup.set(block.key, block);
      next = block.first;
      n--;
    }
    while (o && n) {
      const new_block = new_blocks[n - 1];
      const old_block = old_blocks[o - 1];
      const new_key = new_block.key;
      const old_key = old_block.key;
      if (new_block === old_block) {
        next = new_block.first;
        o--;
        n--;
      } else if (!new_lookup.has(old_key)) {
        destroy(old_block, lookup);
        o--;
      } else if (!lookup.has(new_key) || will_move.has(new_key)) {
        insert2(new_block);
      } else if (did_move.has(old_key)) {
        o--;
      } else if (deltas.get(new_key) > deltas.get(old_key)) {
        did_move.add(new_key);
        insert2(new_block);
      } else {
        will_move.add(old_key);
        o--;
      }
    }
    while (o--) {
      const old_block = old_blocks[o];
      if (!new_lookup.has(old_block.key))
        destroy(old_block, lookup);
    }
    while (n)
      insert2(new_blocks[n - 1]);
    return new_blocks;
  }
  function get_spread_update(levels, updates) {
    const update2 = {};
    const to_null_out = {};
    const accounted_for = { $$scope: 1 };
    let i = levels.length;
    while (i--) {
      const o = levels[i];
      const n = updates[i];
      if (n) {
        for (const key in o) {
          if (!(key in n))
            to_null_out[key] = 1;
        }
        for (const key in n) {
          if (!accounted_for[key]) {
            update2[key] = n[key];
            accounted_for[key] = 1;
          }
        }
        levels[i] = n;
      } else {
        for (const key in o) {
          accounted_for[key] = 1;
        }
      }
    }
    for (const key in to_null_out) {
      if (!(key in update2))
        update2[key] = void 0;
    }
    return update2;
  }
  function get_spread_object(spread_props) {
    return typeof spread_props === "object" && spread_props !== null ? spread_props : {};
  }
  var boolean_attributes = new Set([
    "allowfullscreen",
    "allowpaymentrequest",
    "async",
    "autofocus",
    "autoplay",
    "checked",
    "controls",
    "default",
    "defer",
    "disabled",
    "formnovalidate",
    "hidden",
    "ismap",
    "loop",
    "multiple",
    "muted",
    "nomodule",
    "novalidate",
    "open",
    "playsinline",
    "readonly",
    "required",
    "reversed",
    "selected"
  ]);
  function bind(component, name, callback) {
    const index = component.$$.props[name];
    if (index !== void 0) {
      component.$$.bound[index] = callback;
      callback(component.$$.ctx[index]);
    }
  }
  function create_component(block) {
    block && block.c();
  }
  function mount_component(component, target, anchor, customElement) {
    const { fragment, on_mount, on_destroy, after_update } = component.$$;
    fragment && fragment.m(target, anchor);
    if (!customElement) {
      add_render_callback(() => {
        const new_on_destroy = on_mount.map(run).filter(is_function);
        if (on_destroy) {
          on_destroy.push(...new_on_destroy);
        } else {
          run_all(new_on_destroy);
        }
        component.$$.on_mount = [];
      });
    }
    after_update.forEach(add_render_callback);
  }
  function destroy_component(component, detaching) {
    const $$ = component.$$;
    if ($$.fragment !== null) {
      run_all($$.on_destroy);
      $$.fragment && $$.fragment.d(detaching);
      $$.on_destroy = $$.fragment = null;
      $$.ctx = [];
    }
  }
  function make_dirty(component, i) {
    if (component.$$.dirty[0] === -1) {
      dirty_components.push(component);
      schedule_update();
      component.$$.dirty.fill(0);
    }
    component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
  }
  function init(component, options, instance86, create_fragment88, not_equal, props, append_styles, dirty = [-1]) {
    const parent_component = current_component;
    set_current_component(component);
    const $$ = component.$$ = {
      fragment: null,
      ctx: null,
      props,
      update: noop,
      not_equal,
      bound: blank_object(),
      on_mount: [],
      on_destroy: [],
      on_disconnect: [],
      before_update: [],
      after_update: [],
      context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
      callbacks: blank_object(),
      dirty,
      skip_bound: false,
      root: options.target || parent_component.$$.root
    };
    append_styles && append_styles($$.root);
    let ready = false;
    $$.ctx = instance86 ? instance86(component, options.props || {}, (i, ret, ...rest) => {
      const value = rest.length ? rest[0] : ret;
      if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
        if (!$$.skip_bound && $$.bound[i])
          $$.bound[i](value);
        if (ready)
          make_dirty(component, i);
      }
      return ret;
    }) : [];
    $$.update();
    ready = true;
    run_all($$.before_update);
    $$.fragment = create_fragment88 ? create_fragment88($$.ctx) : false;
    if (options.target) {
      if (options.hydrate) {
        start_hydrating();
        const nodes = children(options.target);
        $$.fragment && $$.fragment.l(nodes);
        nodes.forEach(detach);
      } else {
        $$.fragment && $$.fragment.c();
      }
      if (options.intro)
        transition_in(component.$$.fragment);
      mount_component(component, options.target, options.anchor, options.customElement);
      end_hydrating();
      flush();
    }
    set_current_component(parent_component);
  }
  var SvelteElement;
  if (typeof HTMLElement === "function") {
    SvelteElement = class extends HTMLElement {
      constructor() {
        super();
        this.attachShadow({ mode: "open" });
      }
      connectedCallback() {
        const { on_mount } = this.$$;
        this.$$.on_disconnect = on_mount.map(run).filter(is_function);
        for (const key in this.$$.slotted) {
          this.appendChild(this.$$.slotted[key]);
        }
      }
      attributeChangedCallback(attr2, _oldValue, newValue) {
        this[attr2] = newValue;
      }
      disconnectedCallback() {
        run_all(this.$$.on_disconnect);
      }
      $destroy() {
        destroy_component(this, 1);
        this.$destroy = noop;
      }
      $on(type, callback) {
        const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
        callbacks.push(callback);
        return () => {
          const index = callbacks.indexOf(callback);
          if (index !== -1)
            callbacks.splice(index, 1);
        };
      }
      $set($$props) {
        if (this.$$set && !is_empty($$props)) {
          this.$$.skip_bound = true;
          this.$$set($$props);
          this.$$.skip_bound = false;
        }
      }
    };
  }
  var SvelteComponent = class {
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop;
    }
    $on(type, callback) {
      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index = callbacks.indexOf(callback);
        if (index !== -1)
          callbacks.splice(index, 1);
      };
    }
    $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }
  };

  // elos-web/node_modules/svelte/store/index.mjs
  var subscriber_queue = [];
  function readable(value, start2) {
    return {
      subscribe: writable(value, start2).subscribe
    };
  }
  function writable(value, start2 = noop) {
    let stop;
    const subscribers = new Set();
    function set(new_value) {
      if (safe_not_equal(value, new_value)) {
        value = new_value;
        if (stop) {
          const run_queue = !subscriber_queue.length;
          for (const subscriber of subscribers) {
            subscriber[1]();
            subscriber_queue.push(subscriber, value);
          }
          if (run_queue) {
            for (let i = 0; i < subscriber_queue.length; i += 2) {
              subscriber_queue[i][0](subscriber_queue[i + 1]);
            }
            subscriber_queue.length = 0;
          }
        }
      }
    }
    function update2(fn) {
      set(fn(value));
    }
    function subscribe2(run2, invalidate = noop) {
      const subscriber = [run2, invalidate];
      subscribers.add(subscriber);
      if (subscribers.size === 1) {
        stop = start2(set) || noop;
      }
      run2(value);
      return () => {
        subscribers.delete(subscriber);
        if (subscribers.size === 0) {
          stop();
          stop = null;
        }
      };
    }
    return { set, update: update2, subscribe: subscribe2 };
  }

  // elos-web/src/lib/clock.js
  var minutesToSeconds = (minutes) => minutes * 60;
  var secondsToMinutes = (seconds) => Math.floor(seconds / 60);
  var padWithZeroes = (number) => number.toString().padStart(2, "0");
  var formatTime = (timeInSeconds) => {
    const minutes = secondsToMinutes(timeInSeconds);
    const remainingSeconds = timeInSeconds % 60;
    return `${padWithZeroes(minutes)}:${padWithZeroes(remainingSeconds)}`;
  };
  var clockFormatter = new Intl.DateTimeFormat("en", {
    hour12: true,
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit"
  });
  var dateStringFromDate = (date) => date.toLocaleDateString();
  var clockStore = readable(new Date(), function start(set) {
    const interval = setInterval(() => {
      set(new Date());
    }, 1e3);
    return function stop() {
      clearInterval(interval);
    };
  });
  var clockAction = (node, args) => {
    clockStore.subscribe((val) => {
      node.innerHTML = `${dateStringFromDate(val)} | ${clockFormatter.format(val)}`;
    });
    return {
      update(val) {
      },
      destroy() {
      }
    };
  };
  var timerAction = (node, args) => {
    let _args = args;
    let started = false;
    let interval = _args.interval;
    let timerP = node.querySelector("p.timer");
    console.log("Loading TIMERACTION", node, "|", _args, "|", timerP);
    node.querySelectorAll("button").forEach((button) => {
      switch (button.name) {
        case "start":
          button.addEventListener("click", (e) => {
            started = true;
            e.preventDefault();
          });
          break;
        case "reset":
          button.addEventListener("click", (e) => {
            started = false;
            interval = _args.interval;
            doc.innerHTML = formatTime(interval);
            e.preventDefault();
          });
          break;
        case "pause":
          button.addEventListener("click", (e) => {
            started = false;
            e.preventDefault();
          });
          break;
        case "lap":
          button.addEventListener("click", (e) => {
            interval = args.interval;
            doc.innerHTML = formatTime(interval);
            e.preventDefault();
          });
          break;
      }
    });
    clockStore.subscribe((val) => {
      let doc2 = document.querySelector("p.timer");
      if (doc2 && started) {
        console.log("p.timer", doc2, interval, formatTime(interval), doc2.innerHTML);
        doc2.innerHTML = formatTime(interval);
        interval -= 1;
      }
    });
    return {
      update(val) {
      },
      destroy() {
      }
    };
  };

  // elos-web/src/Timer.svelte
  function create_fragment(ctx) {
    let section;
    let timerAction_action;
    let mounted;
    let dispose;
    return {
      c() {
        section = element("section");
        section.innerHTML = `<p class="timer svelte-ie0v0j"></p> 
  <div class="control svelte-ie0v0j"><button name="start" class="svelte-ie0v0j">Start</button> 
    <button name="reset" class="svelte-ie0v0j">Reset</button> 
    <button name="pause" class="svelte-ie0v0j">Pause</button> 
    <button name="lap" class="svelte-ie0v0j">Lap</button></div>`;
        attr(section, "class", "timer-container svelte-ie0v0j");
      },
      m(target, anchor) {
        insert(target, section, anchor);
        if (!mounted) {
          dispose = action_destroyer(timerAction_action = timerAction.call(null, section, ctx[0]));
          mounted = true;
        }
      },
      p: noop,
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(section);
        mounted = false;
        dispose();
      }
    };
  }
  function instance($$self, $$props, $$invalidate) {
    let timerInterval;
    let timer;
    let timerDurations = {
      "pomodoro_short": minutesToSeconds(25),
      "pomodoro_medium": minutesToSeconds(45),
      "break_short": minutesToSeconds(5),
      "break_medium": minutesToSeconds(15)
    };
    const timerTypes = ["break", "work", "study"];
    let { startTime = timerDurations.pomodoro_short } = $$props;
    let timerArgs = {
      interval: startTime,
      store: null,
      data: {}
    };
    onMount(async () => {
      console.log("Timer mounted");
    });
    $$self.$$set = ($$props2) => {
      if ("startTime" in $$props2)
        $$invalidate(1, startTime = $$props2.startTime);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 2) {
        $:
          console.log("TIMER START TIME", startTime);
      }
    };
    return [timerArgs, startTime];
  }
  var Timer = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance, create_fragment, safe_not_equal, { startTime: 1 });
    }
  };
  var Timer_default = Timer;

  // elos-web/node_modules/carbon-icons-svelte/lib/AccessibilityColor16/AccessibilityColor16.svelte
  function create_if_block(ctx) {
    let title_1;
    let t;
    return {
      c() {
        title_1 = svg_element("title");
        t = text(ctx[2]);
      },
      m(target, anchor) {
        insert(target, title_1, anchor);
        append(title_1, t);
      },
      p(ctx2, dirty) {
        if (dirty & 4)
          set_data(t, ctx2[2]);
      },
      d(detaching) {
        if (detaching)
          detach(title_1);
      }
    };
  }
  function fallback_block(ctx) {
    let if_block_anchor;
    let if_block = ctx[2] && create_if_block(ctx);
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (ctx2[2]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach(if_block_anchor);
      }
    };
  }
  function create_fragment2(ctx) {
    let svg;
    let path0;
    let path1;
    let path2;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[11].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
    const default_slot_or_fallback = default_slot || fallback_block(ctx);
    let svg_levels = [
      {
        "data-carbon-icon": "AccessibilityColor16"
      },
      { xmlns: "http://www.w3.org/2000/svg" },
      { viewBox: "0 0 32 32" },
      { fill: "currentColor" },
      { width: "16" },
      { height: "16" },
      { class: ctx[0] },
      { preserveAspectRatio: "xMidYMid meet" },
      { style: ctx[3] },
      { id: ctx[1] },
      ctx[4]
    ];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    return {
      c() {
        svg = svg_element("svg");
        path0 = svg_element("path");
        path1 = svg_element("path");
        path2 = svg_element("path");
        if (default_slot_or_fallback)
          default_slot_or_fallback.c();
        attr(path0, "d", "M16,20a4,4,0,1,1,4-4A4.0045,4.0045,0,0,1,16,20Zm0-6a2,2,0,1,0,2,2A2.0021,2.0021,0,0,0,16,14Z");
        attr(path1, "d", "M16,24a10.6547,10.6547,0,0,1-9.97-7.7576L5.9692,16l.0606-.2424A10.6547,10.6547,0,0,1,16,8a10.6547,10.6547,0,0,1,9.97,7.7576L26.0308,16l-.0606.2424A10.6547,10.6547,0,0,1,16,24ZM8.0352,16A8.5975,8.5975,0,0,0,16,22a8.5975,8.5975,0,0,0,7.9648-6A8.5975,8.5975,0,0,0,16,10,8.5975,8.5975,0,0,0,8.0352,16Z");
        attr(path2, "d", "M16,30A14,14,0,1,1,30,16,14.0158,14.0158,0,0,1,16,30ZM16,4A12,12,0,1,0,28,16,12.0137,12.0137,0,0,0,16,4Z");
        set_svg_attributes(svg, svg_data);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path0);
        append(svg, path1);
        append(svg, path2);
        if (default_slot_or_fallback) {
          default_slot_or_fallback.m(svg, null);
        }
        current = true;
        if (!mounted) {
          dispose = [
            listen(svg, "click", ctx[12]),
            listen(svg, "mouseover", ctx[13]),
            listen(svg, "mouseenter", ctx[14]),
            listen(svg, "mouseleave", ctx[15]),
            listen(svg, "keyup", ctx[16]),
            listen(svg, "keydown", ctx[17])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1024)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
          }
        } else {
          if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
            default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
          }
        }
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
          {
            "data-carbon-icon": "AccessibilityColor16"
          },
          { xmlns: "http://www.w3.org/2000/svg" },
          { viewBox: "0 0 32 32" },
          { fill: "currentColor" },
          { width: "16" },
          { height: "16" },
          (!current || dirty & 1) && { class: ctx2[0] },
          { preserveAspectRatio: "xMidYMid meet" },
          (!current || dirty & 8) && { style: ctx2[3] },
          (!current || dirty & 2) && { id: ctx2[1] },
          dirty & 16 && ctx2[4]
        ]));
      },
      i(local) {
        if (current)
          return;
        transition_in(default_slot_or_fallback, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot_or_fallback, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(svg);
        if (default_slot_or_fallback)
          default_slot_or_fallback.d(detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance2($$self, $$props, $$invalidate) {
    let ariaLabel;
    let ariaLabelledBy;
    let labelled;
    let attributes;
    let { $$slots: slots = {}, $$scope } = $$props;
    let { class: className = void 0 } = $$props;
    let { id = void 0 } = $$props;
    let { tabindex = void 0 } = $$props;
    let { focusable = false } = $$props;
    let { title: title2 = void 0 } = $$props;
    let { style = void 0 } = $$props;
    function click_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseover_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseenter_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseleave_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keyup_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keydown_handler(event) {
      bubble.call(this, $$self, event);
    }
    $$self.$$set = ($$new_props) => {
      $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
      if ("class" in $$new_props)
        $$invalidate(0, className = $$new_props.class);
      if ("id" in $$new_props)
        $$invalidate(1, id = $$new_props.id);
      if ("tabindex" in $$new_props)
        $$invalidate(5, tabindex = $$new_props.tabindex);
      if ("focusable" in $$new_props)
        $$invalidate(6, focusable = $$new_props.focusable);
      if ("title" in $$new_props)
        $$invalidate(2, title2 = $$new_props.title);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("$$scope" in $$new_props)
        $$invalidate(10, $$scope = $$new_props.$$scope);
    };
    $$self.$$.update = () => {
      $:
        $$invalidate(9, ariaLabel = $$props["aria-label"]);
      $:
        $$invalidate(8, ariaLabelledBy = $$props["aria-labelledby"]);
      if ($$self.$$.dirty & 772) {
        $:
          $$invalidate(7, labelled = ariaLabel || ariaLabelledBy || title2);
      }
      if ($$self.$$.dirty & 992) {
        $:
          $$invalidate(4, attributes = {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-hidden": labelled ? void 0 : true,
            role: labelled ? "img" : void 0,
            focusable: tabindex === "0" ? true : focusable,
            tabindex
          });
      }
    };
    $$props = exclude_internal_props($$props);
    return [
      className,
      id,
      title2,
      style,
      attributes,
      tabindex,
      focusable,
      labelled,
      ariaLabelledBy,
      ariaLabel,
      $$scope,
      slots,
      click_handler,
      mouseover_handler,
      mouseenter_handler,
      mouseleave_handler,
      keyup_handler,
      keydown_handler
    ];
  }
  var AccessibilityColor16 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance2, create_fragment2, safe_not_equal, {
        class: 0,
        id: 1,
        tabindex: 5,
        focusable: 6,
        title: 2,
        style: 3
      });
    }
  };
  var AccessibilityColor16_default = AccessibilityColor16;

  // elos-web/node_modules/carbon-icons-svelte/lib/AccessibilityColor16/index.js
  var AccessibilityColor16_default2 = AccessibilityColor16_default;

  // elos-web/node_modules/carbon-icons-svelte/lib/AccessibilityColorFilled16/AccessibilityColorFilled16.svelte
  function create_if_block2(ctx) {
    let title_1;
    let t;
    return {
      c() {
        title_1 = svg_element("title");
        t = text(ctx[2]);
      },
      m(target, anchor) {
        insert(target, title_1, anchor);
        append(title_1, t);
      },
      p(ctx2, dirty) {
        if (dirty & 4)
          set_data(t, ctx2[2]);
      },
      d(detaching) {
        if (detaching)
          detach(title_1);
      }
    };
  }
  function fallback_block2(ctx) {
    let if_block_anchor;
    let if_block = ctx[2] && create_if_block2(ctx);
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (ctx2[2]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block2(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach(if_block_anchor);
      }
    };
  }
  function create_fragment3(ctx) {
    let svg;
    let path0;
    let path1;
    let circle;
    let path2;
    let path3;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[11].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
    const default_slot_or_fallback = default_slot || fallback_block2(ctx);
    let svg_levels = [
      {
        "data-carbon-icon": "AccessibilityColorFilled16"
      },
      { xmlns: "http://www.w3.org/2000/svg" },
      { viewBox: "0 0 32 32" },
      { fill: "currentColor" },
      { width: "16" },
      { height: "16" },
      { class: ctx[0] },
      { preserveAspectRatio: "xMidYMid meet" },
      { style: ctx[3] },
      { id: ctx[1] },
      ctx[4]
    ];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    return {
      c() {
        svg = svg_element("svg");
        path0 = svg_element("path");
        path1 = svg_element("path");
        circle = svg_element("circle");
        path2 = svg_element("path");
        path3 = svg_element("path");
        if (default_slot_or_fallback)
          default_slot_or_fallback.c();
        attr(path0, "d", "M16,10a8.5975,8.5975,0,0,0-7.9648,6A8.5975,8.5975,0,0,0,16,22a8.5975,8.5975,0,0,0,7.9648-6A8.5975,8.5975,0,0,0,16,10Zm0,10a4,4,0,1,1,4-4A4.0045,4.0045,0,0,1,16,20Z");
        attr(path1, "d", "M16,2A14,14,0,1,0,30,16,14,14,0,0,0,16,2Zm0,22a10.6543,10.6543,0,0,1-9.97-7.7578L5.9692,16l.0606-.2422A10.6543,10.6543,0,0,1,16,8a10.6543,10.6543,0,0,1,9.97,7.7578L26.0308,16l-.0606.2422A10.6543,10.6543,0,0,1,16,24Z");
        attr(circle, "cx", "16");
        attr(circle, "cy", "16");
        attr(circle, "r", "2");
        attr(path2, "fill", "none");
        attr(path2, "d", "M16,20a4,4,0,1,1,4-4A4.0045,4.0045,0,0,1,16,20Zm0-6a2,2,0,1,0,2,2A2.0021,2.0021,0,0,0,16,14Z");
        attr(path3, "fill", "none");
        attr(path3, "d", "M16,24a10.6547,10.6547,0,0,1-9.97-7.7576L5.9692,16l.0606-.2424A10.6547,10.6547,0,0,1,16,8a10.6547,10.6547,0,0,1,9.97,7.7576L26.0308,16l-.0606.2424A10.6547,10.6547,0,0,1,16,24ZM8.0352,16A8.5975,8.5975,0,0,0,16,22a8.5975,8.5975,0,0,0,7.9648-6A8.5975,8.5975,0,0,0,16,10,8.5975,8.5975,0,0,0,8.0352,16Z");
        set_svg_attributes(svg, svg_data);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path0);
        append(svg, path1);
        append(svg, circle);
        append(svg, path2);
        append(svg, path3);
        if (default_slot_or_fallback) {
          default_slot_or_fallback.m(svg, null);
        }
        current = true;
        if (!mounted) {
          dispose = [
            listen(svg, "click", ctx[12]),
            listen(svg, "mouseover", ctx[13]),
            listen(svg, "mouseenter", ctx[14]),
            listen(svg, "mouseleave", ctx[15]),
            listen(svg, "keyup", ctx[16]),
            listen(svg, "keydown", ctx[17])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1024)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
          }
        } else {
          if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
            default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
          }
        }
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
          {
            "data-carbon-icon": "AccessibilityColorFilled16"
          },
          { xmlns: "http://www.w3.org/2000/svg" },
          { viewBox: "0 0 32 32" },
          { fill: "currentColor" },
          { width: "16" },
          { height: "16" },
          (!current || dirty & 1) && { class: ctx2[0] },
          { preserveAspectRatio: "xMidYMid meet" },
          (!current || dirty & 8) && { style: ctx2[3] },
          (!current || dirty & 2) && { id: ctx2[1] },
          dirty & 16 && ctx2[4]
        ]));
      },
      i(local) {
        if (current)
          return;
        transition_in(default_slot_or_fallback, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot_or_fallback, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(svg);
        if (default_slot_or_fallback)
          default_slot_or_fallback.d(detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance3($$self, $$props, $$invalidate) {
    let ariaLabel;
    let ariaLabelledBy;
    let labelled;
    let attributes;
    let { $$slots: slots = {}, $$scope } = $$props;
    let { class: className = void 0 } = $$props;
    let { id = void 0 } = $$props;
    let { tabindex = void 0 } = $$props;
    let { focusable = false } = $$props;
    let { title: title2 = void 0 } = $$props;
    let { style = void 0 } = $$props;
    function click_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseover_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseenter_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseleave_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keyup_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keydown_handler(event) {
      bubble.call(this, $$self, event);
    }
    $$self.$$set = ($$new_props) => {
      $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
      if ("class" in $$new_props)
        $$invalidate(0, className = $$new_props.class);
      if ("id" in $$new_props)
        $$invalidate(1, id = $$new_props.id);
      if ("tabindex" in $$new_props)
        $$invalidate(5, tabindex = $$new_props.tabindex);
      if ("focusable" in $$new_props)
        $$invalidate(6, focusable = $$new_props.focusable);
      if ("title" in $$new_props)
        $$invalidate(2, title2 = $$new_props.title);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("$$scope" in $$new_props)
        $$invalidate(10, $$scope = $$new_props.$$scope);
    };
    $$self.$$.update = () => {
      $:
        $$invalidate(9, ariaLabel = $$props["aria-label"]);
      $:
        $$invalidate(8, ariaLabelledBy = $$props["aria-labelledby"]);
      if ($$self.$$.dirty & 772) {
        $:
          $$invalidate(7, labelled = ariaLabel || ariaLabelledBy || title2);
      }
      if ($$self.$$.dirty & 992) {
        $:
          $$invalidate(4, attributes = {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-hidden": labelled ? void 0 : true,
            role: labelled ? "img" : void 0,
            focusable: tabindex === "0" ? true : focusable,
            tabindex
          });
      }
    };
    $$props = exclude_internal_props($$props);
    return [
      className,
      id,
      title2,
      style,
      attributes,
      tabindex,
      focusable,
      labelled,
      ariaLabelledBy,
      ariaLabel,
      $$scope,
      slots,
      click_handler,
      mouseover_handler,
      mouseenter_handler,
      mouseleave_handler,
      keyup_handler,
      keydown_handler
    ];
  }
  var AccessibilityColorFilled16 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance3, create_fragment3, safe_not_equal, {
        class: 0,
        id: 1,
        tabindex: 5,
        focusable: 6,
        title: 2,
        style: 3
      });
    }
  };
  var AccessibilityColorFilled16_default = AccessibilityColorFilled16;

  // elos-web/node_modules/carbon-icons-svelte/lib/AccessibilityColorFilled16/index.js
  var AccessibilityColorFilled16_default2 = AccessibilityColorFilled16_default;

  // elos-web/node_modules/carbon-icons-svelte/lib/AddFilled16/AddFilled16.svelte
  function create_if_block3(ctx) {
    let title_1;
    let t;
    return {
      c() {
        title_1 = svg_element("title");
        t = text(ctx[2]);
      },
      m(target, anchor) {
        insert(target, title_1, anchor);
        append(title_1, t);
      },
      p(ctx2, dirty) {
        if (dirty & 4)
          set_data(t, ctx2[2]);
      },
      d(detaching) {
        if (detaching)
          detach(title_1);
      }
    };
  }
  function fallback_block3(ctx) {
    let if_block_anchor;
    let if_block = ctx[2] && create_if_block3(ctx);
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (ctx2[2]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block3(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach(if_block_anchor);
      }
    };
  }
  function create_fragment4(ctx) {
    let svg;
    let path0;
    let path1;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[11].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
    const default_slot_or_fallback = default_slot || fallback_block3(ctx);
    let svg_levels = [
      { "data-carbon-icon": "AddFilled16" },
      { xmlns: "http://www.w3.org/2000/svg" },
      { viewBox: "0 0 32 32" },
      { fill: "currentColor" },
      { width: "16" },
      { height: "16" },
      { class: ctx[0] },
      { preserveAspectRatio: "xMidYMid meet" },
      { style: ctx[3] },
      { id: ctx[1] },
      ctx[4]
    ];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    return {
      c() {
        svg = svg_element("svg");
        path0 = svg_element("path");
        path1 = svg_element("path");
        if (default_slot_or_fallback)
          default_slot_or_fallback.c();
        attr(path0, "d", "M16,2A14.1725,14.1725,0,0,0,2,16,14.1725,14.1725,0,0,0,16,30,14.1725,14.1725,0,0,0,30,16,14.1725,14.1725,0,0,0,16,2Zm8,15H17v7H15V17H8V15h7V8h2v7h7Z");
        attr(path1, "fill", "none");
        attr(path1, "d", "M24 17L17 17 17 24 15 24 15 17 8 17 8 15 15 15 15 8 17 8 17 15 24 15 24 17z");
        attr(path1, "data-icon-path", "inner-path");
        set_svg_attributes(svg, svg_data);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path0);
        append(svg, path1);
        if (default_slot_or_fallback) {
          default_slot_or_fallback.m(svg, null);
        }
        current = true;
        if (!mounted) {
          dispose = [
            listen(svg, "click", ctx[12]),
            listen(svg, "mouseover", ctx[13]),
            listen(svg, "mouseenter", ctx[14]),
            listen(svg, "mouseleave", ctx[15]),
            listen(svg, "keyup", ctx[16]),
            listen(svg, "keydown", ctx[17])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1024)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
          }
        } else {
          if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
            default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
          }
        }
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
          { "data-carbon-icon": "AddFilled16" },
          { xmlns: "http://www.w3.org/2000/svg" },
          { viewBox: "0 0 32 32" },
          { fill: "currentColor" },
          { width: "16" },
          { height: "16" },
          (!current || dirty & 1) && { class: ctx2[0] },
          { preserveAspectRatio: "xMidYMid meet" },
          (!current || dirty & 8) && { style: ctx2[3] },
          (!current || dirty & 2) && { id: ctx2[1] },
          dirty & 16 && ctx2[4]
        ]));
      },
      i(local) {
        if (current)
          return;
        transition_in(default_slot_or_fallback, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot_or_fallback, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(svg);
        if (default_slot_or_fallback)
          default_slot_or_fallback.d(detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance4($$self, $$props, $$invalidate) {
    let ariaLabel;
    let ariaLabelledBy;
    let labelled;
    let attributes;
    let { $$slots: slots = {}, $$scope } = $$props;
    let { class: className = void 0 } = $$props;
    let { id = void 0 } = $$props;
    let { tabindex = void 0 } = $$props;
    let { focusable = false } = $$props;
    let { title: title2 = void 0 } = $$props;
    let { style = void 0 } = $$props;
    function click_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseover_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseenter_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseleave_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keyup_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keydown_handler(event) {
      bubble.call(this, $$self, event);
    }
    $$self.$$set = ($$new_props) => {
      $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
      if ("class" in $$new_props)
        $$invalidate(0, className = $$new_props.class);
      if ("id" in $$new_props)
        $$invalidate(1, id = $$new_props.id);
      if ("tabindex" in $$new_props)
        $$invalidate(5, tabindex = $$new_props.tabindex);
      if ("focusable" in $$new_props)
        $$invalidate(6, focusable = $$new_props.focusable);
      if ("title" in $$new_props)
        $$invalidate(2, title2 = $$new_props.title);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("$$scope" in $$new_props)
        $$invalidate(10, $$scope = $$new_props.$$scope);
    };
    $$self.$$.update = () => {
      $:
        $$invalidate(9, ariaLabel = $$props["aria-label"]);
      $:
        $$invalidate(8, ariaLabelledBy = $$props["aria-labelledby"]);
      if ($$self.$$.dirty & 772) {
        $:
          $$invalidate(7, labelled = ariaLabel || ariaLabelledBy || title2);
      }
      if ($$self.$$.dirty & 992) {
        $:
          $$invalidate(4, attributes = {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-hidden": labelled ? void 0 : true,
            role: labelled ? "img" : void 0,
            focusable: tabindex === "0" ? true : focusable,
            tabindex
          });
      }
    };
    $$props = exclude_internal_props($$props);
    return [
      className,
      id,
      title2,
      style,
      attributes,
      tabindex,
      focusable,
      labelled,
      ariaLabelledBy,
      ariaLabel,
      $$scope,
      slots,
      click_handler,
      mouseover_handler,
      mouseenter_handler,
      mouseleave_handler,
      keyup_handler,
      keydown_handler
    ];
  }
  var AddFilled16 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance4, create_fragment4, safe_not_equal, {
        class: 0,
        id: 1,
        tabindex: 5,
        focusable: 6,
        title: 2,
        style: 3
      });
    }
  };
  var AddFilled16_default = AddFilled16;

  // elos-web/node_modules/carbon-icons-svelte/lib/AddFilled16/index.js
  var AddFilled16_default2 = AddFilled16_default;

  // elos-web/node_modules/carbon-icons-svelte/lib/Alarm16/Alarm16.svelte
  function create_if_block4(ctx) {
    let title_1;
    let t;
    return {
      c() {
        title_1 = svg_element("title");
        t = text(ctx[2]);
      },
      m(target, anchor) {
        insert(target, title_1, anchor);
        append(title_1, t);
      },
      p(ctx2, dirty) {
        if (dirty & 4)
          set_data(t, ctx2[2]);
      },
      d(detaching) {
        if (detaching)
          detach(title_1);
      }
    };
  }
  function fallback_block4(ctx) {
    let if_block_anchor;
    let if_block = ctx[2] && create_if_block4(ctx);
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (ctx2[2]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block4(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach(if_block_anchor);
      }
    };
  }
  function create_fragment5(ctx) {
    let svg;
    let path0;
    let path1;
    let path2;
    let path3;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[11].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
    const default_slot_or_fallback = default_slot || fallback_block4(ctx);
    let svg_levels = [
      { "data-carbon-icon": "Alarm16" },
      { xmlns: "http://www.w3.org/2000/svg" },
      { viewBox: "0 0 32 32" },
      { fill: "currentColor" },
      { width: "16" },
      { height: "16" },
      { class: ctx[0] },
      { preserveAspectRatio: "xMidYMid meet" },
      { style: ctx[3] },
      { id: ctx[1] },
      ctx[4]
    ];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    return {
      c() {
        svg = svg_element("svg");
        path0 = svg_element("path");
        path1 = svg_element("path");
        path2 = svg_element("path");
        path3 = svg_element("path");
        if (default_slot_or_fallback)
          default_slot_or_fallback.c();
        attr(path0, "d", "M16,28A11,11,0,1,1,27,17,11,11,0,0,1,16,28ZM16,8a9,9,0,1,0,9,9A9,9,0,0,0,16,8Z");
        attr(path1, "d", "M18.59 21L15 17.41 15 11 17 11 17 16.58 20 19.59 18.59 21z");
        attr(path2, "d", "M3.96 5.5H9.030000000000001V7.5H3.96z");
        attr(path2, "transform", "rotate(-45.06 6.502 6.497)");
        attr(path3, "d", "M24.5 3.96H26.5V9.030000000000001H24.5z");
        attr(path3, "transform", "rotate(-44.94 25.5 6.498)");
        set_svg_attributes(svg, svg_data);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path0);
        append(svg, path1);
        append(svg, path2);
        append(svg, path3);
        if (default_slot_or_fallback) {
          default_slot_or_fallback.m(svg, null);
        }
        current = true;
        if (!mounted) {
          dispose = [
            listen(svg, "click", ctx[12]),
            listen(svg, "mouseover", ctx[13]),
            listen(svg, "mouseenter", ctx[14]),
            listen(svg, "mouseleave", ctx[15]),
            listen(svg, "keyup", ctx[16]),
            listen(svg, "keydown", ctx[17])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1024)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
          }
        } else {
          if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
            default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
          }
        }
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
          { "data-carbon-icon": "Alarm16" },
          { xmlns: "http://www.w3.org/2000/svg" },
          { viewBox: "0 0 32 32" },
          { fill: "currentColor" },
          { width: "16" },
          { height: "16" },
          (!current || dirty & 1) && { class: ctx2[0] },
          { preserveAspectRatio: "xMidYMid meet" },
          (!current || dirty & 8) && { style: ctx2[3] },
          (!current || dirty & 2) && { id: ctx2[1] },
          dirty & 16 && ctx2[4]
        ]));
      },
      i(local) {
        if (current)
          return;
        transition_in(default_slot_or_fallback, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot_or_fallback, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(svg);
        if (default_slot_or_fallback)
          default_slot_or_fallback.d(detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance5($$self, $$props, $$invalidate) {
    let ariaLabel;
    let ariaLabelledBy;
    let labelled;
    let attributes;
    let { $$slots: slots = {}, $$scope } = $$props;
    let { class: className = void 0 } = $$props;
    let { id = void 0 } = $$props;
    let { tabindex = void 0 } = $$props;
    let { focusable = false } = $$props;
    let { title: title2 = void 0 } = $$props;
    let { style = void 0 } = $$props;
    function click_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseover_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseenter_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseleave_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keyup_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keydown_handler(event) {
      bubble.call(this, $$self, event);
    }
    $$self.$$set = ($$new_props) => {
      $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
      if ("class" in $$new_props)
        $$invalidate(0, className = $$new_props.class);
      if ("id" in $$new_props)
        $$invalidate(1, id = $$new_props.id);
      if ("tabindex" in $$new_props)
        $$invalidate(5, tabindex = $$new_props.tabindex);
      if ("focusable" in $$new_props)
        $$invalidate(6, focusable = $$new_props.focusable);
      if ("title" in $$new_props)
        $$invalidate(2, title2 = $$new_props.title);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("$$scope" in $$new_props)
        $$invalidate(10, $$scope = $$new_props.$$scope);
    };
    $$self.$$.update = () => {
      $:
        $$invalidate(9, ariaLabel = $$props["aria-label"]);
      $:
        $$invalidate(8, ariaLabelledBy = $$props["aria-labelledby"]);
      if ($$self.$$.dirty & 772) {
        $:
          $$invalidate(7, labelled = ariaLabel || ariaLabelledBy || title2);
      }
      if ($$self.$$.dirty & 992) {
        $:
          $$invalidate(4, attributes = {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-hidden": labelled ? void 0 : true,
            role: labelled ? "img" : void 0,
            focusable: tabindex === "0" ? true : focusable,
            tabindex
          });
      }
    };
    $$props = exclude_internal_props($$props);
    return [
      className,
      id,
      title2,
      style,
      attributes,
      tabindex,
      focusable,
      labelled,
      ariaLabelledBy,
      ariaLabel,
      $$scope,
      slots,
      click_handler,
      mouseover_handler,
      mouseenter_handler,
      mouseleave_handler,
      keyup_handler,
      keydown_handler
    ];
  }
  var Alarm16 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance5, create_fragment5, safe_not_equal, {
        class: 0,
        id: 1,
        tabindex: 5,
        focusable: 6,
        title: 2,
        style: 3
      });
    }
  };
  var Alarm16_default = Alarm16;

  // elos-web/node_modules/carbon-icons-svelte/lib/Alarm16/index.js
  var Alarm16_default2 = Alarm16_default;

  // elos-web/node_modules/carbon-icons-svelte/lib/AlarmAdd16/AlarmAdd16.svelte
  function create_if_block5(ctx) {
    let title_1;
    let t;
    return {
      c() {
        title_1 = svg_element("title");
        t = text(ctx[2]);
      },
      m(target, anchor) {
        insert(target, title_1, anchor);
        append(title_1, t);
      },
      p(ctx2, dirty) {
        if (dirty & 4)
          set_data(t, ctx2[2]);
      },
      d(detaching) {
        if (detaching)
          detach(title_1);
      }
    };
  }
  function fallback_block5(ctx) {
    let if_block_anchor;
    let if_block = ctx[2] && create_if_block5(ctx);
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (ctx2[2]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block5(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach(if_block_anchor);
      }
    };
  }
  function create_fragment6(ctx) {
    let svg;
    let path0;
    let path1;
    let path2;
    let path3;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[11].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
    const default_slot_or_fallback = default_slot || fallback_block5(ctx);
    let svg_levels = [
      { "data-carbon-icon": "AlarmAdd16" },
      { xmlns: "http://www.w3.org/2000/svg" },
      { viewBox: "0 0 32 32" },
      { fill: "currentColor" },
      { width: "16" },
      { height: "16" },
      { class: ctx[0] },
      { preserveAspectRatio: "xMidYMid meet" },
      { style: ctx[3] },
      { id: ctx[1] },
      ctx[4]
    ];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    return {
      c() {
        svg = svg_element("svg");
        path0 = svg_element("path");
        path1 = svg_element("path");
        path2 = svg_element("path");
        path3 = svg_element("path");
        if (default_slot_or_fallback)
          default_slot_or_fallback.c();
        attr(path0, "d", "M16,28A11,11,0,1,1,27,17,11,11,0,0,1,16,28ZM16,8a9,9,0,1,0,9,9A9,9,0,0,0,16,8Z");
        attr(path1, "d", "M3.96 5.5H9.030000000000001V7.5H3.96z");
        attr(path1, "transform", "rotate(-45.06 6.502 6.497)");
        attr(path2, "d", "M24.5 3.96H26.5V9.030000000000001H24.5z");
        attr(path2, "transform", "rotate(-44.94 25.5 6.498)");
        attr(path3, "d", "M21 16L17 16 17 12 15 12 15 16 11 16 11 18 15 18 15 22 17 22 17 18 21 18 21 16z");
        set_svg_attributes(svg, svg_data);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path0);
        append(svg, path1);
        append(svg, path2);
        append(svg, path3);
        if (default_slot_or_fallback) {
          default_slot_or_fallback.m(svg, null);
        }
        current = true;
        if (!mounted) {
          dispose = [
            listen(svg, "click", ctx[12]),
            listen(svg, "mouseover", ctx[13]),
            listen(svg, "mouseenter", ctx[14]),
            listen(svg, "mouseleave", ctx[15]),
            listen(svg, "keyup", ctx[16]),
            listen(svg, "keydown", ctx[17])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1024)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
          }
        } else {
          if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
            default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
          }
        }
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
          { "data-carbon-icon": "AlarmAdd16" },
          { xmlns: "http://www.w3.org/2000/svg" },
          { viewBox: "0 0 32 32" },
          { fill: "currentColor" },
          { width: "16" },
          { height: "16" },
          (!current || dirty & 1) && { class: ctx2[0] },
          { preserveAspectRatio: "xMidYMid meet" },
          (!current || dirty & 8) && { style: ctx2[3] },
          (!current || dirty & 2) && { id: ctx2[1] },
          dirty & 16 && ctx2[4]
        ]));
      },
      i(local) {
        if (current)
          return;
        transition_in(default_slot_or_fallback, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot_or_fallback, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(svg);
        if (default_slot_or_fallback)
          default_slot_or_fallback.d(detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance6($$self, $$props, $$invalidate) {
    let ariaLabel;
    let ariaLabelledBy;
    let labelled;
    let attributes;
    let { $$slots: slots = {}, $$scope } = $$props;
    let { class: className = void 0 } = $$props;
    let { id = void 0 } = $$props;
    let { tabindex = void 0 } = $$props;
    let { focusable = false } = $$props;
    let { title: title2 = void 0 } = $$props;
    let { style = void 0 } = $$props;
    function click_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseover_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseenter_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseleave_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keyup_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keydown_handler(event) {
      bubble.call(this, $$self, event);
    }
    $$self.$$set = ($$new_props) => {
      $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
      if ("class" in $$new_props)
        $$invalidate(0, className = $$new_props.class);
      if ("id" in $$new_props)
        $$invalidate(1, id = $$new_props.id);
      if ("tabindex" in $$new_props)
        $$invalidate(5, tabindex = $$new_props.tabindex);
      if ("focusable" in $$new_props)
        $$invalidate(6, focusable = $$new_props.focusable);
      if ("title" in $$new_props)
        $$invalidate(2, title2 = $$new_props.title);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("$$scope" in $$new_props)
        $$invalidate(10, $$scope = $$new_props.$$scope);
    };
    $$self.$$.update = () => {
      $:
        $$invalidate(9, ariaLabel = $$props["aria-label"]);
      $:
        $$invalidate(8, ariaLabelledBy = $$props["aria-labelledby"]);
      if ($$self.$$.dirty & 772) {
        $:
          $$invalidate(7, labelled = ariaLabel || ariaLabelledBy || title2);
      }
      if ($$self.$$.dirty & 992) {
        $:
          $$invalidate(4, attributes = {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-hidden": labelled ? void 0 : true,
            role: labelled ? "img" : void 0,
            focusable: tabindex === "0" ? true : focusable,
            tabindex
          });
      }
    };
    $$props = exclude_internal_props($$props);
    return [
      className,
      id,
      title2,
      style,
      attributes,
      tabindex,
      focusable,
      labelled,
      ariaLabelledBy,
      ariaLabel,
      $$scope,
      slots,
      click_handler,
      mouseover_handler,
      mouseenter_handler,
      mouseleave_handler,
      keyup_handler,
      keydown_handler
    ];
  }
  var AlarmAdd16 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance6, create_fragment6, safe_not_equal, {
        class: 0,
        id: 1,
        tabindex: 5,
        focusable: 6,
        title: 2,
        style: 3
      });
    }
  };
  var AlarmAdd16_default = AlarmAdd16;

  // elos-web/node_modules/carbon-icons-svelte/lib/AlarmAdd16/index.js
  var AlarmAdd16_default2 = AlarmAdd16_default;

  // elos-web/node_modules/carbon-icons-svelte/lib/AlarmSubtract16/AlarmSubtract16.svelte
  function create_if_block6(ctx) {
    let title_1;
    let t;
    return {
      c() {
        title_1 = svg_element("title");
        t = text(ctx[2]);
      },
      m(target, anchor) {
        insert(target, title_1, anchor);
        append(title_1, t);
      },
      p(ctx2, dirty) {
        if (dirty & 4)
          set_data(t, ctx2[2]);
      },
      d(detaching) {
        if (detaching)
          detach(title_1);
      }
    };
  }
  function fallback_block6(ctx) {
    let if_block_anchor;
    let if_block = ctx[2] && create_if_block6(ctx);
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (ctx2[2]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block6(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach(if_block_anchor);
      }
    };
  }
  function create_fragment7(ctx) {
    let svg;
    let path0;
    let path1;
    let path2;
    let path3;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[11].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
    const default_slot_or_fallback = default_slot || fallback_block6(ctx);
    let svg_levels = [
      { "data-carbon-icon": "AlarmSubtract16" },
      { xmlns: "http://www.w3.org/2000/svg" },
      { viewBox: "0 0 32 32" },
      { fill: "currentColor" },
      { width: "16" },
      { height: "16" },
      { class: ctx[0] },
      { preserveAspectRatio: "xMidYMid meet" },
      { style: ctx[3] },
      { id: ctx[1] },
      ctx[4]
    ];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    return {
      c() {
        svg = svg_element("svg");
        path0 = svg_element("path");
        path1 = svg_element("path");
        path2 = svg_element("path");
        path3 = svg_element("path");
        if (default_slot_or_fallback)
          default_slot_or_fallback.c();
        attr(path0, "d", "M16,28A11,11,0,1,1,27,17,11,11,0,0,1,16,28ZM16,8a9,9,0,1,0,9,9A9,9,0,0,0,16,8Z");
        attr(path1, "d", "M3.96 5.5H9.030000000000001V7.5H3.96z");
        attr(path1, "transform", "rotate(-45.06 6.502 6.497)");
        attr(path2, "d", "M24.5 3.96H26.5V9.030000000000001H24.5z");
        attr(path2, "transform", "rotate(-44.94 25.5 6.498)");
        attr(path3, "d", "M11 16H21V18H11z");
        set_svg_attributes(svg, svg_data);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path0);
        append(svg, path1);
        append(svg, path2);
        append(svg, path3);
        if (default_slot_or_fallback) {
          default_slot_or_fallback.m(svg, null);
        }
        current = true;
        if (!mounted) {
          dispose = [
            listen(svg, "click", ctx[12]),
            listen(svg, "mouseover", ctx[13]),
            listen(svg, "mouseenter", ctx[14]),
            listen(svg, "mouseleave", ctx[15]),
            listen(svg, "keyup", ctx[16]),
            listen(svg, "keydown", ctx[17])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1024)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
          }
        } else {
          if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
            default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
          }
        }
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
          { "data-carbon-icon": "AlarmSubtract16" },
          { xmlns: "http://www.w3.org/2000/svg" },
          { viewBox: "0 0 32 32" },
          { fill: "currentColor" },
          { width: "16" },
          { height: "16" },
          (!current || dirty & 1) && { class: ctx2[0] },
          { preserveAspectRatio: "xMidYMid meet" },
          (!current || dirty & 8) && { style: ctx2[3] },
          (!current || dirty & 2) && { id: ctx2[1] },
          dirty & 16 && ctx2[4]
        ]));
      },
      i(local) {
        if (current)
          return;
        transition_in(default_slot_or_fallback, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot_or_fallback, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(svg);
        if (default_slot_or_fallback)
          default_slot_or_fallback.d(detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance7($$self, $$props, $$invalidate) {
    let ariaLabel;
    let ariaLabelledBy;
    let labelled;
    let attributes;
    let { $$slots: slots = {}, $$scope } = $$props;
    let { class: className = void 0 } = $$props;
    let { id = void 0 } = $$props;
    let { tabindex = void 0 } = $$props;
    let { focusable = false } = $$props;
    let { title: title2 = void 0 } = $$props;
    let { style = void 0 } = $$props;
    function click_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseover_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseenter_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseleave_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keyup_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keydown_handler(event) {
      bubble.call(this, $$self, event);
    }
    $$self.$$set = ($$new_props) => {
      $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
      if ("class" in $$new_props)
        $$invalidate(0, className = $$new_props.class);
      if ("id" in $$new_props)
        $$invalidate(1, id = $$new_props.id);
      if ("tabindex" in $$new_props)
        $$invalidate(5, tabindex = $$new_props.tabindex);
      if ("focusable" in $$new_props)
        $$invalidate(6, focusable = $$new_props.focusable);
      if ("title" in $$new_props)
        $$invalidate(2, title2 = $$new_props.title);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("$$scope" in $$new_props)
        $$invalidate(10, $$scope = $$new_props.$$scope);
    };
    $$self.$$.update = () => {
      $:
        $$invalidate(9, ariaLabel = $$props["aria-label"]);
      $:
        $$invalidate(8, ariaLabelledBy = $$props["aria-labelledby"]);
      if ($$self.$$.dirty & 772) {
        $:
          $$invalidate(7, labelled = ariaLabel || ariaLabelledBy || title2);
      }
      if ($$self.$$.dirty & 992) {
        $:
          $$invalidate(4, attributes = {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-hidden": labelled ? void 0 : true,
            role: labelled ? "img" : void 0,
            focusable: tabindex === "0" ? true : focusable,
            tabindex
          });
      }
    };
    $$props = exclude_internal_props($$props);
    return [
      className,
      id,
      title2,
      style,
      attributes,
      tabindex,
      focusable,
      labelled,
      ariaLabelledBy,
      ariaLabel,
      $$scope,
      slots,
      click_handler,
      mouseover_handler,
      mouseenter_handler,
      mouseleave_handler,
      keyup_handler,
      keydown_handler
    ];
  }
  var AlarmSubtract16 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance7, create_fragment7, safe_not_equal, {
        class: 0,
        id: 1,
        tabindex: 5,
        focusable: 6,
        title: 2,
        style: 3
      });
    }
  };
  var AlarmSubtract16_default = AlarmSubtract16;

  // elos-web/node_modules/carbon-icons-svelte/lib/AlarmSubtract16/index.js
  var AlarmSubtract16_default2 = AlarmSubtract16_default;

  // elos-web/node_modules/carbon-icons-svelte/lib/Api_116/Api_116.svelte
  function create_if_block7(ctx) {
    let title_1;
    let t;
    return {
      c() {
        title_1 = svg_element("title");
        t = text(ctx[2]);
      },
      m(target, anchor) {
        insert(target, title_1, anchor);
        append(title_1, t);
      },
      p(ctx2, dirty) {
        if (dirty & 4)
          set_data(t, ctx2[2]);
      },
      d(detaching) {
        if (detaching)
          detach(title_1);
      }
    };
  }
  function fallback_block7(ctx) {
    let if_block_anchor;
    let if_block = ctx[2] && create_if_block7(ctx);
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (ctx2[2]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block7(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach(if_block_anchor);
      }
    };
  }
  function create_fragment8(ctx) {
    let svg;
    let path;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[11].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
    const default_slot_or_fallback = default_slot || fallback_block7(ctx);
    let svg_levels = [
      { "data-carbon-icon": "Api_116" },
      { xmlns: "http://www.w3.org/2000/svg" },
      { viewBox: "0 0 32 32" },
      { fill: "currentColor" },
      { width: "16" },
      { height: "16" },
      { class: ctx[0] },
      { preserveAspectRatio: "xMidYMid meet" },
      { style: ctx[3] },
      { id: ctx[1] },
      ctx[4]
    ];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        if (default_slot_or_fallback)
          default_slot_or_fallback.c();
        attr(path, "d", "M8 9H4a2 2 0 00-2 2V23H4V18H8v5h2V11A2 2 0 008 9zM4 16V11H8v5zM22 11L25 11 25 21 22 21 22 23 30 23 30 21 27 21 27 11 30 11 30 9 22 9 22 11zM14 23H12V9h6a2 2 0 012 2v5a2 2 0 01-2 2H14zm0-7h4V11H14z");
        set_svg_attributes(svg, svg_data);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        if (default_slot_or_fallback) {
          default_slot_or_fallback.m(svg, null);
        }
        current = true;
        if (!mounted) {
          dispose = [
            listen(svg, "click", ctx[12]),
            listen(svg, "mouseover", ctx[13]),
            listen(svg, "mouseenter", ctx[14]),
            listen(svg, "mouseleave", ctx[15]),
            listen(svg, "keyup", ctx[16]),
            listen(svg, "keydown", ctx[17])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1024)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
          }
        } else {
          if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
            default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
          }
        }
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
          { "data-carbon-icon": "Api_116" },
          { xmlns: "http://www.w3.org/2000/svg" },
          { viewBox: "0 0 32 32" },
          { fill: "currentColor" },
          { width: "16" },
          { height: "16" },
          (!current || dirty & 1) && { class: ctx2[0] },
          { preserveAspectRatio: "xMidYMid meet" },
          (!current || dirty & 8) && { style: ctx2[3] },
          (!current || dirty & 2) && { id: ctx2[1] },
          dirty & 16 && ctx2[4]
        ]));
      },
      i(local) {
        if (current)
          return;
        transition_in(default_slot_or_fallback, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot_or_fallback, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(svg);
        if (default_slot_or_fallback)
          default_slot_or_fallback.d(detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance8($$self, $$props, $$invalidate) {
    let ariaLabel;
    let ariaLabelledBy;
    let labelled;
    let attributes;
    let { $$slots: slots = {}, $$scope } = $$props;
    let { class: className = void 0 } = $$props;
    let { id = void 0 } = $$props;
    let { tabindex = void 0 } = $$props;
    let { focusable = false } = $$props;
    let { title: title2 = void 0 } = $$props;
    let { style = void 0 } = $$props;
    function click_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseover_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseenter_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseleave_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keyup_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keydown_handler(event) {
      bubble.call(this, $$self, event);
    }
    $$self.$$set = ($$new_props) => {
      $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
      if ("class" in $$new_props)
        $$invalidate(0, className = $$new_props.class);
      if ("id" in $$new_props)
        $$invalidate(1, id = $$new_props.id);
      if ("tabindex" in $$new_props)
        $$invalidate(5, tabindex = $$new_props.tabindex);
      if ("focusable" in $$new_props)
        $$invalidate(6, focusable = $$new_props.focusable);
      if ("title" in $$new_props)
        $$invalidate(2, title2 = $$new_props.title);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("$$scope" in $$new_props)
        $$invalidate(10, $$scope = $$new_props.$$scope);
    };
    $$self.$$.update = () => {
      $:
        $$invalidate(9, ariaLabel = $$props["aria-label"]);
      $:
        $$invalidate(8, ariaLabelledBy = $$props["aria-labelledby"]);
      if ($$self.$$.dirty & 772) {
        $:
          $$invalidate(7, labelled = ariaLabel || ariaLabelledBy || title2);
      }
      if ($$self.$$.dirty & 992) {
        $:
          $$invalidate(4, attributes = {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-hidden": labelled ? void 0 : true,
            role: labelled ? "img" : void 0,
            focusable: tabindex === "0" ? true : focusable,
            tabindex
          });
      }
    };
    $$props = exclude_internal_props($$props);
    return [
      className,
      id,
      title2,
      style,
      attributes,
      tabindex,
      focusable,
      labelled,
      ariaLabelledBy,
      ariaLabel,
      $$scope,
      slots,
      click_handler,
      mouseover_handler,
      mouseenter_handler,
      mouseleave_handler,
      keyup_handler,
      keydown_handler
    ];
  }
  var Api_116 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance8, create_fragment8, safe_not_equal, {
        class: 0,
        id: 1,
        tabindex: 5,
        focusable: 6,
        title: 2,
        style: 3
      });
    }
  };
  var Api_116_default = Api_116;

  // elos-web/node_modules/carbon-icons-svelte/lib/Api_116/index.js
  var Api_116_default2 = Api_116_default;

  // elos-web/node_modules/carbon-icons-svelte/lib/App16/App16.svelte
  function create_if_block8(ctx) {
    let title_1;
    let t;
    return {
      c() {
        title_1 = svg_element("title");
        t = text(ctx[2]);
      },
      m(target, anchor) {
        insert(target, title_1, anchor);
        append(title_1, t);
      },
      p(ctx2, dirty) {
        if (dirty & 4)
          set_data(t, ctx2[2]);
      },
      d(detaching) {
        if (detaching)
          detach(title_1);
      }
    };
  }
  function fallback_block8(ctx) {
    let if_block_anchor;
    let if_block = ctx[2] && create_if_block8(ctx);
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (ctx2[2]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block8(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach(if_block_anchor);
      }
    };
  }
  function create_fragment9(ctx) {
    let svg;
    let path;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[11].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
    const default_slot_or_fallback = default_slot || fallback_block8(ctx);
    let svg_levels = [
      { "data-carbon-icon": "App16" },
      { xmlns: "http://www.w3.org/2000/svg" },
      { viewBox: "0 0 32 32" },
      { fill: "currentColor" },
      { width: "16" },
      { height: "16" },
      { class: ctx[0] },
      { preserveAspectRatio: "xMidYMid meet" },
      { style: ctx[3] },
      { id: ctx[1] },
      ctx[4]
    ];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        if (default_slot_or_fallback)
          default_slot_or_fallback.c();
        attr(path, "d", "M28 10H22V24h2V20h4a2.0027 2.0027 0 002-2V12A2.0023 2.0023 0 0028 10zm-4 8V12h4v6zM18 10H12V24h2V20h4a2.0027 2.0027 0 002-2V12A2.0023 2.0023 0 0018 10zm-4 8V12h4v6zM8 10H3v2H8v2H4a2 2 0 00-2 2v2a2 2 0 002 2h6V12A2.0023 2.0023 0 008 10zm0 8H4V16H8z");
        set_svg_attributes(svg, svg_data);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        if (default_slot_or_fallback) {
          default_slot_or_fallback.m(svg, null);
        }
        current = true;
        if (!mounted) {
          dispose = [
            listen(svg, "click", ctx[12]),
            listen(svg, "mouseover", ctx[13]),
            listen(svg, "mouseenter", ctx[14]),
            listen(svg, "mouseleave", ctx[15]),
            listen(svg, "keyup", ctx[16]),
            listen(svg, "keydown", ctx[17])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1024)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
          }
        } else {
          if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
            default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
          }
        }
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
          { "data-carbon-icon": "App16" },
          { xmlns: "http://www.w3.org/2000/svg" },
          { viewBox: "0 0 32 32" },
          { fill: "currentColor" },
          { width: "16" },
          { height: "16" },
          (!current || dirty & 1) && { class: ctx2[0] },
          { preserveAspectRatio: "xMidYMid meet" },
          (!current || dirty & 8) && { style: ctx2[3] },
          (!current || dirty & 2) && { id: ctx2[1] },
          dirty & 16 && ctx2[4]
        ]));
      },
      i(local) {
        if (current)
          return;
        transition_in(default_slot_or_fallback, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot_or_fallback, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(svg);
        if (default_slot_or_fallback)
          default_slot_or_fallback.d(detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance9($$self, $$props, $$invalidate) {
    let ariaLabel;
    let ariaLabelledBy;
    let labelled;
    let attributes;
    let { $$slots: slots = {}, $$scope } = $$props;
    let { class: className = void 0 } = $$props;
    let { id = void 0 } = $$props;
    let { tabindex = void 0 } = $$props;
    let { focusable = false } = $$props;
    let { title: title2 = void 0 } = $$props;
    let { style = void 0 } = $$props;
    function click_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseover_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseenter_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseleave_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keyup_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keydown_handler(event) {
      bubble.call(this, $$self, event);
    }
    $$self.$$set = ($$new_props) => {
      $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
      if ("class" in $$new_props)
        $$invalidate(0, className = $$new_props.class);
      if ("id" in $$new_props)
        $$invalidate(1, id = $$new_props.id);
      if ("tabindex" in $$new_props)
        $$invalidate(5, tabindex = $$new_props.tabindex);
      if ("focusable" in $$new_props)
        $$invalidate(6, focusable = $$new_props.focusable);
      if ("title" in $$new_props)
        $$invalidate(2, title2 = $$new_props.title);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("$$scope" in $$new_props)
        $$invalidate(10, $$scope = $$new_props.$$scope);
    };
    $$self.$$.update = () => {
      $:
        $$invalidate(9, ariaLabel = $$props["aria-label"]);
      $:
        $$invalidate(8, ariaLabelledBy = $$props["aria-labelledby"]);
      if ($$self.$$.dirty & 772) {
        $:
          $$invalidate(7, labelled = ariaLabel || ariaLabelledBy || title2);
      }
      if ($$self.$$.dirty & 992) {
        $:
          $$invalidate(4, attributes = {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-hidden": labelled ? void 0 : true,
            role: labelled ? "img" : void 0,
            focusable: tabindex === "0" ? true : focusable,
            tabindex
          });
      }
    };
    $$props = exclude_internal_props($$props);
    return [
      className,
      id,
      title2,
      style,
      attributes,
      tabindex,
      focusable,
      labelled,
      ariaLabelledBy,
      ariaLabel,
      $$scope,
      slots,
      click_handler,
      mouseover_handler,
      mouseenter_handler,
      mouseleave_handler,
      keyup_handler,
      keydown_handler
    ];
  }
  var App16 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance9, create_fragment9, safe_not_equal, {
        class: 0,
        id: 1,
        tabindex: 5,
        focusable: 6,
        title: 2,
        style: 3
      });
    }
  };
  var App16_default = App16;

  // elos-web/node_modules/carbon-icons-svelte/lib/App16/index.js
  var App16_default2 = App16_default;

  // elos-web/node_modules/carbon-icons-svelte/lib/AudioConsole16/AudioConsole16.svelte
  function create_if_block9(ctx) {
    let title_1;
    let t;
    return {
      c() {
        title_1 = svg_element("title");
        t = text(ctx[2]);
      },
      m(target, anchor) {
        insert(target, title_1, anchor);
        append(title_1, t);
      },
      p(ctx2, dirty) {
        if (dirty & 4)
          set_data(t, ctx2[2]);
      },
      d(detaching) {
        if (detaching)
          detach(title_1);
      }
    };
  }
  function fallback_block9(ctx) {
    let if_block_anchor;
    let if_block = ctx[2] && create_if_block9(ctx);
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (ctx2[2]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block9(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach(if_block_anchor);
      }
    };
  }
  function create_fragment10(ctx) {
    let svg;
    let path;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[11].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
    const default_slot_or_fallback = default_slot || fallback_block9(ctx);
    let svg_levels = [
      { "data-carbon-icon": "AudioConsole16" },
      { xmlns: "http://www.w3.org/2000/svg" },
      { viewBox: "0 0 32 32" },
      { fill: "currentColor" },
      { width: "16" },
      { height: "16" },
      { class: ctx[0] },
      { preserveAspectRatio: "xMidYMid meet" },
      { style: ctx[3] },
      { id: ctx[1] },
      ctx[4]
    ];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        if (default_slot_or_fallback)
          default_slot_or_fallback.c();
        attr(path, "d", "M28 14H27V2H25V14H24a2.0019 2.0019 0 00-2 2v2a2.0023 2.0023 0 002 2h1V30h2V20h1a2.0027 2.0027 0 002-2V16A2.0023 2.0023 0 0028 14zm0 4H24V16h4zM18 6H17V2H15V6H14a2.0019 2.0019 0 00-2 2v2a2.0019 2.0019 0 002 2h1V30h2V12h1a2.002 2.002 0 002-2V8A2.002 2.002 0 0018 6zm0 4H14V8h4zM8 20H7V2H5V20H4a2.0023 2.0023 0 00-2 2v2a2.0023 2.0023 0 002 2H5v4H7V26H8a2.0023 2.0023 0 002-2V22A2.0023 2.0023 0 008 20zm0 4H4V22H8z");
        attr(path, "transform", "translate(0 .005)");
        set_svg_attributes(svg, svg_data);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        if (default_slot_or_fallback) {
          default_slot_or_fallback.m(svg, null);
        }
        current = true;
        if (!mounted) {
          dispose = [
            listen(svg, "click", ctx[12]),
            listen(svg, "mouseover", ctx[13]),
            listen(svg, "mouseenter", ctx[14]),
            listen(svg, "mouseleave", ctx[15]),
            listen(svg, "keyup", ctx[16]),
            listen(svg, "keydown", ctx[17])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1024)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
          }
        } else {
          if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
            default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
          }
        }
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
          { "data-carbon-icon": "AudioConsole16" },
          { xmlns: "http://www.w3.org/2000/svg" },
          { viewBox: "0 0 32 32" },
          { fill: "currentColor" },
          { width: "16" },
          { height: "16" },
          (!current || dirty & 1) && { class: ctx2[0] },
          { preserveAspectRatio: "xMidYMid meet" },
          (!current || dirty & 8) && { style: ctx2[3] },
          (!current || dirty & 2) && { id: ctx2[1] },
          dirty & 16 && ctx2[4]
        ]));
      },
      i(local) {
        if (current)
          return;
        transition_in(default_slot_or_fallback, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot_or_fallback, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(svg);
        if (default_slot_or_fallback)
          default_slot_or_fallback.d(detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance10($$self, $$props, $$invalidate) {
    let ariaLabel;
    let ariaLabelledBy;
    let labelled;
    let attributes;
    let { $$slots: slots = {}, $$scope } = $$props;
    let { class: className = void 0 } = $$props;
    let { id = void 0 } = $$props;
    let { tabindex = void 0 } = $$props;
    let { focusable = false } = $$props;
    let { title: title2 = void 0 } = $$props;
    let { style = void 0 } = $$props;
    function click_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseover_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseenter_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseleave_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keyup_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keydown_handler(event) {
      bubble.call(this, $$self, event);
    }
    $$self.$$set = ($$new_props) => {
      $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
      if ("class" in $$new_props)
        $$invalidate(0, className = $$new_props.class);
      if ("id" in $$new_props)
        $$invalidate(1, id = $$new_props.id);
      if ("tabindex" in $$new_props)
        $$invalidate(5, tabindex = $$new_props.tabindex);
      if ("focusable" in $$new_props)
        $$invalidate(6, focusable = $$new_props.focusable);
      if ("title" in $$new_props)
        $$invalidate(2, title2 = $$new_props.title);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("$$scope" in $$new_props)
        $$invalidate(10, $$scope = $$new_props.$$scope);
    };
    $$self.$$.update = () => {
      $:
        $$invalidate(9, ariaLabel = $$props["aria-label"]);
      $:
        $$invalidate(8, ariaLabelledBy = $$props["aria-labelledby"]);
      if ($$self.$$.dirty & 772) {
        $:
          $$invalidate(7, labelled = ariaLabel || ariaLabelledBy || title2);
      }
      if ($$self.$$.dirty & 992) {
        $:
          $$invalidate(4, attributes = {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-hidden": labelled ? void 0 : true,
            role: labelled ? "img" : void 0,
            focusable: tabindex === "0" ? true : focusable,
            tabindex
          });
      }
    };
    $$props = exclude_internal_props($$props);
    return [
      className,
      id,
      title2,
      style,
      attributes,
      tabindex,
      focusable,
      labelled,
      ariaLabelledBy,
      ariaLabel,
      $$scope,
      slots,
      click_handler,
      mouseover_handler,
      mouseenter_handler,
      mouseleave_handler,
      keyup_handler,
      keydown_handler
    ];
  }
  var AudioConsole16 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance10, create_fragment10, safe_not_equal, {
        class: 0,
        id: 1,
        tabindex: 5,
        focusable: 6,
        title: 2,
        style: 3
      });
    }
  };
  var AudioConsole16_default = AudioConsole16;

  // elos-web/node_modules/carbon-icons-svelte/lib/AudioConsole16/index.js
  var AudioConsole16_default2 = AudioConsole16_default;

  // elos-web/node_modules/carbon-icons-svelte/lib/Awake16/Awake16.svelte
  function create_if_block10(ctx) {
    let title_1;
    let t;
    return {
      c() {
        title_1 = svg_element("title");
        t = text(ctx[2]);
      },
      m(target, anchor) {
        insert(target, title_1, anchor);
        append(title_1, t);
      },
      p(ctx2, dirty) {
        if (dirty & 4)
          set_data(t, ctx2[2]);
      },
      d(detaching) {
        if (detaching)
          detach(title_1);
      }
    };
  }
  function fallback_block10(ctx) {
    let if_block_anchor;
    let if_block = ctx[2] && create_if_block10(ctx);
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (ctx2[2]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block10(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach(if_block_anchor);
      }
    };
  }
  function create_fragment11(ctx) {
    let svg;
    let path0;
    let path1;
    let path2;
    let path3;
    let path4;
    let path5;
    let path6;
    let path7;
    let path8;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[11].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
    const default_slot_or_fallback = default_slot || fallback_block10(ctx);
    let svg_levels = [
      { "data-carbon-icon": "Awake16" },
      { xmlns: "http://www.w3.org/2000/svg" },
      { viewBox: "0 0 16 16" },
      { fill: "currentColor" },
      { width: "16" },
      { height: "16" },
      { class: ctx[0] },
      { preserveAspectRatio: "xMidYMid meet" },
      { style: ctx[3] },
      { id: ctx[1] },
      ctx[4]
    ];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    return {
      c() {
        svg = svg_element("svg");
        path0 = svg_element("path");
        path1 = svg_element("path");
        path2 = svg_element("path");
        path3 = svg_element("path");
        path4 = svg_element("path");
        path5 = svg_element("path");
        path6 = svg_element("path");
        path7 = svg_element("path");
        path8 = svg_element("path");
        if (default_slot_or_fallback)
          default_slot_or_fallback.c();
        attr(path0, "d", "M7.5 1H8.5V3.5H7.5z");
        attr(path1, "d", "M10.8 3.4H13.3V4.4H10.8z");
        attr(path1, "transform", "rotate(-45.001 12.074 3.922)");
        attr(path2, "d", "M12.5 7.5H15V8.5H12.5z");
        attr(path3, "d", "M11.6 10.8H12.6V13.3H11.6z");
        attr(path3, "transform", "rotate(-45.001 12.077 12.075)");
        attr(path4, "d", "M7.5 12.5H8.5V15H7.5z");
        attr(path5, "d", "M2.7 11.6H5.2V12.6H2.7z");
        attr(path5, "transform", "rotate(-45.001 3.929 12.078)");
        attr(path6, "d", "M1 7.5H3.5V8.5H1z");
        attr(path7, "d", "M3.4 2.7H4.4V5.2H3.4z");
        attr(path7, "transform", "rotate(-45.001 3.926 3.925)");
        attr(path8, "d", "M8,6c1.1,0,2,0.9,2,2s-0.9,2-2,2S6,9.1,6,8S6.9,6,8,6 M8,5C6.3,5,5,6.3,5,8s1.3,3,3,3s3-1.3,3-3S9.7,5,8,5z");
        set_svg_attributes(svg, svg_data);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path0);
        append(svg, path1);
        append(svg, path2);
        append(svg, path3);
        append(svg, path4);
        append(svg, path5);
        append(svg, path6);
        append(svg, path7);
        append(svg, path8);
        if (default_slot_or_fallback) {
          default_slot_or_fallback.m(svg, null);
        }
        current = true;
        if (!mounted) {
          dispose = [
            listen(svg, "click", ctx[12]),
            listen(svg, "mouseover", ctx[13]),
            listen(svg, "mouseenter", ctx[14]),
            listen(svg, "mouseleave", ctx[15]),
            listen(svg, "keyup", ctx[16]),
            listen(svg, "keydown", ctx[17])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1024)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
          }
        } else {
          if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
            default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
          }
        }
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
          { "data-carbon-icon": "Awake16" },
          { xmlns: "http://www.w3.org/2000/svg" },
          { viewBox: "0 0 16 16" },
          { fill: "currentColor" },
          { width: "16" },
          { height: "16" },
          (!current || dirty & 1) && { class: ctx2[0] },
          { preserveAspectRatio: "xMidYMid meet" },
          (!current || dirty & 8) && { style: ctx2[3] },
          (!current || dirty & 2) && { id: ctx2[1] },
          dirty & 16 && ctx2[4]
        ]));
      },
      i(local) {
        if (current)
          return;
        transition_in(default_slot_or_fallback, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot_or_fallback, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(svg);
        if (default_slot_or_fallback)
          default_slot_or_fallback.d(detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance11($$self, $$props, $$invalidate) {
    let ariaLabel;
    let ariaLabelledBy;
    let labelled;
    let attributes;
    let { $$slots: slots = {}, $$scope } = $$props;
    let { class: className = void 0 } = $$props;
    let { id = void 0 } = $$props;
    let { tabindex = void 0 } = $$props;
    let { focusable = false } = $$props;
    let { title: title2 = void 0 } = $$props;
    let { style = void 0 } = $$props;
    function click_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseover_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseenter_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseleave_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keyup_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keydown_handler(event) {
      bubble.call(this, $$self, event);
    }
    $$self.$$set = ($$new_props) => {
      $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
      if ("class" in $$new_props)
        $$invalidate(0, className = $$new_props.class);
      if ("id" in $$new_props)
        $$invalidate(1, id = $$new_props.id);
      if ("tabindex" in $$new_props)
        $$invalidate(5, tabindex = $$new_props.tabindex);
      if ("focusable" in $$new_props)
        $$invalidate(6, focusable = $$new_props.focusable);
      if ("title" in $$new_props)
        $$invalidate(2, title2 = $$new_props.title);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("$$scope" in $$new_props)
        $$invalidate(10, $$scope = $$new_props.$$scope);
    };
    $$self.$$.update = () => {
      $:
        $$invalidate(9, ariaLabel = $$props["aria-label"]);
      $:
        $$invalidate(8, ariaLabelledBy = $$props["aria-labelledby"]);
      if ($$self.$$.dirty & 772) {
        $:
          $$invalidate(7, labelled = ariaLabel || ariaLabelledBy || title2);
      }
      if ($$self.$$.dirty & 992) {
        $:
          $$invalidate(4, attributes = {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-hidden": labelled ? void 0 : true,
            role: labelled ? "img" : void 0,
            focusable: tabindex === "0" ? true : focusable,
            tabindex
          });
      }
    };
    $$props = exclude_internal_props($$props);
    return [
      className,
      id,
      title2,
      style,
      attributes,
      tabindex,
      focusable,
      labelled,
      ariaLabelledBy,
      ariaLabel,
      $$scope,
      slots,
      click_handler,
      mouseover_handler,
      mouseenter_handler,
      mouseleave_handler,
      keyup_handler,
      keydown_handler
    ];
  }
  var Awake16 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance11, create_fragment11, safe_not_equal, {
        class: 0,
        id: 1,
        tabindex: 5,
        focusable: 6,
        title: 2,
        style: 3
      });
    }
  };
  var Awake16_default = Awake16;

  // elos-web/node_modules/carbon-icons-svelte/lib/Awake16/index.js
  var Awake16_default2 = Awake16_default;

  // elos-web/node_modules/carbon-icons-svelte/lib/Categories16/Categories16.svelte
  function create_if_block11(ctx) {
    let title_1;
    let t;
    return {
      c() {
        title_1 = svg_element("title");
        t = text(ctx[2]);
      },
      m(target, anchor) {
        insert(target, title_1, anchor);
        append(title_1, t);
      },
      p(ctx2, dirty) {
        if (dirty & 4)
          set_data(t, ctx2[2]);
      },
      d(detaching) {
        if (detaching)
          detach(title_1);
      }
    };
  }
  function fallback_block11(ctx) {
    let if_block_anchor;
    let if_block = ctx[2] && create_if_block11(ctx);
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (ctx2[2]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block11(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach(if_block_anchor);
      }
    };
  }
  function create_fragment12(ctx) {
    let svg;
    let path;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[11].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
    const default_slot_or_fallback = default_slot || fallback_block11(ctx);
    let svg_levels = [
      { "data-carbon-icon": "Categories16" },
      { xmlns: "http://www.w3.org/2000/svg" },
      { viewBox: "0 0 32 32" },
      { fill: "currentColor" },
      { width: "16" },
      { height: "16" },
      { class: ctx[0] },
      { preserveAspectRatio: "xMidYMid meet" },
      { style: ctx[3] },
      { id: ctx[1] },
      ctx[4]
    ];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        if (default_slot_or_fallback)
          default_slot_or_fallback.c();
        attr(path, "d", "M6.76 6l.45.89L7.76 8H12v5H4V6H6.76m.62-2H3A1 1 0 002 5v9a1 1 0 001 1H13a1 1 0 001-1V7a1 1 0 00-1-1H9L8.28 4.55A1 1 0 007.38 4zM22.76 6l.45.89L23.76 8H28v5H20V6h2.76m.62-2H19a1 1 0 00-1 1v9a1 1 0 001 1H29a1 1 0 001-1V7a1 1 0 00-1-1H25l-.72-1.45a1 1 0 00-.9-.55zM6.76 19l.45.89L7.76 21H12v5H4V19H6.76m.62-2H3a1 1 0 00-1 1v9a1 1 0 001 1H13a1 1 0 001-1V20a1 1 0 00-1-1H9l-.72-1.45a1 1 0 00-.9-.55zM22.76 19l.45.89L23.76 21H28v5H20V19h2.76m.62-2H19a1 1 0 00-1 1v9a1 1 0 001 1H29a1 1 0 001-1V20a1 1 0 00-1-1H25l-.72-1.45a1 1 0 00-.9-.55z");
        set_svg_attributes(svg, svg_data);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        if (default_slot_or_fallback) {
          default_slot_or_fallback.m(svg, null);
        }
        current = true;
        if (!mounted) {
          dispose = [
            listen(svg, "click", ctx[12]),
            listen(svg, "mouseover", ctx[13]),
            listen(svg, "mouseenter", ctx[14]),
            listen(svg, "mouseleave", ctx[15]),
            listen(svg, "keyup", ctx[16]),
            listen(svg, "keydown", ctx[17])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1024)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
          }
        } else {
          if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
            default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
          }
        }
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
          { "data-carbon-icon": "Categories16" },
          { xmlns: "http://www.w3.org/2000/svg" },
          { viewBox: "0 0 32 32" },
          { fill: "currentColor" },
          { width: "16" },
          { height: "16" },
          (!current || dirty & 1) && { class: ctx2[0] },
          { preserveAspectRatio: "xMidYMid meet" },
          (!current || dirty & 8) && { style: ctx2[3] },
          (!current || dirty & 2) && { id: ctx2[1] },
          dirty & 16 && ctx2[4]
        ]));
      },
      i(local) {
        if (current)
          return;
        transition_in(default_slot_or_fallback, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot_or_fallback, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(svg);
        if (default_slot_or_fallback)
          default_slot_or_fallback.d(detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance12($$self, $$props, $$invalidate) {
    let ariaLabel;
    let ariaLabelledBy;
    let labelled;
    let attributes;
    let { $$slots: slots = {}, $$scope } = $$props;
    let { class: className = void 0 } = $$props;
    let { id = void 0 } = $$props;
    let { tabindex = void 0 } = $$props;
    let { focusable = false } = $$props;
    let { title: title2 = void 0 } = $$props;
    let { style = void 0 } = $$props;
    function click_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseover_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseenter_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseleave_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keyup_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keydown_handler(event) {
      bubble.call(this, $$self, event);
    }
    $$self.$$set = ($$new_props) => {
      $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
      if ("class" in $$new_props)
        $$invalidate(0, className = $$new_props.class);
      if ("id" in $$new_props)
        $$invalidate(1, id = $$new_props.id);
      if ("tabindex" in $$new_props)
        $$invalidate(5, tabindex = $$new_props.tabindex);
      if ("focusable" in $$new_props)
        $$invalidate(6, focusable = $$new_props.focusable);
      if ("title" in $$new_props)
        $$invalidate(2, title2 = $$new_props.title);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("$$scope" in $$new_props)
        $$invalidate(10, $$scope = $$new_props.$$scope);
    };
    $$self.$$.update = () => {
      $:
        $$invalidate(9, ariaLabel = $$props["aria-label"]);
      $:
        $$invalidate(8, ariaLabelledBy = $$props["aria-labelledby"]);
      if ($$self.$$.dirty & 772) {
        $:
          $$invalidate(7, labelled = ariaLabel || ariaLabelledBy || title2);
      }
      if ($$self.$$.dirty & 992) {
        $:
          $$invalidate(4, attributes = {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-hidden": labelled ? void 0 : true,
            role: labelled ? "img" : void 0,
            focusable: tabindex === "0" ? true : focusable,
            tabindex
          });
      }
    };
    $$props = exclude_internal_props($$props);
    return [
      className,
      id,
      title2,
      style,
      attributes,
      tabindex,
      focusable,
      labelled,
      ariaLabelledBy,
      ariaLabel,
      $$scope,
      slots,
      click_handler,
      mouseover_handler,
      mouseenter_handler,
      mouseleave_handler,
      keyup_handler,
      keydown_handler
    ];
  }
  var Categories16 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance12, create_fragment12, safe_not_equal, {
        class: 0,
        id: 1,
        tabindex: 5,
        focusable: 6,
        title: 2,
        style: 3
      });
    }
  };
  var Categories16_default = Categories16;

  // elos-web/node_modules/carbon-icons-svelte/lib/Categories16/index.js
  var Categories16_default2 = Categories16_default;

  // elos-web/node_modules/carbon-icons-svelte/lib/CheckmarkFilled16/CheckmarkFilled16.svelte
  function create_if_block12(ctx) {
    let title_1;
    let t;
    return {
      c() {
        title_1 = svg_element("title");
        t = text(ctx[2]);
      },
      m(target, anchor) {
        insert(target, title_1, anchor);
        append(title_1, t);
      },
      p(ctx2, dirty) {
        if (dirty & 4)
          set_data(t, ctx2[2]);
      },
      d(detaching) {
        if (detaching)
          detach(title_1);
      }
    };
  }
  function fallback_block12(ctx) {
    let if_block_anchor;
    let if_block = ctx[2] && create_if_block12(ctx);
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (ctx2[2]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block12(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach(if_block_anchor);
      }
    };
  }
  function create_fragment13(ctx) {
    let svg;
    let path0;
    let path1;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[11].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
    const default_slot_or_fallback = default_slot || fallback_block12(ctx);
    let svg_levels = [
      { "data-carbon-icon": "CheckmarkFilled16" },
      { xmlns: "http://www.w3.org/2000/svg" },
      { viewBox: "0 0 16 16" },
      { fill: "currentColor" },
      { width: "16" },
      { height: "16" },
      { class: ctx[0] },
      { preserveAspectRatio: "xMidYMid meet" },
      { style: ctx[3] },
      { id: ctx[1] },
      ctx[4]
    ];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    return {
      c() {
        svg = svg_element("svg");
        path0 = svg_element("path");
        path1 = svg_element("path");
        if (default_slot_or_fallback)
          default_slot_or_fallback.c();
        attr(path0, "d", "M8,1C4.1,1,1,4.1,1,8c0,3.9,3.1,7,7,7s7-3.1,7-7C15,4.1,11.9,1,8,1z M7,11L4.3,8.3l0.9-0.8L7,9.3l4-3.9l0.9,0.8L7,11z");
        attr(path1, "d", "M7,11L4.3,8.3l0.9-0.8L7,9.3l4-3.9l0.9,0.8L7,11z");
        attr(path1, "data-icon-path", "inner-path");
        attr(path1, "opacity", "0");
        set_svg_attributes(svg, svg_data);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path0);
        append(svg, path1);
        if (default_slot_or_fallback) {
          default_slot_or_fallback.m(svg, null);
        }
        current = true;
        if (!mounted) {
          dispose = [
            listen(svg, "click", ctx[12]),
            listen(svg, "mouseover", ctx[13]),
            listen(svg, "mouseenter", ctx[14]),
            listen(svg, "mouseleave", ctx[15]),
            listen(svg, "keyup", ctx[16]),
            listen(svg, "keydown", ctx[17])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1024)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
          }
        } else {
          if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
            default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
          }
        }
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
          { "data-carbon-icon": "CheckmarkFilled16" },
          { xmlns: "http://www.w3.org/2000/svg" },
          { viewBox: "0 0 16 16" },
          { fill: "currentColor" },
          { width: "16" },
          { height: "16" },
          (!current || dirty & 1) && { class: ctx2[0] },
          { preserveAspectRatio: "xMidYMid meet" },
          (!current || dirty & 8) && { style: ctx2[3] },
          (!current || dirty & 2) && { id: ctx2[1] },
          dirty & 16 && ctx2[4]
        ]));
      },
      i(local) {
        if (current)
          return;
        transition_in(default_slot_or_fallback, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot_or_fallback, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(svg);
        if (default_slot_or_fallback)
          default_slot_or_fallback.d(detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance13($$self, $$props, $$invalidate) {
    let ariaLabel;
    let ariaLabelledBy;
    let labelled;
    let attributes;
    let { $$slots: slots = {}, $$scope } = $$props;
    let { class: className = void 0 } = $$props;
    let { id = void 0 } = $$props;
    let { tabindex = void 0 } = $$props;
    let { focusable = false } = $$props;
    let { title: title2 = void 0 } = $$props;
    let { style = void 0 } = $$props;
    function click_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseover_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseenter_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseleave_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keyup_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keydown_handler(event) {
      bubble.call(this, $$self, event);
    }
    $$self.$$set = ($$new_props) => {
      $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
      if ("class" in $$new_props)
        $$invalidate(0, className = $$new_props.class);
      if ("id" in $$new_props)
        $$invalidate(1, id = $$new_props.id);
      if ("tabindex" in $$new_props)
        $$invalidate(5, tabindex = $$new_props.tabindex);
      if ("focusable" in $$new_props)
        $$invalidate(6, focusable = $$new_props.focusable);
      if ("title" in $$new_props)
        $$invalidate(2, title2 = $$new_props.title);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("$$scope" in $$new_props)
        $$invalidate(10, $$scope = $$new_props.$$scope);
    };
    $$self.$$.update = () => {
      $:
        $$invalidate(9, ariaLabel = $$props["aria-label"]);
      $:
        $$invalidate(8, ariaLabelledBy = $$props["aria-labelledby"]);
      if ($$self.$$.dirty & 772) {
        $:
          $$invalidate(7, labelled = ariaLabel || ariaLabelledBy || title2);
      }
      if ($$self.$$.dirty & 992) {
        $:
          $$invalidate(4, attributes = {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-hidden": labelled ? void 0 : true,
            role: labelled ? "img" : void 0,
            focusable: tabindex === "0" ? true : focusable,
            tabindex
          });
      }
    };
    $$props = exclude_internal_props($$props);
    return [
      className,
      id,
      title2,
      style,
      attributes,
      tabindex,
      focusable,
      labelled,
      ariaLabelledBy,
      ariaLabel,
      $$scope,
      slots,
      click_handler,
      mouseover_handler,
      mouseenter_handler,
      mouseleave_handler,
      keyup_handler,
      keydown_handler
    ];
  }
  var CheckmarkFilled16 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance13, create_fragment13, safe_not_equal, {
        class: 0,
        id: 1,
        tabindex: 5,
        focusable: 6,
        title: 2,
        style: 3
      });
    }
  };
  var CheckmarkFilled16_default = CheckmarkFilled16;

  // elos-web/node_modules/carbon-icons-svelte/lib/CheckmarkFilled16/index.js
  var CheckmarkFilled16_default2 = CheckmarkFilled16_default;

  // elos-web/node_modules/carbon-icons-svelte/lib/CollapseCategories16/CollapseCategories16.svelte
  function create_if_block13(ctx) {
    let title_1;
    let t;
    return {
      c() {
        title_1 = svg_element("title");
        t = text(ctx[2]);
      },
      m(target, anchor) {
        insert(target, title_1, anchor);
        append(title_1, t);
      },
      p(ctx2, dirty) {
        if (dirty & 4)
          set_data(t, ctx2[2]);
      },
      d(detaching) {
        if (detaching)
          detach(title_1);
      }
    };
  }
  function fallback_block13(ctx) {
    let if_block_anchor;
    let if_block = ctx[2] && create_if_block13(ctx);
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (ctx2[2]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block13(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach(if_block_anchor);
      }
    };
  }
  function create_fragment14(ctx) {
    let svg;
    let path;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[11].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
    const default_slot_or_fallback = default_slot || fallback_block13(ctx);
    let svg_levels = [
      {
        "data-carbon-icon": "CollapseCategories16"
      },
      { xmlns: "http://www.w3.org/2000/svg" },
      { viewBox: "0 0 32 32" },
      { fill: "currentColor" },
      { width: "16" },
      { height: "16" },
      { class: ctx[0] },
      { preserveAspectRatio: "xMidYMid meet" },
      { style: ctx[3] },
      { id: ctx[1] },
      ctx[4]
    ];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        if (default_slot_or_fallback)
          default_slot_or_fallback.c();
        attr(path, "d", "M14 25H28V27H14zM7.17 26L4.59 28.58 6 30 10 26 6 22 4.58 23.41 7.17 26zM14 15H28V17H14zM7.17 16L4.59 18.58 6 20 10 16 6 12 4.58 13.41 7.17 16zM14 5H28V7H14zM7.17 6L4.59 8.58 6 10 10 6 6 2 4.58 3.41 7.17 6z");
        set_svg_attributes(svg, svg_data);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        if (default_slot_or_fallback) {
          default_slot_or_fallback.m(svg, null);
        }
        current = true;
        if (!mounted) {
          dispose = [
            listen(svg, "click", ctx[12]),
            listen(svg, "mouseover", ctx[13]),
            listen(svg, "mouseenter", ctx[14]),
            listen(svg, "mouseleave", ctx[15]),
            listen(svg, "keyup", ctx[16]),
            listen(svg, "keydown", ctx[17])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1024)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
          }
        } else {
          if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
            default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
          }
        }
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
          {
            "data-carbon-icon": "CollapseCategories16"
          },
          { xmlns: "http://www.w3.org/2000/svg" },
          { viewBox: "0 0 32 32" },
          { fill: "currentColor" },
          { width: "16" },
          { height: "16" },
          (!current || dirty & 1) && { class: ctx2[0] },
          { preserveAspectRatio: "xMidYMid meet" },
          (!current || dirty & 8) && { style: ctx2[3] },
          (!current || dirty & 2) && { id: ctx2[1] },
          dirty & 16 && ctx2[4]
        ]));
      },
      i(local) {
        if (current)
          return;
        transition_in(default_slot_or_fallback, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot_or_fallback, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(svg);
        if (default_slot_or_fallback)
          default_slot_or_fallback.d(detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance14($$self, $$props, $$invalidate) {
    let ariaLabel;
    let ariaLabelledBy;
    let labelled;
    let attributes;
    let { $$slots: slots = {}, $$scope } = $$props;
    let { class: className = void 0 } = $$props;
    let { id = void 0 } = $$props;
    let { tabindex = void 0 } = $$props;
    let { focusable = false } = $$props;
    let { title: title2 = void 0 } = $$props;
    let { style = void 0 } = $$props;
    function click_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseover_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseenter_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseleave_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keyup_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keydown_handler(event) {
      bubble.call(this, $$self, event);
    }
    $$self.$$set = ($$new_props) => {
      $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
      if ("class" in $$new_props)
        $$invalidate(0, className = $$new_props.class);
      if ("id" in $$new_props)
        $$invalidate(1, id = $$new_props.id);
      if ("tabindex" in $$new_props)
        $$invalidate(5, tabindex = $$new_props.tabindex);
      if ("focusable" in $$new_props)
        $$invalidate(6, focusable = $$new_props.focusable);
      if ("title" in $$new_props)
        $$invalidate(2, title2 = $$new_props.title);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("$$scope" in $$new_props)
        $$invalidate(10, $$scope = $$new_props.$$scope);
    };
    $$self.$$.update = () => {
      $:
        $$invalidate(9, ariaLabel = $$props["aria-label"]);
      $:
        $$invalidate(8, ariaLabelledBy = $$props["aria-labelledby"]);
      if ($$self.$$.dirty & 772) {
        $:
          $$invalidate(7, labelled = ariaLabel || ariaLabelledBy || title2);
      }
      if ($$self.$$.dirty & 992) {
        $:
          $$invalidate(4, attributes = {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-hidden": labelled ? void 0 : true,
            role: labelled ? "img" : void 0,
            focusable: tabindex === "0" ? true : focusable,
            tabindex
          });
      }
    };
    $$props = exclude_internal_props($$props);
    return [
      className,
      id,
      title2,
      style,
      attributes,
      tabindex,
      focusable,
      labelled,
      ariaLabelledBy,
      ariaLabel,
      $$scope,
      slots,
      click_handler,
      mouseover_handler,
      mouseenter_handler,
      mouseleave_handler,
      keyup_handler,
      keydown_handler
    ];
  }
  var CollapseCategories16 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance14, create_fragment14, safe_not_equal, {
        class: 0,
        id: 1,
        tabindex: 5,
        focusable: 6,
        title: 2,
        style: 3
      });
    }
  };
  var CollapseCategories16_default = CollapseCategories16;

  // elos-web/node_modules/carbon-icons-svelte/lib/CollapseCategories16/index.js
  var CollapseCategories16_default2 = CollapseCategories16_default;

  // elos-web/node_modules/carbon-icons-svelte/lib/ClosedCaptionAlt16/ClosedCaptionAlt16.svelte
  function create_if_block14(ctx) {
    let title_1;
    let t;
    return {
      c() {
        title_1 = svg_element("title");
        t = text(ctx[2]);
      },
      m(target, anchor) {
        insert(target, title_1, anchor);
        append(title_1, t);
      },
      p(ctx2, dirty) {
        if (dirty & 4)
          set_data(t, ctx2[2]);
      },
      d(detaching) {
        if (detaching)
          detach(title_1);
      }
    };
  }
  function fallback_block14(ctx) {
    let if_block_anchor;
    let if_block = ctx[2] && create_if_block14(ctx);
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (ctx2[2]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block14(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach(if_block_anchor);
      }
    };
  }
  function create_fragment15(ctx) {
    let svg;
    let path0;
    let path1;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[11].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
    const default_slot_or_fallback = default_slot || fallback_block14(ctx);
    let svg_levels = [
      { "data-carbon-icon": "ClosedCaptionAlt16" },
      { xmlns: "http://www.w3.org/2000/svg" },
      { viewBox: "0 0 32 32" },
      { fill: "currentColor" },
      { width: "16" },
      { height: "16" },
      { class: ctx[0] },
      { preserveAspectRatio: "xMidYMid meet" },
      { style: ctx[3] },
      { id: ctx[1] },
      ctx[4]
    ];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    return {
      c() {
        svg = svg_element("svg");
        path0 = svg_element("path");
        path1 = svg_element("path");
        if (default_slot_or_fallback)
          default_slot_or_fallback.c();
        attr(path0, "d", "M19 17H25V19H19zM11 17H17V19H11zM6 17H9V19H6zM22 13H26V15H22zM13 13H20V15H13zM6 13H11V15H6z");
        attr(path1, "d", "M17.7358,30,16,29l4-7h6a1.9966,1.9966,0,0,0,2-2V8a1.9966,1.9966,0,0,0-2-2H6A1.9966,1.9966,0,0,0,4,8V20a1.9966,1.9966,0,0,0,2,2h9v2H6a3.9993,3.9993,0,0,1-4-4V8A3.9988,3.9988,0,0,1,6,4H26a3.9988,3.9988,0,0,1,4,4V20a3.9993,3.9993,0,0,1-4,4H21.1646Z");
        set_svg_attributes(svg, svg_data);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path0);
        append(svg, path1);
        if (default_slot_or_fallback) {
          default_slot_or_fallback.m(svg, null);
        }
        current = true;
        if (!mounted) {
          dispose = [
            listen(svg, "click", ctx[12]),
            listen(svg, "mouseover", ctx[13]),
            listen(svg, "mouseenter", ctx[14]),
            listen(svg, "mouseleave", ctx[15]),
            listen(svg, "keyup", ctx[16]),
            listen(svg, "keydown", ctx[17])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1024)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
          }
        } else {
          if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
            default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
          }
        }
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
          { "data-carbon-icon": "ClosedCaptionAlt16" },
          { xmlns: "http://www.w3.org/2000/svg" },
          { viewBox: "0 0 32 32" },
          { fill: "currentColor" },
          { width: "16" },
          { height: "16" },
          (!current || dirty & 1) && { class: ctx2[0] },
          { preserveAspectRatio: "xMidYMid meet" },
          (!current || dirty & 8) && { style: ctx2[3] },
          (!current || dirty & 2) && { id: ctx2[1] },
          dirty & 16 && ctx2[4]
        ]));
      },
      i(local) {
        if (current)
          return;
        transition_in(default_slot_or_fallback, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot_or_fallback, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(svg);
        if (default_slot_or_fallback)
          default_slot_or_fallback.d(detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance15($$self, $$props, $$invalidate) {
    let ariaLabel;
    let ariaLabelledBy;
    let labelled;
    let attributes;
    let { $$slots: slots = {}, $$scope } = $$props;
    let { class: className = void 0 } = $$props;
    let { id = void 0 } = $$props;
    let { tabindex = void 0 } = $$props;
    let { focusable = false } = $$props;
    let { title: title2 = void 0 } = $$props;
    let { style = void 0 } = $$props;
    function click_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseover_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseenter_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseleave_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keyup_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keydown_handler(event) {
      bubble.call(this, $$self, event);
    }
    $$self.$$set = ($$new_props) => {
      $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
      if ("class" in $$new_props)
        $$invalidate(0, className = $$new_props.class);
      if ("id" in $$new_props)
        $$invalidate(1, id = $$new_props.id);
      if ("tabindex" in $$new_props)
        $$invalidate(5, tabindex = $$new_props.tabindex);
      if ("focusable" in $$new_props)
        $$invalidate(6, focusable = $$new_props.focusable);
      if ("title" in $$new_props)
        $$invalidate(2, title2 = $$new_props.title);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("$$scope" in $$new_props)
        $$invalidate(10, $$scope = $$new_props.$$scope);
    };
    $$self.$$.update = () => {
      $:
        $$invalidate(9, ariaLabel = $$props["aria-label"]);
      $:
        $$invalidate(8, ariaLabelledBy = $$props["aria-labelledby"]);
      if ($$self.$$.dirty & 772) {
        $:
          $$invalidate(7, labelled = ariaLabel || ariaLabelledBy || title2);
      }
      if ($$self.$$.dirty & 992) {
        $:
          $$invalidate(4, attributes = {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-hidden": labelled ? void 0 : true,
            role: labelled ? "img" : void 0,
            focusable: tabindex === "0" ? true : focusable,
            tabindex
          });
      }
    };
    $$props = exclude_internal_props($$props);
    return [
      className,
      id,
      title2,
      style,
      attributes,
      tabindex,
      focusable,
      labelled,
      ariaLabelledBy,
      ariaLabel,
      $$scope,
      slots,
      click_handler,
      mouseover_handler,
      mouseenter_handler,
      mouseleave_handler,
      keyup_handler,
      keydown_handler
    ];
  }
  var ClosedCaptionAlt16 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance15, create_fragment15, safe_not_equal, {
        class: 0,
        id: 1,
        tabindex: 5,
        focusable: 6,
        title: 2,
        style: 3
      });
    }
  };
  var ClosedCaptionAlt16_default = ClosedCaptionAlt16;

  // elos-web/node_modules/carbon-icons-svelte/lib/ClosedCaptionAlt16/index.js
  var ClosedCaptionAlt16_default2 = ClosedCaptionAlt16_default;

  // elos-web/node_modules/carbon-icons-svelte/lib/CloseFilled16/CloseFilled16.svelte
  function create_if_block15(ctx) {
    let title_1;
    let t;
    return {
      c() {
        title_1 = svg_element("title");
        t = text(ctx[2]);
      },
      m(target, anchor) {
        insert(target, title_1, anchor);
        append(title_1, t);
      },
      p(ctx2, dirty) {
        if (dirty & 4)
          set_data(t, ctx2[2]);
      },
      d(detaching) {
        if (detaching)
          detach(title_1);
      }
    };
  }
  function fallback_block15(ctx) {
    let if_block_anchor;
    let if_block = ctx[2] && create_if_block15(ctx);
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (ctx2[2]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block15(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach(if_block_anchor);
      }
    };
  }
  function create_fragment16(ctx) {
    let svg;
    let path;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[11].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
    const default_slot_or_fallback = default_slot || fallback_block15(ctx);
    let svg_levels = [
      { "data-carbon-icon": "CloseFilled16" },
      { xmlns: "http://www.w3.org/2000/svg" },
      { viewBox: "0 0 16 16" },
      { fill: "currentColor" },
      { width: "16" },
      { height: "16" },
      { class: ctx[0] },
      { preserveAspectRatio: "xMidYMid meet" },
      { style: ctx[3] },
      { id: ctx[1] },
      ctx[4]
    ];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        if (default_slot_or_fallback)
          default_slot_or_fallback.c();
        attr(path, "d", "M8,1C4.1,1,1,4.1,1,8s3.1,7,7,7s7-3.1,7-7S11.9,1,8,1z M10.7,11.5L8,8.8l-2.7,2.7l-0.8-0.8L7.2,8L4.5,5.3l0.8-0.8L8,7.2	l2.7-2.7l0.8,0.8L8.8,8l2.7,2.7L10.7,11.5z");
        set_svg_attributes(svg, svg_data);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        if (default_slot_or_fallback) {
          default_slot_or_fallback.m(svg, null);
        }
        current = true;
        if (!mounted) {
          dispose = [
            listen(svg, "click", ctx[12]),
            listen(svg, "mouseover", ctx[13]),
            listen(svg, "mouseenter", ctx[14]),
            listen(svg, "mouseleave", ctx[15]),
            listen(svg, "keyup", ctx[16]),
            listen(svg, "keydown", ctx[17])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1024)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
          }
        } else {
          if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
            default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
          }
        }
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
          { "data-carbon-icon": "CloseFilled16" },
          { xmlns: "http://www.w3.org/2000/svg" },
          { viewBox: "0 0 16 16" },
          { fill: "currentColor" },
          { width: "16" },
          { height: "16" },
          (!current || dirty & 1) && { class: ctx2[0] },
          { preserveAspectRatio: "xMidYMid meet" },
          (!current || dirty & 8) && { style: ctx2[3] },
          (!current || dirty & 2) && { id: ctx2[1] },
          dirty & 16 && ctx2[4]
        ]));
      },
      i(local) {
        if (current)
          return;
        transition_in(default_slot_or_fallback, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot_or_fallback, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(svg);
        if (default_slot_or_fallback)
          default_slot_or_fallback.d(detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance16($$self, $$props, $$invalidate) {
    let ariaLabel;
    let ariaLabelledBy;
    let labelled;
    let attributes;
    let { $$slots: slots = {}, $$scope } = $$props;
    let { class: className = void 0 } = $$props;
    let { id = void 0 } = $$props;
    let { tabindex = void 0 } = $$props;
    let { focusable = false } = $$props;
    let { title: title2 = void 0 } = $$props;
    let { style = void 0 } = $$props;
    function click_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseover_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseenter_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseleave_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keyup_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keydown_handler(event) {
      bubble.call(this, $$self, event);
    }
    $$self.$$set = ($$new_props) => {
      $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
      if ("class" in $$new_props)
        $$invalidate(0, className = $$new_props.class);
      if ("id" in $$new_props)
        $$invalidate(1, id = $$new_props.id);
      if ("tabindex" in $$new_props)
        $$invalidate(5, tabindex = $$new_props.tabindex);
      if ("focusable" in $$new_props)
        $$invalidate(6, focusable = $$new_props.focusable);
      if ("title" in $$new_props)
        $$invalidate(2, title2 = $$new_props.title);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("$$scope" in $$new_props)
        $$invalidate(10, $$scope = $$new_props.$$scope);
    };
    $$self.$$.update = () => {
      $:
        $$invalidate(9, ariaLabel = $$props["aria-label"]);
      $:
        $$invalidate(8, ariaLabelledBy = $$props["aria-labelledby"]);
      if ($$self.$$.dirty & 772) {
        $:
          $$invalidate(7, labelled = ariaLabel || ariaLabelledBy || title2);
      }
      if ($$self.$$.dirty & 992) {
        $:
          $$invalidate(4, attributes = {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-hidden": labelled ? void 0 : true,
            role: labelled ? "img" : void 0,
            focusable: tabindex === "0" ? true : focusable,
            tabindex
          });
      }
    };
    $$props = exclude_internal_props($$props);
    return [
      className,
      id,
      title2,
      style,
      attributes,
      tabindex,
      focusable,
      labelled,
      ariaLabelledBy,
      ariaLabel,
      $$scope,
      slots,
      click_handler,
      mouseover_handler,
      mouseenter_handler,
      mouseleave_handler,
      keyup_handler,
      keydown_handler
    ];
  }
  var CloseFilled16 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance16, create_fragment16, safe_not_equal, {
        class: 0,
        id: 1,
        tabindex: 5,
        focusable: 6,
        title: 2,
        style: 3
      });
    }
  };
  var CloseFilled16_default = CloseFilled16;

  // elos-web/node_modules/carbon-icons-svelte/lib/CloseFilled16/index.js
  var CloseFilled16_default2 = CloseFilled16_default;

  // elos-web/node_modules/carbon-icons-svelte/lib/Code16/Code16.svelte
  function create_if_block16(ctx) {
    let title_1;
    let t;
    return {
      c() {
        title_1 = svg_element("title");
        t = text(ctx[2]);
      },
      m(target, anchor) {
        insert(target, title_1, anchor);
        append(title_1, t);
      },
      p(ctx2, dirty) {
        if (dirty & 4)
          set_data(t, ctx2[2]);
      },
      d(detaching) {
        if (detaching)
          detach(title_1);
      }
    };
  }
  function fallback_block16(ctx) {
    let if_block_anchor;
    let if_block = ctx[2] && create_if_block16(ctx);
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (ctx2[2]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block16(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach(if_block_anchor);
      }
    };
  }
  function create_fragment17(ctx) {
    let svg;
    let path0;
    let path1;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[11].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
    const default_slot_or_fallback = default_slot || fallback_block16(ctx);
    let svg_levels = [
      { "data-carbon-icon": "Code16" },
      { xmlns: "http://www.w3.org/2000/svg" },
      { viewBox: "0 0 32 32" },
      { fill: "currentColor" },
      { width: "16" },
      { height: "16" },
      { class: ctx[0] },
      { preserveAspectRatio: "xMidYMid meet" },
      { style: ctx[3] },
      { id: ctx[1] },
      ctx[4]
    ];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    return {
      c() {
        svg = svg_element("svg");
        path0 = svg_element("path");
        path1 = svg_element("path");
        if (default_slot_or_fallback)
          default_slot_or_fallback.c();
        attr(path0, "d", "M31 16L24 23 22.59 21.59 28.17 16 22.59 10.41 24 9 31 16zM1 16L8 9 9.41 10.41 3.83 16 9.41 21.59 8 23 1 16z");
        attr(path1, "d", "M5.91 15H26.080000000000002V17H5.91z");
        attr(path1, "transform", "rotate(-75 15.996 16)");
        set_svg_attributes(svg, svg_data);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path0);
        append(svg, path1);
        if (default_slot_or_fallback) {
          default_slot_or_fallback.m(svg, null);
        }
        current = true;
        if (!mounted) {
          dispose = [
            listen(svg, "click", ctx[12]),
            listen(svg, "mouseover", ctx[13]),
            listen(svg, "mouseenter", ctx[14]),
            listen(svg, "mouseleave", ctx[15]),
            listen(svg, "keyup", ctx[16]),
            listen(svg, "keydown", ctx[17])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1024)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
          }
        } else {
          if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
            default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
          }
        }
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
          { "data-carbon-icon": "Code16" },
          { xmlns: "http://www.w3.org/2000/svg" },
          { viewBox: "0 0 32 32" },
          { fill: "currentColor" },
          { width: "16" },
          { height: "16" },
          (!current || dirty & 1) && { class: ctx2[0] },
          { preserveAspectRatio: "xMidYMid meet" },
          (!current || dirty & 8) && { style: ctx2[3] },
          (!current || dirty & 2) && { id: ctx2[1] },
          dirty & 16 && ctx2[4]
        ]));
      },
      i(local) {
        if (current)
          return;
        transition_in(default_slot_or_fallback, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot_or_fallback, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(svg);
        if (default_slot_or_fallback)
          default_slot_or_fallback.d(detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance17($$self, $$props, $$invalidate) {
    let ariaLabel;
    let ariaLabelledBy;
    let labelled;
    let attributes;
    let { $$slots: slots = {}, $$scope } = $$props;
    let { class: className = void 0 } = $$props;
    let { id = void 0 } = $$props;
    let { tabindex = void 0 } = $$props;
    let { focusable = false } = $$props;
    let { title: title2 = void 0 } = $$props;
    let { style = void 0 } = $$props;
    function click_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseover_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseenter_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseleave_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keyup_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keydown_handler(event) {
      bubble.call(this, $$self, event);
    }
    $$self.$$set = ($$new_props) => {
      $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
      if ("class" in $$new_props)
        $$invalidate(0, className = $$new_props.class);
      if ("id" in $$new_props)
        $$invalidate(1, id = $$new_props.id);
      if ("tabindex" in $$new_props)
        $$invalidate(5, tabindex = $$new_props.tabindex);
      if ("focusable" in $$new_props)
        $$invalidate(6, focusable = $$new_props.focusable);
      if ("title" in $$new_props)
        $$invalidate(2, title2 = $$new_props.title);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("$$scope" in $$new_props)
        $$invalidate(10, $$scope = $$new_props.$$scope);
    };
    $$self.$$.update = () => {
      $:
        $$invalidate(9, ariaLabel = $$props["aria-label"]);
      $:
        $$invalidate(8, ariaLabelledBy = $$props["aria-labelledby"]);
      if ($$self.$$.dirty & 772) {
        $:
          $$invalidate(7, labelled = ariaLabel || ariaLabelledBy || title2);
      }
      if ($$self.$$.dirty & 992) {
        $:
          $$invalidate(4, attributes = {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-hidden": labelled ? void 0 : true,
            role: labelled ? "img" : void 0,
            focusable: tabindex === "0" ? true : focusable,
            tabindex
          });
      }
    };
    $$props = exclude_internal_props($$props);
    return [
      className,
      id,
      title2,
      style,
      attributes,
      tabindex,
      focusable,
      labelled,
      ariaLabelledBy,
      ariaLabel,
      $$scope,
      slots,
      click_handler,
      mouseover_handler,
      mouseenter_handler,
      mouseleave_handler,
      keyup_handler,
      keydown_handler
    ];
  }
  var Code16 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance17, create_fragment17, safe_not_equal, {
        class: 0,
        id: 1,
        tabindex: 5,
        focusable: 6,
        title: 2,
        style: 3
      });
    }
  };
  var Code16_default = Code16;

  // elos-web/node_modules/carbon-icons-svelte/lib/Code16/index.js
  var Code16_default2 = Code16_default;

  // elos-web/node_modules/carbon-icons-svelte/lib/CodeReference16/CodeReference16.svelte
  function create_if_block17(ctx) {
    let title_1;
    let t;
    return {
      c() {
        title_1 = svg_element("title");
        t = text(ctx[2]);
      },
      m(target, anchor) {
        insert(target, title_1, anchor);
        append(title_1, t);
      },
      p(ctx2, dirty) {
        if (dirty & 4)
          set_data(t, ctx2[2]);
      },
      d(detaching) {
        if (detaching)
          detach(title_1);
      }
    };
  }
  function fallback_block17(ctx) {
    let if_block_anchor;
    let if_block = ctx[2] && create_if_block17(ctx);
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (ctx2[2]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block17(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach(if_block_anchor);
      }
    };
  }
  function create_fragment18(ctx) {
    let svg;
    let path0;
    let path1;
    let path2;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[11].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
    const default_slot_or_fallback = default_slot || fallback_block17(ctx);
    let svg_levels = [
      { "data-carbon-icon": "CodeReference16" },
      { xmlns: "http://www.w3.org/2000/svg" },
      { viewBox: "0 0 32 32" },
      { fill: "currentColor" },
      { width: "16" },
      { height: "16" },
      { class: ctx[0] },
      { preserveAspectRatio: "xMidYMid meet" },
      { style: ctx[3] },
      { id: ctx[1] },
      ctx[4]
    ];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    return {
      c() {
        svg = svg_element("svg");
        path0 = svg_element("path");
        path1 = svg_element("path");
        path2 = svg_element("path");
        if (default_slot_or_fallback)
          default_slot_or_fallback.c();
        attr(path0, "d", "M4 20L4 22 8.586 22 2 28.586 3.414 30 10 23.414 10 28 12 28 12 20 4 20zM30 10L24 4 22.586 5.414 27.172 10 22.586 14.586 24 16 30 10z");
        attr(path1, "d", "M8.944 9.001H24.974000000000004V11.001H8.944z");
        attr(path1, "transform", "rotate(-74.995 16.96 10)");
        attr(path2, "d", "M4 10L10 4 11.414 5.414 6.828 10 11.414 14.586 10 16 4 10z");
        set_svg_attributes(svg, svg_data);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path0);
        append(svg, path1);
        append(svg, path2);
        if (default_slot_or_fallback) {
          default_slot_or_fallback.m(svg, null);
        }
        current = true;
        if (!mounted) {
          dispose = [
            listen(svg, "click", ctx[12]),
            listen(svg, "mouseover", ctx[13]),
            listen(svg, "mouseenter", ctx[14]),
            listen(svg, "mouseleave", ctx[15]),
            listen(svg, "keyup", ctx[16]),
            listen(svg, "keydown", ctx[17])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1024)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
          }
        } else {
          if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
            default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
          }
        }
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
          { "data-carbon-icon": "CodeReference16" },
          { xmlns: "http://www.w3.org/2000/svg" },
          { viewBox: "0 0 32 32" },
          { fill: "currentColor" },
          { width: "16" },
          { height: "16" },
          (!current || dirty & 1) && { class: ctx2[0] },
          { preserveAspectRatio: "xMidYMid meet" },
          (!current || dirty & 8) && { style: ctx2[3] },
          (!current || dirty & 2) && { id: ctx2[1] },
          dirty & 16 && ctx2[4]
        ]));
      },
      i(local) {
        if (current)
          return;
        transition_in(default_slot_or_fallback, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot_or_fallback, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(svg);
        if (default_slot_or_fallback)
          default_slot_or_fallback.d(detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance18($$self, $$props, $$invalidate) {
    let ariaLabel;
    let ariaLabelledBy;
    let labelled;
    let attributes;
    let { $$slots: slots = {}, $$scope } = $$props;
    let { class: className = void 0 } = $$props;
    let { id = void 0 } = $$props;
    let { tabindex = void 0 } = $$props;
    let { focusable = false } = $$props;
    let { title: title2 = void 0 } = $$props;
    let { style = void 0 } = $$props;
    function click_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseover_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseenter_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseleave_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keyup_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keydown_handler(event) {
      bubble.call(this, $$self, event);
    }
    $$self.$$set = ($$new_props) => {
      $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
      if ("class" in $$new_props)
        $$invalidate(0, className = $$new_props.class);
      if ("id" in $$new_props)
        $$invalidate(1, id = $$new_props.id);
      if ("tabindex" in $$new_props)
        $$invalidate(5, tabindex = $$new_props.tabindex);
      if ("focusable" in $$new_props)
        $$invalidate(6, focusable = $$new_props.focusable);
      if ("title" in $$new_props)
        $$invalidate(2, title2 = $$new_props.title);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("$$scope" in $$new_props)
        $$invalidate(10, $$scope = $$new_props.$$scope);
    };
    $$self.$$.update = () => {
      $:
        $$invalidate(9, ariaLabel = $$props["aria-label"]);
      $:
        $$invalidate(8, ariaLabelledBy = $$props["aria-labelledby"]);
      if ($$self.$$.dirty & 772) {
        $:
          $$invalidate(7, labelled = ariaLabel || ariaLabelledBy || title2);
      }
      if ($$self.$$.dirty & 992) {
        $:
          $$invalidate(4, attributes = {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-hidden": labelled ? void 0 : true,
            role: labelled ? "img" : void 0,
            focusable: tabindex === "0" ? true : focusable,
            tabindex
          });
      }
    };
    $$props = exclude_internal_props($$props);
    return [
      className,
      id,
      title2,
      style,
      attributes,
      tabindex,
      focusable,
      labelled,
      ariaLabelledBy,
      ariaLabel,
      $$scope,
      slots,
      click_handler,
      mouseover_handler,
      mouseenter_handler,
      mouseleave_handler,
      keyup_handler,
      keydown_handler
    ];
  }
  var CodeReference16 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance18, create_fragment18, safe_not_equal, {
        class: 0,
        id: 1,
        tabindex: 5,
        focusable: 6,
        title: 2,
        style: 3
      });
    }
  };
  var CodeReference16_default = CodeReference16;

  // elos-web/node_modules/carbon-icons-svelte/lib/CodeReference16/index.js
  var CodeReference16_default2 = CodeReference16_default;

  // elos-web/node_modules/carbon-icons-svelte/lib/Compare16/Compare16.svelte
  function create_if_block18(ctx) {
    let title_1;
    let t;
    return {
      c() {
        title_1 = svg_element("title");
        t = text(ctx[2]);
      },
      m(target, anchor) {
        insert(target, title_1, anchor);
        append(title_1, t);
      },
      p(ctx2, dirty) {
        if (dirty & 4)
          set_data(t, ctx2[2]);
      },
      d(detaching) {
        if (detaching)
          detach(title_1);
      }
    };
  }
  function fallback_block18(ctx) {
    let if_block_anchor;
    let if_block = ctx[2] && create_if_block18(ctx);
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (ctx2[2]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block18(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach(if_block_anchor);
      }
    };
  }
  function create_fragment19(ctx) {
    let svg;
    let path;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[11].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
    const default_slot_or_fallback = default_slot || fallback_block18(ctx);
    let svg_levels = [
      { "data-carbon-icon": "Compare16" },
      { xmlns: "http://www.w3.org/2000/svg" },
      { viewBox: "0 0 32 32" },
      { fill: "currentColor" },
      { width: "16" },
      { height: "16" },
      { class: ctx[0] },
      { preserveAspectRatio: "xMidYMid meet" },
      { style: ctx[3] },
      { id: ctx[1] },
      ctx[4]
    ];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        if (default_slot_or_fallback)
          default_slot_or_fallback.c();
        attr(path, "d", "M28,6H18V4a2,2,0,0,0-2-2H4A2,2,0,0,0,2,4V24a2,2,0,0,0,2,2H14v2a2,2,0,0,0,2,2H28a2,2,0,0,0,2-2V8A2,2,0,0,0,28,6ZM4,15h6.17L7.59,17.59,9,19l5-5L9,9,7.59,10.41,10.17,13H4V4H16V24H4ZM16,28V26a2,2,0,0,0,2-2V8H28v9H21.83l2.58-2.59L23,13l-5,5,5,5,1.41-1.41L21.83,19H28v9Z");
        set_svg_attributes(svg, svg_data);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        if (default_slot_or_fallback) {
          default_slot_or_fallback.m(svg, null);
        }
        current = true;
        if (!mounted) {
          dispose = [
            listen(svg, "click", ctx[12]),
            listen(svg, "mouseover", ctx[13]),
            listen(svg, "mouseenter", ctx[14]),
            listen(svg, "mouseleave", ctx[15]),
            listen(svg, "keyup", ctx[16]),
            listen(svg, "keydown", ctx[17])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1024)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
          }
        } else {
          if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
            default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
          }
        }
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
          { "data-carbon-icon": "Compare16" },
          { xmlns: "http://www.w3.org/2000/svg" },
          { viewBox: "0 0 32 32" },
          { fill: "currentColor" },
          { width: "16" },
          { height: "16" },
          (!current || dirty & 1) && { class: ctx2[0] },
          { preserveAspectRatio: "xMidYMid meet" },
          (!current || dirty & 8) && { style: ctx2[3] },
          (!current || dirty & 2) && { id: ctx2[1] },
          dirty & 16 && ctx2[4]
        ]));
      },
      i(local) {
        if (current)
          return;
        transition_in(default_slot_or_fallback, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot_or_fallback, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(svg);
        if (default_slot_or_fallback)
          default_slot_or_fallback.d(detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance19($$self, $$props, $$invalidate) {
    let ariaLabel;
    let ariaLabelledBy;
    let labelled;
    let attributes;
    let { $$slots: slots = {}, $$scope } = $$props;
    let { class: className = void 0 } = $$props;
    let { id = void 0 } = $$props;
    let { tabindex = void 0 } = $$props;
    let { focusable = false } = $$props;
    let { title: title2 = void 0 } = $$props;
    let { style = void 0 } = $$props;
    function click_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseover_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseenter_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseleave_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keyup_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keydown_handler(event) {
      bubble.call(this, $$self, event);
    }
    $$self.$$set = ($$new_props) => {
      $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
      if ("class" in $$new_props)
        $$invalidate(0, className = $$new_props.class);
      if ("id" in $$new_props)
        $$invalidate(1, id = $$new_props.id);
      if ("tabindex" in $$new_props)
        $$invalidate(5, tabindex = $$new_props.tabindex);
      if ("focusable" in $$new_props)
        $$invalidate(6, focusable = $$new_props.focusable);
      if ("title" in $$new_props)
        $$invalidate(2, title2 = $$new_props.title);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("$$scope" in $$new_props)
        $$invalidate(10, $$scope = $$new_props.$$scope);
    };
    $$self.$$.update = () => {
      $:
        $$invalidate(9, ariaLabel = $$props["aria-label"]);
      $:
        $$invalidate(8, ariaLabelledBy = $$props["aria-labelledby"]);
      if ($$self.$$.dirty & 772) {
        $:
          $$invalidate(7, labelled = ariaLabel || ariaLabelledBy || title2);
      }
      if ($$self.$$.dirty & 992) {
        $:
          $$invalidate(4, attributes = {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-hidden": labelled ? void 0 : true,
            role: labelled ? "img" : void 0,
            focusable: tabindex === "0" ? true : focusable,
            tabindex
          });
      }
    };
    $$props = exclude_internal_props($$props);
    return [
      className,
      id,
      title2,
      style,
      attributes,
      tabindex,
      focusable,
      labelled,
      ariaLabelledBy,
      ariaLabel,
      $$scope,
      slots,
      click_handler,
      mouseover_handler,
      mouseenter_handler,
      mouseleave_handler,
      keyup_handler,
      keydown_handler
    ];
  }
  var Compare16 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance19, create_fragment19, safe_not_equal, {
        class: 0,
        id: 1,
        tabindex: 5,
        focusable: 6,
        title: 2,
        style: 3
      });
    }
  };
  var Compare16_default = Compare16;

  // elos-web/node_modules/carbon-icons-svelte/lib/Compare16/index.js
  var Compare16_default2 = Compare16_default;

  // elos-web/node_modules/carbon-icons-svelte/lib/Crossroads16/Crossroads16.svelte
  function create_if_block19(ctx) {
    let title_1;
    let t;
    return {
      c() {
        title_1 = svg_element("title");
        t = text(ctx[2]);
      },
      m(target, anchor) {
        insert(target, title_1, anchor);
        append(title_1, t);
      },
      p(ctx2, dirty) {
        if (dirty & 4)
          set_data(t, ctx2[2]);
      },
      d(detaching) {
        if (detaching)
          detach(title_1);
      }
    };
  }
  function fallback_block19(ctx) {
    let if_block_anchor;
    let if_block = ctx[2] && create_if_block19(ctx);
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (ctx2[2]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block19(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach(if_block_anchor);
      }
    };
  }
  function create_fragment20(ctx) {
    let svg;
    let path;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[11].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
    const default_slot_or_fallback = default_slot || fallback_block19(ctx);
    let svg_levels = [
      { "data-carbon-icon": "Crossroads16" },
      { xmlns: "http://www.w3.org/2000/svg" },
      { viewBox: "0 0 32 32" },
      { fill: "currentColor" },
      { width: "16" },
      { height: "16" },
      { class: ctx[0] },
      { preserveAspectRatio: "xMidYMid meet" },
      { style: ctx[3] },
      { id: ctx[1] },
      ctx[4]
    ];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        if (default_slot_or_fallback)
          default_slot_or_fallback.c();
        attr(path, "d", "M26.5859,6.5859A1.9862,1.9862,0,0,0,25.1719,6H17V2H15V12H6.8281a1.9862,1.9862,0,0,0-1.414.5859L2,16l3.4141,3.4141A1.9862,1.9862,0,0,0,6.8281,20H15V30h2V14h8.1719a1.9862,1.9862,0,0,0,1.414-.5859L30,10ZM6.8281,18l-2-2,2-2H15v4Zm18.3438-6H17V8h8.1719l2,2Z");
        set_svg_attributes(svg, svg_data);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        if (default_slot_or_fallback) {
          default_slot_or_fallback.m(svg, null);
        }
        current = true;
        if (!mounted) {
          dispose = [
            listen(svg, "click", ctx[12]),
            listen(svg, "mouseover", ctx[13]),
            listen(svg, "mouseenter", ctx[14]),
            listen(svg, "mouseleave", ctx[15]),
            listen(svg, "keyup", ctx[16]),
            listen(svg, "keydown", ctx[17])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1024)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
          }
        } else {
          if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
            default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
          }
        }
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
          { "data-carbon-icon": "Crossroads16" },
          { xmlns: "http://www.w3.org/2000/svg" },
          { viewBox: "0 0 32 32" },
          { fill: "currentColor" },
          { width: "16" },
          { height: "16" },
          (!current || dirty & 1) && { class: ctx2[0] },
          { preserveAspectRatio: "xMidYMid meet" },
          (!current || dirty & 8) && { style: ctx2[3] },
          (!current || dirty & 2) && { id: ctx2[1] },
          dirty & 16 && ctx2[4]
        ]));
      },
      i(local) {
        if (current)
          return;
        transition_in(default_slot_or_fallback, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot_or_fallback, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(svg);
        if (default_slot_or_fallback)
          default_slot_or_fallback.d(detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance20($$self, $$props, $$invalidate) {
    let ariaLabel;
    let ariaLabelledBy;
    let labelled;
    let attributes;
    let { $$slots: slots = {}, $$scope } = $$props;
    let { class: className = void 0 } = $$props;
    let { id = void 0 } = $$props;
    let { tabindex = void 0 } = $$props;
    let { focusable = false } = $$props;
    let { title: title2 = void 0 } = $$props;
    let { style = void 0 } = $$props;
    function click_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseover_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseenter_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseleave_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keyup_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keydown_handler(event) {
      bubble.call(this, $$self, event);
    }
    $$self.$$set = ($$new_props) => {
      $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
      if ("class" in $$new_props)
        $$invalidate(0, className = $$new_props.class);
      if ("id" in $$new_props)
        $$invalidate(1, id = $$new_props.id);
      if ("tabindex" in $$new_props)
        $$invalidate(5, tabindex = $$new_props.tabindex);
      if ("focusable" in $$new_props)
        $$invalidate(6, focusable = $$new_props.focusable);
      if ("title" in $$new_props)
        $$invalidate(2, title2 = $$new_props.title);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("$$scope" in $$new_props)
        $$invalidate(10, $$scope = $$new_props.$$scope);
    };
    $$self.$$.update = () => {
      $:
        $$invalidate(9, ariaLabel = $$props["aria-label"]);
      $:
        $$invalidate(8, ariaLabelledBy = $$props["aria-labelledby"]);
      if ($$self.$$.dirty & 772) {
        $:
          $$invalidate(7, labelled = ariaLabel || ariaLabelledBy || title2);
      }
      if ($$self.$$.dirty & 992) {
        $:
          $$invalidate(4, attributes = {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-hidden": labelled ? void 0 : true,
            role: labelled ? "img" : void 0,
            focusable: tabindex === "0" ? true : focusable,
            tabindex
          });
      }
    };
    $$props = exclude_internal_props($$props);
    return [
      className,
      id,
      title2,
      style,
      attributes,
      tabindex,
      focusable,
      labelled,
      ariaLabelledBy,
      ariaLabel,
      $$scope,
      slots,
      click_handler,
      mouseover_handler,
      mouseenter_handler,
      mouseleave_handler,
      keyup_handler,
      keydown_handler
    ];
  }
  var Crossroads16 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance20, create_fragment20, safe_not_equal, {
        class: 0,
        id: 1,
        tabindex: 5,
        focusable: 6,
        title: 2,
        style: 3
      });
    }
  };
  var Crossroads16_default = Crossroads16;

  // elos-web/node_modules/carbon-icons-svelte/lib/Crossroads16/index.js
  var Crossroads16_default2 = Crossroads16_default;

  // elos-web/node_modules/carbon-icons-svelte/lib/CrossTab16/CrossTab16.svelte
  function create_if_block20(ctx) {
    let title_1;
    let t;
    return {
      c() {
        title_1 = svg_element("title");
        t = text(ctx[2]);
      },
      m(target, anchor) {
        insert(target, title_1, anchor);
        append(title_1, t);
      },
      p(ctx2, dirty) {
        if (dirty & 4)
          set_data(t, ctx2[2]);
      },
      d(detaching) {
        if (detaching)
          detach(title_1);
      }
    };
  }
  function fallback_block20(ctx) {
    let if_block_anchor;
    let if_block = ctx[2] && create_if_block20(ctx);
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (ctx2[2]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block20(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach(if_block_anchor);
      }
    };
  }
  function create_fragment21(ctx) {
    let svg;
    let path;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[11].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
    const default_slot_or_fallback = default_slot || fallback_block20(ctx);
    let svg_levels = [
      { "data-carbon-icon": "CrossTab16" },
      { xmlns: "http://www.w3.org/2000/svg" },
      { viewBox: "0 0 32 32" },
      { fill: "currentColor" },
      { width: "16" },
      { height: "16" },
      { class: ctx[0] },
      { preserveAspectRatio: "xMidYMid meet" },
      { style: ctx[3] },
      { id: ctx[1] },
      ctx[4]
    ];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        if (default_slot_or_fallback)
          default_slot_or_fallback.c();
        attr(path, "d", "M28,2H10A2.0023,2.0023,0,0,0,8,4V7H4A2.0023,2.0023,0,0,0,2,9V28a2.0023,2.0023,0,0,0,2,2H28a2.0023,2.0023,0,0,0,2-2V4A2.0023,2.0023,0,0,0,28,2ZM10,4H28V7H10ZM28,14H20V9h8ZM10,21V16h8v5Zm8,2v5H10V23ZM8,21H4V16H8ZM18,9v5H10V9Zm2,7h8v5H20ZM8,9v5H4V9ZM4,23H8v5H4Zm16,5V23h8v5Z");
        set_svg_attributes(svg, svg_data);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        if (default_slot_or_fallback) {
          default_slot_or_fallback.m(svg, null);
        }
        current = true;
        if (!mounted) {
          dispose = [
            listen(svg, "click", ctx[12]),
            listen(svg, "mouseover", ctx[13]),
            listen(svg, "mouseenter", ctx[14]),
            listen(svg, "mouseleave", ctx[15]),
            listen(svg, "keyup", ctx[16]),
            listen(svg, "keydown", ctx[17])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1024)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
          }
        } else {
          if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
            default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
          }
        }
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
          { "data-carbon-icon": "CrossTab16" },
          { xmlns: "http://www.w3.org/2000/svg" },
          { viewBox: "0 0 32 32" },
          { fill: "currentColor" },
          { width: "16" },
          { height: "16" },
          (!current || dirty & 1) && { class: ctx2[0] },
          { preserveAspectRatio: "xMidYMid meet" },
          (!current || dirty & 8) && { style: ctx2[3] },
          (!current || dirty & 2) && { id: ctx2[1] },
          dirty & 16 && ctx2[4]
        ]));
      },
      i(local) {
        if (current)
          return;
        transition_in(default_slot_or_fallback, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot_or_fallback, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(svg);
        if (default_slot_or_fallback)
          default_slot_or_fallback.d(detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance21($$self, $$props, $$invalidate) {
    let ariaLabel;
    let ariaLabelledBy;
    let labelled;
    let attributes;
    let { $$slots: slots = {}, $$scope } = $$props;
    let { class: className = void 0 } = $$props;
    let { id = void 0 } = $$props;
    let { tabindex = void 0 } = $$props;
    let { focusable = false } = $$props;
    let { title: title2 = void 0 } = $$props;
    let { style = void 0 } = $$props;
    function click_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseover_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseenter_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseleave_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keyup_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keydown_handler(event) {
      bubble.call(this, $$self, event);
    }
    $$self.$$set = ($$new_props) => {
      $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
      if ("class" in $$new_props)
        $$invalidate(0, className = $$new_props.class);
      if ("id" in $$new_props)
        $$invalidate(1, id = $$new_props.id);
      if ("tabindex" in $$new_props)
        $$invalidate(5, tabindex = $$new_props.tabindex);
      if ("focusable" in $$new_props)
        $$invalidate(6, focusable = $$new_props.focusable);
      if ("title" in $$new_props)
        $$invalidate(2, title2 = $$new_props.title);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("$$scope" in $$new_props)
        $$invalidate(10, $$scope = $$new_props.$$scope);
    };
    $$self.$$.update = () => {
      $:
        $$invalidate(9, ariaLabel = $$props["aria-label"]);
      $:
        $$invalidate(8, ariaLabelledBy = $$props["aria-labelledby"]);
      if ($$self.$$.dirty & 772) {
        $:
          $$invalidate(7, labelled = ariaLabel || ariaLabelledBy || title2);
      }
      if ($$self.$$.dirty & 992) {
        $:
          $$invalidate(4, attributes = {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-hidden": labelled ? void 0 : true,
            role: labelled ? "img" : void 0,
            focusable: tabindex === "0" ? true : focusable,
            tabindex
          });
      }
    };
    $$props = exclude_internal_props($$props);
    return [
      className,
      id,
      title2,
      style,
      attributes,
      tabindex,
      focusable,
      labelled,
      ariaLabelledBy,
      ariaLabel,
      $$scope,
      slots,
      click_handler,
      mouseover_handler,
      mouseenter_handler,
      mouseleave_handler,
      keyup_handler,
      keydown_handler
    ];
  }
  var CrossTab16 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance21, create_fragment21, safe_not_equal, {
        class: 0,
        id: 1,
        tabindex: 5,
        focusable: 6,
        title: 2,
        style: 3
      });
    }
  };
  var CrossTab16_default = CrossTab16;

  // elos-web/node_modules/carbon-icons-svelte/lib/CrossTab16/index.js
  var CrossTab16_default2 = CrossTab16_default;

  // elos-web/node_modules/carbon-icons-svelte/lib/Cut16/Cut16.svelte
  function create_if_block21(ctx) {
    let title_1;
    let t;
    return {
      c() {
        title_1 = svg_element("title");
        t = text(ctx[2]);
      },
      m(target, anchor) {
        insert(target, title_1, anchor);
        append(title_1, t);
      },
      p(ctx2, dirty) {
        if (dirty & 4)
          set_data(t, ctx2[2]);
      },
      d(detaching) {
        if (detaching)
          detach(title_1);
      }
    };
  }
  function fallback_block21(ctx) {
    let if_block_anchor;
    let if_block = ctx[2] && create_if_block21(ctx);
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (ctx2[2]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block21(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach(if_block_anchor);
      }
    };
  }
  function create_fragment22(ctx) {
    let svg;
    let path;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[11].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
    const default_slot_or_fallback = default_slot || fallback_block21(ctx);
    let svg_levels = [
      { "data-carbon-icon": "Cut16" },
      { xmlns: "http://www.w3.org/2000/svg" },
      { viewBox: "0 0 32 32" },
      { fill: "currentColor" },
      { width: "16" },
      { height: "16" },
      { class: ctx[0] },
      { preserveAspectRatio: "xMidYMid meet" },
      { style: ctx[3] },
      { id: ctx[1] },
      ctx[4]
    ];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        if (default_slot_or_fallback)
          default_slot_or_fallback.c();
        attr(path, "d", "M26.5,19.63,20.24,16l6.26-3.63a5,5,0,0,0-1.21-9.2A5.19,5.19,0,0,0,24,3a5,5,0,0,0-4.33,7.53,5,5,0,0,0,2.39,2.1l-3.82,2.21L4,6.6,3,8.34,16.24,16,3,23.68l1,1.74,14.24-8.26,3.82,2.21a5,5,0,0,0-2.39,2.1A5,5,0,0,0,24,29a5.19,5.19,0,0,0,1.29-.17,5,5,0,0,0,1.21-9.2ZM21.4,9.53a3,3,0,0,1,1.1-4.12,3,3,0,0,1,4.1,1.11,3,3,0,0,1-1.1,4.11h0A3,3,0,0,1,21.4,9.53Zm5.2,16a3,3,0,0,1-4.1,1.11,3,3,0,0,1-1.1-4.12,3,3,0,0,1,4.1-1.1h0A3,3,0,0,1,26.6,25.48Z");
        set_svg_attributes(svg, svg_data);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        if (default_slot_or_fallback) {
          default_slot_or_fallback.m(svg, null);
        }
        current = true;
        if (!mounted) {
          dispose = [
            listen(svg, "click", ctx[12]),
            listen(svg, "mouseover", ctx[13]),
            listen(svg, "mouseenter", ctx[14]),
            listen(svg, "mouseleave", ctx[15]),
            listen(svg, "keyup", ctx[16]),
            listen(svg, "keydown", ctx[17])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1024)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
          }
        } else {
          if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
            default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
          }
        }
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
          { "data-carbon-icon": "Cut16" },
          { xmlns: "http://www.w3.org/2000/svg" },
          { viewBox: "0 0 32 32" },
          { fill: "currentColor" },
          { width: "16" },
          { height: "16" },
          (!current || dirty & 1) && { class: ctx2[0] },
          { preserveAspectRatio: "xMidYMid meet" },
          (!current || dirty & 8) && { style: ctx2[3] },
          (!current || dirty & 2) && { id: ctx2[1] },
          dirty & 16 && ctx2[4]
        ]));
      },
      i(local) {
        if (current)
          return;
        transition_in(default_slot_or_fallback, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot_or_fallback, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(svg);
        if (default_slot_or_fallback)
          default_slot_or_fallback.d(detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance22($$self, $$props, $$invalidate) {
    let ariaLabel;
    let ariaLabelledBy;
    let labelled;
    let attributes;
    let { $$slots: slots = {}, $$scope } = $$props;
    let { class: className = void 0 } = $$props;
    let { id = void 0 } = $$props;
    let { tabindex = void 0 } = $$props;
    let { focusable = false } = $$props;
    let { title: title2 = void 0 } = $$props;
    let { style = void 0 } = $$props;
    function click_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseover_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseenter_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseleave_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keyup_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keydown_handler(event) {
      bubble.call(this, $$self, event);
    }
    $$self.$$set = ($$new_props) => {
      $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
      if ("class" in $$new_props)
        $$invalidate(0, className = $$new_props.class);
      if ("id" in $$new_props)
        $$invalidate(1, id = $$new_props.id);
      if ("tabindex" in $$new_props)
        $$invalidate(5, tabindex = $$new_props.tabindex);
      if ("focusable" in $$new_props)
        $$invalidate(6, focusable = $$new_props.focusable);
      if ("title" in $$new_props)
        $$invalidate(2, title2 = $$new_props.title);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("$$scope" in $$new_props)
        $$invalidate(10, $$scope = $$new_props.$$scope);
    };
    $$self.$$.update = () => {
      $:
        $$invalidate(9, ariaLabel = $$props["aria-label"]);
      $:
        $$invalidate(8, ariaLabelledBy = $$props["aria-labelledby"]);
      if ($$self.$$.dirty & 772) {
        $:
          $$invalidate(7, labelled = ariaLabel || ariaLabelledBy || title2);
      }
      if ($$self.$$.dirty & 992) {
        $:
          $$invalidate(4, attributes = {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-hidden": labelled ? void 0 : true,
            role: labelled ? "img" : void 0,
            focusable: tabindex === "0" ? true : focusable,
            tabindex
          });
      }
    };
    $$props = exclude_internal_props($$props);
    return [
      className,
      id,
      title2,
      style,
      attributes,
      tabindex,
      focusable,
      labelled,
      ariaLabelledBy,
      ariaLabel,
      $$scope,
      slots,
      click_handler,
      mouseover_handler,
      mouseenter_handler,
      mouseleave_handler,
      keyup_handler,
      keydown_handler
    ];
  }
  var Cut16 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance22, create_fragment22, safe_not_equal, {
        class: 0,
        id: 1,
        tabindex: 5,
        focusable: 6,
        title: 2,
        style: 3
      });
    }
  };
  var Cut16_default = Cut16;

  // elos-web/node_modules/carbon-icons-svelte/lib/Cut16/index.js
  var Cut16_default2 = Cut16_default;

  // elos-web/node_modules/carbon-icons-svelte/lib/Delete16/Delete16.svelte
  function create_if_block22(ctx) {
    let title_1;
    let t;
    return {
      c() {
        title_1 = svg_element("title");
        t = text(ctx[2]);
      },
      m(target, anchor) {
        insert(target, title_1, anchor);
        append(title_1, t);
      },
      p(ctx2, dirty) {
        if (dirty & 4)
          set_data(t, ctx2[2]);
      },
      d(detaching) {
        if (detaching)
          detach(title_1);
      }
    };
  }
  function fallback_block22(ctx) {
    let if_block_anchor;
    let if_block = ctx[2] && create_if_block22(ctx);
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (ctx2[2]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block22(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach(if_block_anchor);
      }
    };
  }
  function create_fragment23(ctx) {
    let svg;
    let path0;
    let path1;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[11].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
    const default_slot_or_fallback = default_slot || fallback_block22(ctx);
    let svg_levels = [
      { "data-carbon-icon": "Delete16" },
      { xmlns: "http://www.w3.org/2000/svg" },
      { viewBox: "0 0 32 32" },
      { fill: "currentColor" },
      { width: "16" },
      { height: "16" },
      { class: ctx[0] },
      { preserveAspectRatio: "xMidYMid meet" },
      { style: ctx[3] },
      { id: ctx[1] },
      ctx[4]
    ];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    return {
      c() {
        svg = svg_element("svg");
        path0 = svg_element("path");
        path1 = svg_element("path");
        if (default_slot_or_fallback)
          default_slot_or_fallback.c();
        attr(path0, "d", "M12 12H14V24H12zM18 12H20V24H18z");
        attr(path1, "d", "M4 6V8H6V28a2 2 0 002 2H24a2 2 0 002-2V8h2V6zM8 28V8H24V28zM12 2H20V4H12z");
        set_svg_attributes(svg, svg_data);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path0);
        append(svg, path1);
        if (default_slot_or_fallback) {
          default_slot_or_fallback.m(svg, null);
        }
        current = true;
        if (!mounted) {
          dispose = [
            listen(svg, "click", ctx[12]),
            listen(svg, "mouseover", ctx[13]),
            listen(svg, "mouseenter", ctx[14]),
            listen(svg, "mouseleave", ctx[15]),
            listen(svg, "keyup", ctx[16]),
            listen(svg, "keydown", ctx[17])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1024)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
          }
        } else {
          if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
            default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
          }
        }
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
          { "data-carbon-icon": "Delete16" },
          { xmlns: "http://www.w3.org/2000/svg" },
          { viewBox: "0 0 32 32" },
          { fill: "currentColor" },
          { width: "16" },
          { height: "16" },
          (!current || dirty & 1) && { class: ctx2[0] },
          { preserveAspectRatio: "xMidYMid meet" },
          (!current || dirty & 8) && { style: ctx2[3] },
          (!current || dirty & 2) && { id: ctx2[1] },
          dirty & 16 && ctx2[4]
        ]));
      },
      i(local) {
        if (current)
          return;
        transition_in(default_slot_or_fallback, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot_or_fallback, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(svg);
        if (default_slot_or_fallback)
          default_slot_or_fallback.d(detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance23($$self, $$props, $$invalidate) {
    let ariaLabel;
    let ariaLabelledBy;
    let labelled;
    let attributes;
    let { $$slots: slots = {}, $$scope } = $$props;
    let { class: className = void 0 } = $$props;
    let { id = void 0 } = $$props;
    let { tabindex = void 0 } = $$props;
    let { focusable = false } = $$props;
    let { title: title2 = void 0 } = $$props;
    let { style = void 0 } = $$props;
    function click_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseover_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseenter_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseleave_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keyup_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keydown_handler(event) {
      bubble.call(this, $$self, event);
    }
    $$self.$$set = ($$new_props) => {
      $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
      if ("class" in $$new_props)
        $$invalidate(0, className = $$new_props.class);
      if ("id" in $$new_props)
        $$invalidate(1, id = $$new_props.id);
      if ("tabindex" in $$new_props)
        $$invalidate(5, tabindex = $$new_props.tabindex);
      if ("focusable" in $$new_props)
        $$invalidate(6, focusable = $$new_props.focusable);
      if ("title" in $$new_props)
        $$invalidate(2, title2 = $$new_props.title);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("$$scope" in $$new_props)
        $$invalidate(10, $$scope = $$new_props.$$scope);
    };
    $$self.$$.update = () => {
      $:
        $$invalidate(9, ariaLabel = $$props["aria-label"]);
      $:
        $$invalidate(8, ariaLabelledBy = $$props["aria-labelledby"]);
      if ($$self.$$.dirty & 772) {
        $:
          $$invalidate(7, labelled = ariaLabel || ariaLabelledBy || title2);
      }
      if ($$self.$$.dirty & 992) {
        $:
          $$invalidate(4, attributes = {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-hidden": labelled ? void 0 : true,
            role: labelled ? "img" : void 0,
            focusable: tabindex === "0" ? true : focusable,
            tabindex
          });
      }
    };
    $$props = exclude_internal_props($$props);
    return [
      className,
      id,
      title2,
      style,
      attributes,
      tabindex,
      focusable,
      labelled,
      ariaLabelledBy,
      ariaLabel,
      $$scope,
      slots,
      click_handler,
      mouseover_handler,
      mouseenter_handler,
      mouseleave_handler,
      keyup_handler,
      keydown_handler
    ];
  }
  var Delete16 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance23, create_fragment23, safe_not_equal, {
        class: 0,
        id: 1,
        tabindex: 5,
        focusable: 6,
        title: 2,
        style: 3
      });
    }
  };
  var Delete16_default = Delete16;

  // elos-web/node_modules/carbon-icons-svelte/lib/Delete16/index.js
  var Delete16_default2 = Delete16_default;

  // elos-web/node_modules/carbon-icons-svelte/lib/DeployRules16/DeployRules16.svelte
  function create_if_block23(ctx) {
    let title_1;
    let t;
    return {
      c() {
        title_1 = svg_element("title");
        t = text(ctx[2]);
      },
      m(target, anchor) {
        insert(target, title_1, anchor);
        append(title_1, t);
      },
      p(ctx2, dirty) {
        if (dirty & 4)
          set_data(t, ctx2[2]);
      },
      d(detaching) {
        if (detaching)
          detach(title_1);
      }
    };
  }
  function fallback_block23(ctx) {
    let if_block_anchor;
    let if_block = ctx[2] && create_if_block23(ctx);
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (ctx2[2]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block23(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach(if_block_anchor);
      }
    };
  }
  function create_fragment24(ctx) {
    let svg;
    let path;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[11].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
    const default_slot_or_fallback = default_slot || fallback_block23(ctx);
    let svg_levels = [
      { "data-carbon-icon": "DeployRules16" },
      { xmlns: "http://www.w3.org/2000/svg" },
      { viewBox: "0 0 32 32" },
      { fill: "currentColor" },
      { width: "16" },
      { height: "16" },
      { class: ctx[0] },
      { preserveAspectRatio: "xMidYMid meet" },
      { style: ctx[3] },
      { id: ctx[1] },
      ctx[4]
    ];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        if (default_slot_or_fallback)
          default_slot_or_fallback.c();
        attr(path, "d", "M18 4L12 10 13.41 11.41 17 7.83 17 20 19 20 19 7.83 22.59 11.41 24 10 18 4zM8 18H15V20H8zM8 22H24V24H8zM8 26H24V28H8z");
        set_svg_attributes(svg, svg_data);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        if (default_slot_or_fallback) {
          default_slot_or_fallback.m(svg, null);
        }
        current = true;
        if (!mounted) {
          dispose = [
            listen(svg, "click", ctx[12]),
            listen(svg, "mouseover", ctx[13]),
            listen(svg, "mouseenter", ctx[14]),
            listen(svg, "mouseleave", ctx[15]),
            listen(svg, "keyup", ctx[16]),
            listen(svg, "keydown", ctx[17])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1024)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
          }
        } else {
          if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
            default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
          }
        }
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
          { "data-carbon-icon": "DeployRules16" },
          { xmlns: "http://www.w3.org/2000/svg" },
          { viewBox: "0 0 32 32" },
          { fill: "currentColor" },
          { width: "16" },
          { height: "16" },
          (!current || dirty & 1) && { class: ctx2[0] },
          { preserveAspectRatio: "xMidYMid meet" },
          (!current || dirty & 8) && { style: ctx2[3] },
          (!current || dirty & 2) && { id: ctx2[1] },
          dirty & 16 && ctx2[4]
        ]));
      },
      i(local) {
        if (current)
          return;
        transition_in(default_slot_or_fallback, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot_or_fallback, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(svg);
        if (default_slot_or_fallback)
          default_slot_or_fallback.d(detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance24($$self, $$props, $$invalidate) {
    let ariaLabel;
    let ariaLabelledBy;
    let labelled;
    let attributes;
    let { $$slots: slots = {}, $$scope } = $$props;
    let { class: className = void 0 } = $$props;
    let { id = void 0 } = $$props;
    let { tabindex = void 0 } = $$props;
    let { focusable = false } = $$props;
    let { title: title2 = void 0 } = $$props;
    let { style = void 0 } = $$props;
    function click_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseover_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseenter_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseleave_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keyup_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keydown_handler(event) {
      bubble.call(this, $$self, event);
    }
    $$self.$$set = ($$new_props) => {
      $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
      if ("class" in $$new_props)
        $$invalidate(0, className = $$new_props.class);
      if ("id" in $$new_props)
        $$invalidate(1, id = $$new_props.id);
      if ("tabindex" in $$new_props)
        $$invalidate(5, tabindex = $$new_props.tabindex);
      if ("focusable" in $$new_props)
        $$invalidate(6, focusable = $$new_props.focusable);
      if ("title" in $$new_props)
        $$invalidate(2, title2 = $$new_props.title);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("$$scope" in $$new_props)
        $$invalidate(10, $$scope = $$new_props.$$scope);
    };
    $$self.$$.update = () => {
      $:
        $$invalidate(9, ariaLabel = $$props["aria-label"]);
      $:
        $$invalidate(8, ariaLabelledBy = $$props["aria-labelledby"]);
      if ($$self.$$.dirty & 772) {
        $:
          $$invalidate(7, labelled = ariaLabel || ariaLabelledBy || title2);
      }
      if ($$self.$$.dirty & 992) {
        $:
          $$invalidate(4, attributes = {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-hidden": labelled ? void 0 : true,
            role: labelled ? "img" : void 0,
            focusable: tabindex === "0" ? true : focusable,
            tabindex
          });
      }
    };
    $$props = exclude_internal_props($$props);
    return [
      className,
      id,
      title2,
      style,
      attributes,
      tabindex,
      focusable,
      labelled,
      ariaLabelledBy,
      ariaLabel,
      $$scope,
      slots,
      click_handler,
      mouseover_handler,
      mouseenter_handler,
      mouseleave_handler,
      keyup_handler,
      keydown_handler
    ];
  }
  var DeployRules16 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance24, create_fragment24, safe_not_equal, {
        class: 0,
        id: 1,
        tabindex: 5,
        focusable: 6,
        title: 2,
        style: 3
      });
    }
  };
  var DeployRules16_default = DeployRules16;

  // elos-web/node_modules/carbon-icons-svelte/lib/DeployRules16/index.js
  var DeployRules16_default2 = DeployRules16_default;

  // elos-web/node_modules/carbon-icons-svelte/lib/Download16/Download16.svelte
  function create_if_block24(ctx) {
    let title_1;
    let t;
    return {
      c() {
        title_1 = svg_element("title");
        t = text(ctx[2]);
      },
      m(target, anchor) {
        insert(target, title_1, anchor);
        append(title_1, t);
      },
      p(ctx2, dirty) {
        if (dirty & 4)
          set_data(t, ctx2[2]);
      },
      d(detaching) {
        if (detaching)
          detach(title_1);
      }
    };
  }
  function fallback_block24(ctx) {
    let if_block_anchor;
    let if_block = ctx[2] && create_if_block24(ctx);
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (ctx2[2]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block24(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach(if_block_anchor);
      }
    };
  }
  function create_fragment25(ctx) {
    let svg;
    let path;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[11].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
    const default_slot_or_fallback = default_slot || fallback_block24(ctx);
    let svg_levels = [
      { "data-carbon-icon": "Download16" },
      { xmlns: "http://www.w3.org/2000/svg" },
      { viewBox: "0 0 16 16" },
      { fill: "currentColor" },
      { width: "16" },
      { height: "16" },
      { class: ctx[0] },
      { preserveAspectRatio: "xMidYMid meet" },
      { style: ctx[3] },
      { id: ctx[1] },
      ctx[4]
    ];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        if (default_slot_or_fallback)
          default_slot_or_fallback.c();
        attr(path, "d", "M13 7L12.3 6.3 8.5 10.1 8.5 1 7.5 1 7.5 10.1 3.7 6.3 3 7 8 12zM13 12v2H3v-2H2v2l0 0c0 .6.4 1 1 1h10c.6 0 1-.4 1-1l0 0v-2H13z");
        set_svg_attributes(svg, svg_data);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        if (default_slot_or_fallback) {
          default_slot_or_fallback.m(svg, null);
        }
        current = true;
        if (!mounted) {
          dispose = [
            listen(svg, "click", ctx[12]),
            listen(svg, "mouseover", ctx[13]),
            listen(svg, "mouseenter", ctx[14]),
            listen(svg, "mouseleave", ctx[15]),
            listen(svg, "keyup", ctx[16]),
            listen(svg, "keydown", ctx[17])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1024)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
          }
        } else {
          if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
            default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
          }
        }
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
          { "data-carbon-icon": "Download16" },
          { xmlns: "http://www.w3.org/2000/svg" },
          { viewBox: "0 0 16 16" },
          { fill: "currentColor" },
          { width: "16" },
          { height: "16" },
          (!current || dirty & 1) && { class: ctx2[0] },
          { preserveAspectRatio: "xMidYMid meet" },
          (!current || dirty & 8) && { style: ctx2[3] },
          (!current || dirty & 2) && { id: ctx2[1] },
          dirty & 16 && ctx2[4]
        ]));
      },
      i(local) {
        if (current)
          return;
        transition_in(default_slot_or_fallback, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot_or_fallback, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(svg);
        if (default_slot_or_fallback)
          default_slot_or_fallback.d(detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance25($$self, $$props, $$invalidate) {
    let ariaLabel;
    let ariaLabelledBy;
    let labelled;
    let attributes;
    let { $$slots: slots = {}, $$scope } = $$props;
    let { class: className = void 0 } = $$props;
    let { id = void 0 } = $$props;
    let { tabindex = void 0 } = $$props;
    let { focusable = false } = $$props;
    let { title: title2 = void 0 } = $$props;
    let { style = void 0 } = $$props;
    function click_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseover_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseenter_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseleave_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keyup_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keydown_handler(event) {
      bubble.call(this, $$self, event);
    }
    $$self.$$set = ($$new_props) => {
      $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
      if ("class" in $$new_props)
        $$invalidate(0, className = $$new_props.class);
      if ("id" in $$new_props)
        $$invalidate(1, id = $$new_props.id);
      if ("tabindex" in $$new_props)
        $$invalidate(5, tabindex = $$new_props.tabindex);
      if ("focusable" in $$new_props)
        $$invalidate(6, focusable = $$new_props.focusable);
      if ("title" in $$new_props)
        $$invalidate(2, title2 = $$new_props.title);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("$$scope" in $$new_props)
        $$invalidate(10, $$scope = $$new_props.$$scope);
    };
    $$self.$$.update = () => {
      $:
        $$invalidate(9, ariaLabel = $$props["aria-label"]);
      $:
        $$invalidate(8, ariaLabelledBy = $$props["aria-labelledby"]);
      if ($$self.$$.dirty & 772) {
        $:
          $$invalidate(7, labelled = ariaLabel || ariaLabelledBy || title2);
      }
      if ($$self.$$.dirty & 992) {
        $:
          $$invalidate(4, attributes = {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-hidden": labelled ? void 0 : true,
            role: labelled ? "img" : void 0,
            focusable: tabindex === "0" ? true : focusable,
            tabindex
          });
      }
    };
    $$props = exclude_internal_props($$props);
    return [
      className,
      id,
      title2,
      style,
      attributes,
      tabindex,
      focusable,
      labelled,
      ariaLabelledBy,
      ariaLabel,
      $$scope,
      slots,
      click_handler,
      mouseover_handler,
      mouseenter_handler,
      mouseleave_handler,
      keyup_handler,
      keydown_handler
    ];
  }
  var Download16 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance25, create_fragment25, safe_not_equal, {
        class: 0,
        id: 1,
        tabindex: 5,
        focusable: 6,
        title: 2,
        style: 3
      });
    }
  };
  var Download16_default = Download16;

  // elos-web/node_modules/carbon-icons-svelte/lib/Download16/index.js
  var Download16_default2 = Download16_default;

  // elos-web/node_modules/carbon-icons-svelte/lib/Education16/Education16.svelte
  function create_if_block25(ctx) {
    let title_1;
    let t;
    return {
      c() {
        title_1 = svg_element("title");
        t = text(ctx[2]);
      },
      m(target, anchor) {
        insert(target, title_1, anchor);
        append(title_1, t);
      },
      p(ctx2, dirty) {
        if (dirty & 4)
          set_data(t, ctx2[2]);
      },
      d(detaching) {
        if (detaching)
          detach(title_1);
      }
    };
  }
  function fallback_block25(ctx) {
    let if_block_anchor;
    let if_block = ctx[2] && create_if_block25(ctx);
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (ctx2[2]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block25(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach(if_block_anchor);
      }
    };
  }
  function create_fragment26(ctx) {
    let svg;
    let path0;
    let path1;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[11].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
    const default_slot_or_fallback = default_slot || fallback_block25(ctx);
    let svg_levels = [
      { "data-carbon-icon": "Education16" },
      { xmlns: "http://www.w3.org/2000/svg" },
      { viewBox: "0 0 32 32" },
      { fill: "currentColor" },
      { width: "16" },
      { height: "16" },
      { class: ctx[0] },
      { preserveAspectRatio: "xMidYMid meet" },
      { style: ctx[3] },
      { id: ctx[1] },
      ctx[4]
    ];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    return {
      c() {
        svg = svg_element("svg");
        path0 = svg_element("path");
        path1 = svg_element("path");
        if (default_slot_or_fallback)
          default_slot_or_fallback.c();
        attr(path0, "d", "M26 30H24V27a5.0059 5.0059 0 00-5-5H13a5.0059 5.0059 0 00-5 5v3H6V27a7.0082 7.0082 0 017-7h6a7.0082 7.0082 0 017 7zM5 6A1 1 0 004 7v9H6V7A1 1 0 005 6z");
        attr(path1, "d", "M4,2V4H9v7a7,7,0,0,0,14,0V4h5V2Zm7,2H21V7H11Zm5,12a5,5,0,0,1-5-5V9H21v2A5,5,0,0,1,16,16Z");
        set_svg_attributes(svg, svg_data);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path0);
        append(svg, path1);
        if (default_slot_or_fallback) {
          default_slot_or_fallback.m(svg, null);
        }
        current = true;
        if (!mounted) {
          dispose = [
            listen(svg, "click", ctx[12]),
            listen(svg, "mouseover", ctx[13]),
            listen(svg, "mouseenter", ctx[14]),
            listen(svg, "mouseleave", ctx[15]),
            listen(svg, "keyup", ctx[16]),
            listen(svg, "keydown", ctx[17])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1024)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
          }
        } else {
          if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
            default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
          }
        }
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
          { "data-carbon-icon": "Education16" },
          { xmlns: "http://www.w3.org/2000/svg" },
          { viewBox: "0 0 32 32" },
          { fill: "currentColor" },
          { width: "16" },
          { height: "16" },
          (!current || dirty & 1) && { class: ctx2[0] },
          { preserveAspectRatio: "xMidYMid meet" },
          (!current || dirty & 8) && { style: ctx2[3] },
          (!current || dirty & 2) && { id: ctx2[1] },
          dirty & 16 && ctx2[4]
        ]));
      },
      i(local) {
        if (current)
          return;
        transition_in(default_slot_or_fallback, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot_or_fallback, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(svg);
        if (default_slot_or_fallback)
          default_slot_or_fallback.d(detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance26($$self, $$props, $$invalidate) {
    let ariaLabel;
    let ariaLabelledBy;
    let labelled;
    let attributes;
    let { $$slots: slots = {}, $$scope } = $$props;
    let { class: className = void 0 } = $$props;
    let { id = void 0 } = $$props;
    let { tabindex = void 0 } = $$props;
    let { focusable = false } = $$props;
    let { title: title2 = void 0 } = $$props;
    let { style = void 0 } = $$props;
    function click_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseover_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseenter_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseleave_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keyup_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keydown_handler(event) {
      bubble.call(this, $$self, event);
    }
    $$self.$$set = ($$new_props) => {
      $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
      if ("class" in $$new_props)
        $$invalidate(0, className = $$new_props.class);
      if ("id" in $$new_props)
        $$invalidate(1, id = $$new_props.id);
      if ("tabindex" in $$new_props)
        $$invalidate(5, tabindex = $$new_props.tabindex);
      if ("focusable" in $$new_props)
        $$invalidate(6, focusable = $$new_props.focusable);
      if ("title" in $$new_props)
        $$invalidate(2, title2 = $$new_props.title);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("$$scope" in $$new_props)
        $$invalidate(10, $$scope = $$new_props.$$scope);
    };
    $$self.$$.update = () => {
      $:
        $$invalidate(9, ariaLabel = $$props["aria-label"]);
      $:
        $$invalidate(8, ariaLabelledBy = $$props["aria-labelledby"]);
      if ($$self.$$.dirty & 772) {
        $:
          $$invalidate(7, labelled = ariaLabel || ariaLabelledBy || title2);
      }
      if ($$self.$$.dirty & 992) {
        $:
          $$invalidate(4, attributes = {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-hidden": labelled ? void 0 : true,
            role: labelled ? "img" : void 0,
            focusable: tabindex === "0" ? true : focusable,
            tabindex
          });
      }
    };
    $$props = exclude_internal_props($$props);
    return [
      className,
      id,
      title2,
      style,
      attributes,
      tabindex,
      focusable,
      labelled,
      ariaLabelledBy,
      ariaLabel,
      $$scope,
      slots,
      click_handler,
      mouseover_handler,
      mouseenter_handler,
      mouseleave_handler,
      keyup_handler,
      keydown_handler
    ];
  }
  var Education16 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance26, create_fragment26, safe_not_equal, {
        class: 0,
        id: 1,
        tabindex: 5,
        focusable: 6,
        title: 2,
        style: 3
      });
    }
  };
  var Education16_default = Education16;

  // elos-web/node_modules/carbon-icons-svelte/lib/Education16/index.js
  var Education16_default2 = Education16_default;

  // elos-web/node_modules/carbon-icons-svelte/lib/Exit16/Exit16.svelte
  function create_if_block26(ctx) {
    let title_1;
    let t;
    return {
      c() {
        title_1 = svg_element("title");
        t = text(ctx[2]);
      },
      m(target, anchor) {
        insert(target, title_1, anchor);
        append(title_1, t);
      },
      p(ctx2, dirty) {
        if (dirty & 4)
          set_data(t, ctx2[2]);
      },
      d(detaching) {
        if (detaching)
          detach(title_1);
      }
    };
  }
  function fallback_block26(ctx) {
    let if_block_anchor;
    let if_block = ctx[2] && create_if_block26(ctx);
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (ctx2[2]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block26(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach(if_block_anchor);
      }
    };
  }
  function create_fragment27(ctx) {
    let svg;
    let path;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[11].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
    const default_slot_or_fallback = default_slot || fallback_block26(ctx);
    let svg_levels = [
      { "data-carbon-icon": "Exit16" },
      { xmlns: "http://www.w3.org/2000/svg" },
      { viewBox: "0 0 32 32" },
      { fill: "currentColor" },
      { width: "16" },
      { height: "16" },
      { class: ctx[0] },
      { preserveAspectRatio: "xMidYMid meet" },
      { style: ctx[3] },
      { id: ctx[1] },
      ctx[4]
    ];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        if (default_slot_or_fallback)
          default_slot_or_fallback.c();
        attr(path, "d", "M26 4H28V28H26zM11.414 20.586L7.828 17 22 17 22 15 7.828 15 11.414 11.414 10 10 4 16 10 22 11.414 20.586z");
        set_svg_attributes(svg, svg_data);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        if (default_slot_or_fallback) {
          default_slot_or_fallback.m(svg, null);
        }
        current = true;
        if (!mounted) {
          dispose = [
            listen(svg, "click", ctx[12]),
            listen(svg, "mouseover", ctx[13]),
            listen(svg, "mouseenter", ctx[14]),
            listen(svg, "mouseleave", ctx[15]),
            listen(svg, "keyup", ctx[16]),
            listen(svg, "keydown", ctx[17])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1024)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
          }
        } else {
          if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
            default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
          }
        }
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
          { "data-carbon-icon": "Exit16" },
          { xmlns: "http://www.w3.org/2000/svg" },
          { viewBox: "0 0 32 32" },
          { fill: "currentColor" },
          { width: "16" },
          { height: "16" },
          (!current || dirty & 1) && { class: ctx2[0] },
          { preserveAspectRatio: "xMidYMid meet" },
          (!current || dirty & 8) && { style: ctx2[3] },
          (!current || dirty & 2) && { id: ctx2[1] },
          dirty & 16 && ctx2[4]
        ]));
      },
      i(local) {
        if (current)
          return;
        transition_in(default_slot_or_fallback, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot_or_fallback, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(svg);
        if (default_slot_or_fallback)
          default_slot_or_fallback.d(detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance27($$self, $$props, $$invalidate) {
    let ariaLabel;
    let ariaLabelledBy;
    let labelled;
    let attributes;
    let { $$slots: slots = {}, $$scope } = $$props;
    let { class: className = void 0 } = $$props;
    let { id = void 0 } = $$props;
    let { tabindex = void 0 } = $$props;
    let { focusable = false } = $$props;
    let { title: title2 = void 0 } = $$props;
    let { style = void 0 } = $$props;
    function click_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseover_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseenter_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseleave_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keyup_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keydown_handler(event) {
      bubble.call(this, $$self, event);
    }
    $$self.$$set = ($$new_props) => {
      $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
      if ("class" in $$new_props)
        $$invalidate(0, className = $$new_props.class);
      if ("id" in $$new_props)
        $$invalidate(1, id = $$new_props.id);
      if ("tabindex" in $$new_props)
        $$invalidate(5, tabindex = $$new_props.tabindex);
      if ("focusable" in $$new_props)
        $$invalidate(6, focusable = $$new_props.focusable);
      if ("title" in $$new_props)
        $$invalidate(2, title2 = $$new_props.title);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("$$scope" in $$new_props)
        $$invalidate(10, $$scope = $$new_props.$$scope);
    };
    $$self.$$.update = () => {
      $:
        $$invalidate(9, ariaLabel = $$props["aria-label"]);
      $:
        $$invalidate(8, ariaLabelledBy = $$props["aria-labelledby"]);
      if ($$self.$$.dirty & 772) {
        $:
          $$invalidate(7, labelled = ariaLabel || ariaLabelledBy || title2);
      }
      if ($$self.$$.dirty & 992) {
        $:
          $$invalidate(4, attributes = {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-hidden": labelled ? void 0 : true,
            role: labelled ? "img" : void 0,
            focusable: tabindex === "0" ? true : focusable,
            tabindex
          });
      }
    };
    $$props = exclude_internal_props($$props);
    return [
      className,
      id,
      title2,
      style,
      attributes,
      tabindex,
      focusable,
      labelled,
      ariaLabelledBy,
      ariaLabel,
      $$scope,
      slots,
      click_handler,
      mouseover_handler,
      mouseenter_handler,
      mouseleave_handler,
      keyup_handler,
      keydown_handler
    ];
  }
  var Exit16 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance27, create_fragment27, safe_not_equal, {
        class: 0,
        id: 1,
        tabindex: 5,
        focusable: 6,
        title: 2,
        style: 3
      });
    }
  };
  var Exit16_default = Exit16;

  // elos-web/node_modules/carbon-icons-svelte/lib/Exit16/index.js
  var Exit16_default2 = Exit16_default;

  // elos-web/node_modules/carbon-icons-svelte/lib/Export16/Export16.svelte
  function create_if_block27(ctx) {
    let title_1;
    let t;
    return {
      c() {
        title_1 = svg_element("title");
        t = text(ctx[2]);
      },
      m(target, anchor) {
        insert(target, title_1, anchor);
        append(title_1, t);
      },
      p(ctx2, dirty) {
        if (dirty & 4)
          set_data(t, ctx2[2]);
      },
      d(detaching) {
        if (detaching)
          detach(title_1);
      }
    };
  }
  function fallback_block27(ctx) {
    let if_block_anchor;
    let if_block = ctx[2] && create_if_block27(ctx);
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (ctx2[2]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block27(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach(if_block_anchor);
      }
    };
  }
  function create_fragment28(ctx) {
    let svg;
    let path;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[11].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
    const default_slot_or_fallback = default_slot || fallback_block27(ctx);
    let svg_levels = [
      { "data-carbon-icon": "Export16" },
      { xmlns: "http://www.w3.org/2000/svg" },
      { viewBox: "0 0 16 16" },
      { fill: "currentColor" },
      { width: "16" },
      { height: "16" },
      { class: ctx[0] },
      { preserveAspectRatio: "xMidYMid meet" },
      { style: ctx[3] },
      { id: ctx[1] },
      ctx[4]
    ];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        if (default_slot_or_fallback)
          default_slot_or_fallback.c();
        attr(path, "d", "M13 12v2H3v-2H2v2l0 0c0 .6.4 1 1 1h10c.6 0 1-.4 1-1l0 0v-2H13zM3 6L3.7 6.7 7.5 2.9 7.5 12 8.5 12 8.5 2.9 12.3 6.7 13 6 8 1z");
        set_svg_attributes(svg, svg_data);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        if (default_slot_or_fallback) {
          default_slot_or_fallback.m(svg, null);
        }
        current = true;
        if (!mounted) {
          dispose = [
            listen(svg, "click", ctx[12]),
            listen(svg, "mouseover", ctx[13]),
            listen(svg, "mouseenter", ctx[14]),
            listen(svg, "mouseleave", ctx[15]),
            listen(svg, "keyup", ctx[16]),
            listen(svg, "keydown", ctx[17])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1024)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
          }
        } else {
          if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
            default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
          }
        }
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
          { "data-carbon-icon": "Export16" },
          { xmlns: "http://www.w3.org/2000/svg" },
          { viewBox: "0 0 16 16" },
          { fill: "currentColor" },
          { width: "16" },
          { height: "16" },
          (!current || dirty & 1) && { class: ctx2[0] },
          { preserveAspectRatio: "xMidYMid meet" },
          (!current || dirty & 8) && { style: ctx2[3] },
          (!current || dirty & 2) && { id: ctx2[1] },
          dirty & 16 && ctx2[4]
        ]));
      },
      i(local) {
        if (current)
          return;
        transition_in(default_slot_or_fallback, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot_or_fallback, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(svg);
        if (default_slot_or_fallback)
          default_slot_or_fallback.d(detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance28($$self, $$props, $$invalidate) {
    let ariaLabel;
    let ariaLabelledBy;
    let labelled;
    let attributes;
    let { $$slots: slots = {}, $$scope } = $$props;
    let { class: className = void 0 } = $$props;
    let { id = void 0 } = $$props;
    let { tabindex = void 0 } = $$props;
    let { focusable = false } = $$props;
    let { title: title2 = void 0 } = $$props;
    let { style = void 0 } = $$props;
    function click_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseover_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseenter_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseleave_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keyup_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keydown_handler(event) {
      bubble.call(this, $$self, event);
    }
    $$self.$$set = ($$new_props) => {
      $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
      if ("class" in $$new_props)
        $$invalidate(0, className = $$new_props.class);
      if ("id" in $$new_props)
        $$invalidate(1, id = $$new_props.id);
      if ("tabindex" in $$new_props)
        $$invalidate(5, tabindex = $$new_props.tabindex);
      if ("focusable" in $$new_props)
        $$invalidate(6, focusable = $$new_props.focusable);
      if ("title" in $$new_props)
        $$invalidate(2, title2 = $$new_props.title);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("$$scope" in $$new_props)
        $$invalidate(10, $$scope = $$new_props.$$scope);
    };
    $$self.$$.update = () => {
      $:
        $$invalidate(9, ariaLabel = $$props["aria-label"]);
      $:
        $$invalidate(8, ariaLabelledBy = $$props["aria-labelledby"]);
      if ($$self.$$.dirty & 772) {
        $:
          $$invalidate(7, labelled = ariaLabel || ariaLabelledBy || title2);
      }
      if ($$self.$$.dirty & 992) {
        $:
          $$invalidate(4, attributes = {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-hidden": labelled ? void 0 : true,
            role: labelled ? "img" : void 0,
            focusable: tabindex === "0" ? true : focusable,
            tabindex
          });
      }
    };
    $$props = exclude_internal_props($$props);
    return [
      className,
      id,
      title2,
      style,
      attributes,
      tabindex,
      focusable,
      labelled,
      ariaLabelledBy,
      ariaLabel,
      $$scope,
      slots,
      click_handler,
      mouseover_handler,
      mouseenter_handler,
      mouseleave_handler,
      keyup_handler,
      keydown_handler
    ];
  }
  var Export16 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance28, create_fragment28, safe_not_equal, {
        class: 0,
        id: 1,
        tabindex: 5,
        focusable: 6,
        title: 2,
        style: 3
      });
    }
  };
  var Export16_default = Export16;

  // elos-web/node_modules/carbon-icons-svelte/lib/Export16/index.js
  var Export16_default2 = Export16_default;

  // elos-web/node_modules/carbon-icons-svelte/lib/Image16/Image16.svelte
  function create_if_block28(ctx) {
    let title_1;
    let t;
    return {
      c() {
        title_1 = svg_element("title");
        t = text(ctx[2]);
      },
      m(target, anchor) {
        insert(target, title_1, anchor);
        append(title_1, t);
      },
      p(ctx2, dirty) {
        if (dirty & 4)
          set_data(t, ctx2[2]);
      },
      d(detaching) {
        if (detaching)
          detach(title_1);
      }
    };
  }
  function fallback_block28(ctx) {
    let if_block_anchor;
    let if_block = ctx[2] && create_if_block28(ctx);
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (ctx2[2]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block28(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach(if_block_anchor);
      }
    };
  }
  function create_fragment29(ctx) {
    let svg;
    let path0;
    let path1;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[11].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
    const default_slot_or_fallback = default_slot || fallback_block28(ctx);
    let svg_levels = [
      { "data-carbon-icon": "Image16" },
      { xmlns: "http://www.w3.org/2000/svg" },
      { viewBox: "0 0 32 32" },
      { fill: "currentColor" },
      { width: "16" },
      { height: "16" },
      { class: ctx[0] },
      { preserveAspectRatio: "xMidYMid meet" },
      { style: ctx[3] },
      { id: ctx[1] },
      ctx[4]
    ];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    return {
      c() {
        svg = svg_element("svg");
        path0 = svg_element("path");
        path1 = svg_element("path");
        if (default_slot_or_fallback)
          default_slot_or_fallback.c();
        attr(path0, "d", "M19,14a3,3,0,1,0-3-3A3,3,0,0,0,19,14Zm0-4a1,1,0,1,1-1,1A1,1,0,0,1,19,10Z");
        attr(path1, "d", "M26,4H6A2,2,0,0,0,4,6V26a2,2,0,0,0,2,2H26a2,2,0,0,0,2-2V6A2,2,0,0,0,26,4Zm0,22H6V20l5-5,5.59,5.59a2,2,0,0,0,2.82,0L21,19l5,5Zm0-4.83-3.59-3.59a2,2,0,0,0-2.82,0L18,19.17l-5.59-5.59a2,2,0,0,0-2.82,0L6,17.17V6H26Z");
        set_svg_attributes(svg, svg_data);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path0);
        append(svg, path1);
        if (default_slot_or_fallback) {
          default_slot_or_fallback.m(svg, null);
        }
        current = true;
        if (!mounted) {
          dispose = [
            listen(svg, "click", ctx[12]),
            listen(svg, "mouseover", ctx[13]),
            listen(svg, "mouseenter", ctx[14]),
            listen(svg, "mouseleave", ctx[15]),
            listen(svg, "keyup", ctx[16]),
            listen(svg, "keydown", ctx[17])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1024)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
          }
        } else {
          if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
            default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
          }
        }
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
          { "data-carbon-icon": "Image16" },
          { xmlns: "http://www.w3.org/2000/svg" },
          { viewBox: "0 0 32 32" },
          { fill: "currentColor" },
          { width: "16" },
          { height: "16" },
          (!current || dirty & 1) && { class: ctx2[0] },
          { preserveAspectRatio: "xMidYMid meet" },
          (!current || dirty & 8) && { style: ctx2[3] },
          (!current || dirty & 2) && { id: ctx2[1] },
          dirty & 16 && ctx2[4]
        ]));
      },
      i(local) {
        if (current)
          return;
        transition_in(default_slot_or_fallback, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot_or_fallback, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(svg);
        if (default_slot_or_fallback)
          default_slot_or_fallback.d(detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance29($$self, $$props, $$invalidate) {
    let ariaLabel;
    let ariaLabelledBy;
    let labelled;
    let attributes;
    let { $$slots: slots = {}, $$scope } = $$props;
    let { class: className = void 0 } = $$props;
    let { id = void 0 } = $$props;
    let { tabindex = void 0 } = $$props;
    let { focusable = false } = $$props;
    let { title: title2 = void 0 } = $$props;
    let { style = void 0 } = $$props;
    function click_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseover_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseenter_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseleave_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keyup_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keydown_handler(event) {
      bubble.call(this, $$self, event);
    }
    $$self.$$set = ($$new_props) => {
      $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
      if ("class" in $$new_props)
        $$invalidate(0, className = $$new_props.class);
      if ("id" in $$new_props)
        $$invalidate(1, id = $$new_props.id);
      if ("tabindex" in $$new_props)
        $$invalidate(5, tabindex = $$new_props.tabindex);
      if ("focusable" in $$new_props)
        $$invalidate(6, focusable = $$new_props.focusable);
      if ("title" in $$new_props)
        $$invalidate(2, title2 = $$new_props.title);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("$$scope" in $$new_props)
        $$invalidate(10, $$scope = $$new_props.$$scope);
    };
    $$self.$$.update = () => {
      $:
        $$invalidate(9, ariaLabel = $$props["aria-label"]);
      $:
        $$invalidate(8, ariaLabelledBy = $$props["aria-labelledby"]);
      if ($$self.$$.dirty & 772) {
        $:
          $$invalidate(7, labelled = ariaLabel || ariaLabelledBy || title2);
      }
      if ($$self.$$.dirty & 992) {
        $:
          $$invalidate(4, attributes = {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-hidden": labelled ? void 0 : true,
            role: labelled ? "img" : void 0,
            focusable: tabindex === "0" ? true : focusable,
            tabindex
          });
      }
    };
    $$props = exclude_internal_props($$props);
    return [
      className,
      id,
      title2,
      style,
      attributes,
      tabindex,
      focusable,
      labelled,
      ariaLabelledBy,
      ariaLabel,
      $$scope,
      slots,
      click_handler,
      mouseover_handler,
      mouseenter_handler,
      mouseleave_handler,
      keyup_handler,
      keydown_handler
    ];
  }
  var Image16 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance29, create_fragment29, safe_not_equal, {
        class: 0,
        id: 1,
        tabindex: 5,
        focusable: 6,
        title: 2,
        style: 3
      });
    }
  };
  var Image16_default = Image16;

  // elos-web/node_modules/carbon-icons-svelte/lib/Image16/index.js
  var Image16_default2 = Image16_default;

  // elos-web/node_modules/carbon-icons-svelte/lib/Jpg16/Jpg16.svelte
  function create_if_block29(ctx) {
    let title_1;
    let t;
    return {
      c() {
        title_1 = svg_element("title");
        t = text(ctx[2]);
      },
      m(target, anchor) {
        insert(target, title_1, anchor);
        append(title_1, t);
      },
      p(ctx2, dirty) {
        if (dirty & 4)
          set_data(t, ctx2[2]);
      },
      d(detaching) {
        if (detaching)
          detach(title_1);
      }
    };
  }
  function fallback_block29(ctx) {
    let if_block_anchor;
    let if_block = ctx[2] && create_if_block29(ctx);
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (ctx2[2]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block29(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach(if_block_anchor);
      }
    };
  }
  function create_fragment30(ctx) {
    let svg;
    let path;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[11].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
    const default_slot_or_fallback = default_slot || fallback_block29(ctx);
    let svg_levels = [
      { "data-carbon-icon": "Jpg16" },
      { xmlns: "http://www.w3.org/2000/svg" },
      { viewBox: "0 0 32 32" },
      { fill: "currentColor" },
      { width: "16" },
      { height: "16" },
      { class: ctx[0] },
      { preserveAspectRatio: "xMidYMid meet" },
      { style: ctx[3] },
      { id: ctx[1] },
      ctx[4]
    ];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        if (default_slot_or_fallback)
          default_slot_or_fallback.c();
        attr(path, "d", "M30 23H24a2 2 0 01-2-2V11a2 2 0 012-2h6v2H24V21h4V17H26V15h4zM14 23H12V9h6a2 2 0 012 2v5a2 2 0 01-2 2H14zm0-7h4V11H14zM8 23H4a2 2 0 01-2-2V19H4v2H8V9h2V21A2 2 0 018 23z");
        set_svg_attributes(svg, svg_data);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        if (default_slot_or_fallback) {
          default_slot_or_fallback.m(svg, null);
        }
        current = true;
        if (!mounted) {
          dispose = [
            listen(svg, "click", ctx[12]),
            listen(svg, "mouseover", ctx[13]),
            listen(svg, "mouseenter", ctx[14]),
            listen(svg, "mouseleave", ctx[15]),
            listen(svg, "keyup", ctx[16]),
            listen(svg, "keydown", ctx[17])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1024)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
          }
        } else {
          if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
            default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
          }
        }
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
          { "data-carbon-icon": "Jpg16" },
          { xmlns: "http://www.w3.org/2000/svg" },
          { viewBox: "0 0 32 32" },
          { fill: "currentColor" },
          { width: "16" },
          { height: "16" },
          (!current || dirty & 1) && { class: ctx2[0] },
          { preserveAspectRatio: "xMidYMid meet" },
          (!current || dirty & 8) && { style: ctx2[3] },
          (!current || dirty & 2) && { id: ctx2[1] },
          dirty & 16 && ctx2[4]
        ]));
      },
      i(local) {
        if (current)
          return;
        transition_in(default_slot_or_fallback, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot_or_fallback, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(svg);
        if (default_slot_or_fallback)
          default_slot_or_fallback.d(detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance30($$self, $$props, $$invalidate) {
    let ariaLabel;
    let ariaLabelledBy;
    let labelled;
    let attributes;
    let { $$slots: slots = {}, $$scope } = $$props;
    let { class: className = void 0 } = $$props;
    let { id = void 0 } = $$props;
    let { tabindex = void 0 } = $$props;
    let { focusable = false } = $$props;
    let { title: title2 = void 0 } = $$props;
    let { style = void 0 } = $$props;
    function click_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseover_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseenter_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseleave_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keyup_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keydown_handler(event) {
      bubble.call(this, $$self, event);
    }
    $$self.$$set = ($$new_props) => {
      $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
      if ("class" in $$new_props)
        $$invalidate(0, className = $$new_props.class);
      if ("id" in $$new_props)
        $$invalidate(1, id = $$new_props.id);
      if ("tabindex" in $$new_props)
        $$invalidate(5, tabindex = $$new_props.tabindex);
      if ("focusable" in $$new_props)
        $$invalidate(6, focusable = $$new_props.focusable);
      if ("title" in $$new_props)
        $$invalidate(2, title2 = $$new_props.title);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("$$scope" in $$new_props)
        $$invalidate(10, $$scope = $$new_props.$$scope);
    };
    $$self.$$.update = () => {
      $:
        $$invalidate(9, ariaLabel = $$props["aria-label"]);
      $:
        $$invalidate(8, ariaLabelledBy = $$props["aria-labelledby"]);
      if ($$self.$$.dirty & 772) {
        $:
          $$invalidate(7, labelled = ariaLabel || ariaLabelledBy || title2);
      }
      if ($$self.$$.dirty & 992) {
        $:
          $$invalidate(4, attributes = {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-hidden": labelled ? void 0 : true,
            role: labelled ? "img" : void 0,
            focusable: tabindex === "0" ? true : focusable,
            tabindex
          });
      }
    };
    $$props = exclude_internal_props($$props);
    return [
      className,
      id,
      title2,
      style,
      attributes,
      tabindex,
      focusable,
      labelled,
      ariaLabelledBy,
      ariaLabel,
      $$scope,
      slots,
      click_handler,
      mouseover_handler,
      mouseenter_handler,
      mouseleave_handler,
      keyup_handler,
      keydown_handler
    ];
  }
  var Jpg16 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance30, create_fragment30, safe_not_equal, {
        class: 0,
        id: 1,
        tabindex: 5,
        focusable: 6,
        title: 2,
        style: 3
      });
    }
  };
  var Jpg16_default = Jpg16;

  // elos-web/node_modules/carbon-icons-svelte/lib/Jpg16/index.js
  var Jpg16_default2 = Jpg16_default;

  // elos-web/node_modules/carbon-icons-svelte/lib/Json16/Json16.svelte
  function create_if_block30(ctx) {
    let title_1;
    let t;
    return {
      c() {
        title_1 = svg_element("title");
        t = text(ctx[2]);
      },
      m(target, anchor) {
        insert(target, title_1, anchor);
        append(title_1, t);
      },
      p(ctx2, dirty) {
        if (dirty & 4)
          set_data(t, ctx2[2]);
      },
      d(detaching) {
        if (detaching)
          detach(title_1);
      }
    };
  }
  function fallback_block30(ctx) {
    let if_block_anchor;
    let if_block = ctx[2] && create_if_block30(ctx);
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (ctx2[2]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block30(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach(if_block_anchor);
      }
    };
  }
  function create_fragment31(ctx) {
    let svg;
    let path;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[11].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
    const default_slot_or_fallback = default_slot || fallback_block30(ctx);
    let svg_levels = [
      { "data-carbon-icon": "Json16" },
      { xmlns: "http://www.w3.org/2000/svg" },
      { viewBox: "0 0 32 32" },
      { fill: "currentColor" },
      { width: "16" },
      { height: "16" },
      { class: ctx[0] },
      { preserveAspectRatio: "xMidYMid meet" },
      { style: ctx[3] },
      { id: ctx[1] },
      ctx[4]
    ];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        if (default_slot_or_fallback)
          default_slot_or_fallback.c();
        attr(path, "d", "M31 11L31 21 29 21 27 15 27 21 25 21 25 11 27 11 29 17 29 11 31 11zM21.3335 21h-2.667A1.6684 1.6684 0 0117 19.3335v-6.667A1.6684 1.6684 0 0118.6665 11h2.667A1.6684 1.6684 0 0123 12.6665v6.667A1.6684 1.6684 0 0121.3335 21zM19 19h2V13H19zM13.3335 21H9V19h4V17H11a2.002 2.002 0 01-2-2V12.6665A1.6684 1.6684 0 0110.6665 11H15v2H11v2h2a2.002 2.002 0 012 2v2.3335A1.6684 1.6684 0 0113.3335 21zM5.3335 21H2.6665A1.6684 1.6684 0 011 19.3335V17H3v2H5V11H7v8.3335A1.6684 1.6684 0 015.3335 21z");
        set_svg_attributes(svg, svg_data);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        if (default_slot_or_fallback) {
          default_slot_or_fallback.m(svg, null);
        }
        current = true;
        if (!mounted) {
          dispose = [
            listen(svg, "click", ctx[12]),
            listen(svg, "mouseover", ctx[13]),
            listen(svg, "mouseenter", ctx[14]),
            listen(svg, "mouseleave", ctx[15]),
            listen(svg, "keyup", ctx[16]),
            listen(svg, "keydown", ctx[17])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1024)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
          }
        } else {
          if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
            default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
          }
        }
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
          { "data-carbon-icon": "Json16" },
          { xmlns: "http://www.w3.org/2000/svg" },
          { viewBox: "0 0 32 32" },
          { fill: "currentColor" },
          { width: "16" },
          { height: "16" },
          (!current || dirty & 1) && { class: ctx2[0] },
          { preserveAspectRatio: "xMidYMid meet" },
          (!current || dirty & 8) && { style: ctx2[3] },
          (!current || dirty & 2) && { id: ctx2[1] },
          dirty & 16 && ctx2[4]
        ]));
      },
      i(local) {
        if (current)
          return;
        transition_in(default_slot_or_fallback, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot_or_fallback, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(svg);
        if (default_slot_or_fallback)
          default_slot_or_fallback.d(detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance31($$self, $$props, $$invalidate) {
    let ariaLabel;
    let ariaLabelledBy;
    let labelled;
    let attributes;
    let { $$slots: slots = {}, $$scope } = $$props;
    let { class: className = void 0 } = $$props;
    let { id = void 0 } = $$props;
    let { tabindex = void 0 } = $$props;
    let { focusable = false } = $$props;
    let { title: title2 = void 0 } = $$props;
    let { style = void 0 } = $$props;
    function click_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseover_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseenter_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseleave_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keyup_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keydown_handler(event) {
      bubble.call(this, $$self, event);
    }
    $$self.$$set = ($$new_props) => {
      $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
      if ("class" in $$new_props)
        $$invalidate(0, className = $$new_props.class);
      if ("id" in $$new_props)
        $$invalidate(1, id = $$new_props.id);
      if ("tabindex" in $$new_props)
        $$invalidate(5, tabindex = $$new_props.tabindex);
      if ("focusable" in $$new_props)
        $$invalidate(6, focusable = $$new_props.focusable);
      if ("title" in $$new_props)
        $$invalidate(2, title2 = $$new_props.title);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("$$scope" in $$new_props)
        $$invalidate(10, $$scope = $$new_props.$$scope);
    };
    $$self.$$.update = () => {
      $:
        $$invalidate(9, ariaLabel = $$props["aria-label"]);
      $:
        $$invalidate(8, ariaLabelledBy = $$props["aria-labelledby"]);
      if ($$self.$$.dirty & 772) {
        $:
          $$invalidate(7, labelled = ariaLabel || ariaLabelledBy || title2);
      }
      if ($$self.$$.dirty & 992) {
        $:
          $$invalidate(4, attributes = {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-hidden": labelled ? void 0 : true,
            role: labelled ? "img" : void 0,
            focusable: tabindex === "0" ? true : focusable,
            tabindex
          });
      }
    };
    $$props = exclude_internal_props($$props);
    return [
      className,
      id,
      title2,
      style,
      attributes,
      tabindex,
      focusable,
      labelled,
      ariaLabelledBy,
      ariaLabel,
      $$scope,
      slots,
      click_handler,
      mouseover_handler,
      mouseenter_handler,
      mouseleave_handler,
      keyup_handler,
      keydown_handler
    ];
  }
  var Json16 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance31, create_fragment31, safe_not_equal, {
        class: 0,
        id: 1,
        tabindex: 5,
        focusable: 6,
        title: 2,
        style: 3
      });
    }
  };
  var Json16_default = Json16;

  // elos-web/node_modules/carbon-icons-svelte/lib/Json16/index.js
  var Json16_default2 = Json16_default;

  // elos-web/node_modules/carbon-icons-svelte/lib/Launch16/Launch16.svelte
  function create_if_block31(ctx) {
    let title_1;
    let t;
    return {
      c() {
        title_1 = svg_element("title");
        t = text(ctx[2]);
      },
      m(target, anchor) {
        insert(target, title_1, anchor);
        append(title_1, t);
      },
      p(ctx2, dirty) {
        if (dirty & 4)
          set_data(t, ctx2[2]);
      },
      d(detaching) {
        if (detaching)
          detach(title_1);
      }
    };
  }
  function fallback_block31(ctx) {
    let if_block_anchor;
    let if_block = ctx[2] && create_if_block31(ctx);
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (ctx2[2]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block31(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach(if_block_anchor);
      }
    };
  }
  function create_fragment32(ctx) {
    let svg;
    let path0;
    let path1;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[11].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
    const default_slot_or_fallback = default_slot || fallback_block31(ctx);
    let svg_levels = [
      { "data-carbon-icon": "Launch16" },
      { xmlns: "http://www.w3.org/2000/svg" },
      { viewBox: "0 0 16 16" },
      { fill: "currentColor" },
      { width: "16" },
      { height: "16" },
      { class: ctx[0] },
      { preserveAspectRatio: "xMidYMid meet" },
      { style: ctx[3] },
      { id: ctx[1] },
      ctx[4]
    ];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    return {
      c() {
        svg = svg_element("svg");
        path0 = svg_element("path");
        path1 = svg_element("path");
        if (default_slot_or_fallback)
          default_slot_or_fallback.c();
        attr(path0, "d", "M13,14H3c-0.6,0-1-0.4-1-1V3c0-0.6,0.4-1,1-1h5v1H3v10h10V8h1v5C14,13.6,13.6,14,13,14z");
        attr(path1, "d", "M10 1L10 2 13.3 2 9 6.3 9.7 7 14 2.7 14 6 15 6 15 1z");
        set_svg_attributes(svg, svg_data);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path0);
        append(svg, path1);
        if (default_slot_or_fallback) {
          default_slot_or_fallback.m(svg, null);
        }
        current = true;
        if (!mounted) {
          dispose = [
            listen(svg, "click", ctx[12]),
            listen(svg, "mouseover", ctx[13]),
            listen(svg, "mouseenter", ctx[14]),
            listen(svg, "mouseleave", ctx[15]),
            listen(svg, "keyup", ctx[16]),
            listen(svg, "keydown", ctx[17])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1024)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
          }
        } else {
          if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
            default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
          }
        }
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
          { "data-carbon-icon": "Launch16" },
          { xmlns: "http://www.w3.org/2000/svg" },
          { viewBox: "0 0 16 16" },
          { fill: "currentColor" },
          { width: "16" },
          { height: "16" },
          (!current || dirty & 1) && { class: ctx2[0] },
          { preserveAspectRatio: "xMidYMid meet" },
          (!current || dirty & 8) && { style: ctx2[3] },
          (!current || dirty & 2) && { id: ctx2[1] },
          dirty & 16 && ctx2[4]
        ]));
      },
      i(local) {
        if (current)
          return;
        transition_in(default_slot_or_fallback, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot_or_fallback, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(svg);
        if (default_slot_or_fallback)
          default_slot_or_fallback.d(detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance32($$self, $$props, $$invalidate) {
    let ariaLabel;
    let ariaLabelledBy;
    let labelled;
    let attributes;
    let { $$slots: slots = {}, $$scope } = $$props;
    let { class: className = void 0 } = $$props;
    let { id = void 0 } = $$props;
    let { tabindex = void 0 } = $$props;
    let { focusable = false } = $$props;
    let { title: title2 = void 0 } = $$props;
    let { style = void 0 } = $$props;
    function click_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseover_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseenter_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseleave_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keyup_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keydown_handler(event) {
      bubble.call(this, $$self, event);
    }
    $$self.$$set = ($$new_props) => {
      $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
      if ("class" in $$new_props)
        $$invalidate(0, className = $$new_props.class);
      if ("id" in $$new_props)
        $$invalidate(1, id = $$new_props.id);
      if ("tabindex" in $$new_props)
        $$invalidate(5, tabindex = $$new_props.tabindex);
      if ("focusable" in $$new_props)
        $$invalidate(6, focusable = $$new_props.focusable);
      if ("title" in $$new_props)
        $$invalidate(2, title2 = $$new_props.title);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("$$scope" in $$new_props)
        $$invalidate(10, $$scope = $$new_props.$$scope);
    };
    $$self.$$.update = () => {
      $:
        $$invalidate(9, ariaLabel = $$props["aria-label"]);
      $:
        $$invalidate(8, ariaLabelledBy = $$props["aria-labelledby"]);
      if ($$self.$$.dirty & 772) {
        $:
          $$invalidate(7, labelled = ariaLabel || ariaLabelledBy || title2);
      }
      if ($$self.$$.dirty & 992) {
        $:
          $$invalidate(4, attributes = {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-hidden": labelled ? void 0 : true,
            role: labelled ? "img" : void 0,
            focusable: tabindex === "0" ? true : focusable,
            tabindex
          });
      }
    };
    $$props = exclude_internal_props($$props);
    return [
      className,
      id,
      title2,
      style,
      attributes,
      tabindex,
      focusable,
      labelled,
      ariaLabelledBy,
      ariaLabel,
      $$scope,
      slots,
      click_handler,
      mouseover_handler,
      mouseenter_handler,
      mouseleave_handler,
      keyup_handler,
      keydown_handler
    ];
  }
  var Launch16 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance32, create_fragment32, safe_not_equal, {
        class: 0,
        id: 1,
        tabindex: 5,
        focusable: 6,
        title: 2,
        style: 3
      });
    }
  };
  var Launch16_default = Launch16;

  // elos-web/node_modules/carbon-icons-svelte/lib/Launch16/index.js
  var Launch16_default2 = Launch16_default;

  // elos-web/node_modules/carbon-icons-svelte/lib/Layers16/Layers16.svelte
  function create_if_block32(ctx) {
    let title_1;
    let t;
    return {
      c() {
        title_1 = svg_element("title");
        t = text(ctx[2]);
      },
      m(target, anchor) {
        insert(target, title_1, anchor);
        append(title_1, t);
      },
      p(ctx2, dirty) {
        if (dirty & 4)
          set_data(t, ctx2[2]);
      },
      d(detaching) {
        if (detaching)
          detach(title_1);
      }
    };
  }
  function fallback_block32(ctx) {
    let if_block_anchor;
    let if_block = ctx[2] && create_if_block32(ctx);
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (ctx2[2]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block32(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach(if_block_anchor);
      }
    };
  }
  function create_fragment33(ctx) {
    let svg;
    let path0;
    let path1;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[11].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
    const default_slot_or_fallback = default_slot || fallback_block32(ctx);
    let svg_levels = [
      { "data-carbon-icon": "Layers16" },
      { xmlns: "http://www.w3.org/2000/svg" },
      { viewBox: "0 0 32 32" },
      { fill: "currentColor" },
      { width: "16" },
      { height: "16" },
      { class: ctx[0] },
      { preserveAspectRatio: "xMidYMid meet" },
      { style: ctx[3] },
      { id: ctx[1] },
      ctx[4]
    ];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    return {
      c() {
        svg = svg_element("svg");
        path0 = svg_element("path");
        path1 = svg_element("path");
        if (default_slot_or_fallback)
          default_slot_or_fallback.c();
        attr(path0, "d", "M16,24a.9967.9967,0,0,1-.4741-.12l-13-7L3.4741,15.12,16,21.8643,28.5259,15.12l.9482,1.7607-13,7A.9967.9967,0,0,1,16,24Z");
        attr(path1, "d", "M16 30a.9967.9967 0 01-.4741-.12l-13-7L3.4741 21.12 16 27.8643 28.5259 21.12l.9482 1.7607-13 7A.9967.9967 0 0116 30zM16 18a.9967.9967 0 01-.4741-.12l-13-7a1 1 0 010-1.7607l13-7a.9982.9982 0 01.9482 0l13 7a1 1 0 010 1.7607l-13 7A.9967.9967 0 0116 18zM5.1094 10L16 15.8643 26.8906 10 16 4.1358z");
        set_svg_attributes(svg, svg_data);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path0);
        append(svg, path1);
        if (default_slot_or_fallback) {
          default_slot_or_fallback.m(svg, null);
        }
        current = true;
        if (!mounted) {
          dispose = [
            listen(svg, "click", ctx[12]),
            listen(svg, "mouseover", ctx[13]),
            listen(svg, "mouseenter", ctx[14]),
            listen(svg, "mouseleave", ctx[15]),
            listen(svg, "keyup", ctx[16]),
            listen(svg, "keydown", ctx[17])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1024)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
          }
        } else {
          if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
            default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
          }
        }
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
          { "data-carbon-icon": "Layers16" },
          { xmlns: "http://www.w3.org/2000/svg" },
          { viewBox: "0 0 32 32" },
          { fill: "currentColor" },
          { width: "16" },
          { height: "16" },
          (!current || dirty & 1) && { class: ctx2[0] },
          { preserveAspectRatio: "xMidYMid meet" },
          (!current || dirty & 8) && { style: ctx2[3] },
          (!current || dirty & 2) && { id: ctx2[1] },
          dirty & 16 && ctx2[4]
        ]));
      },
      i(local) {
        if (current)
          return;
        transition_in(default_slot_or_fallback, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot_or_fallback, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(svg);
        if (default_slot_or_fallback)
          default_slot_or_fallback.d(detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance33($$self, $$props, $$invalidate) {
    let ariaLabel;
    let ariaLabelledBy;
    let labelled;
    let attributes;
    let { $$slots: slots = {}, $$scope } = $$props;
    let { class: className = void 0 } = $$props;
    let { id = void 0 } = $$props;
    let { tabindex = void 0 } = $$props;
    let { focusable = false } = $$props;
    let { title: title2 = void 0 } = $$props;
    let { style = void 0 } = $$props;
    function click_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseover_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseenter_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseleave_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keyup_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keydown_handler(event) {
      bubble.call(this, $$self, event);
    }
    $$self.$$set = ($$new_props) => {
      $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
      if ("class" in $$new_props)
        $$invalidate(0, className = $$new_props.class);
      if ("id" in $$new_props)
        $$invalidate(1, id = $$new_props.id);
      if ("tabindex" in $$new_props)
        $$invalidate(5, tabindex = $$new_props.tabindex);
      if ("focusable" in $$new_props)
        $$invalidate(6, focusable = $$new_props.focusable);
      if ("title" in $$new_props)
        $$invalidate(2, title2 = $$new_props.title);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("$$scope" in $$new_props)
        $$invalidate(10, $$scope = $$new_props.$$scope);
    };
    $$self.$$.update = () => {
      $:
        $$invalidate(9, ariaLabel = $$props["aria-label"]);
      $:
        $$invalidate(8, ariaLabelledBy = $$props["aria-labelledby"]);
      if ($$self.$$.dirty & 772) {
        $:
          $$invalidate(7, labelled = ariaLabel || ariaLabelledBy || title2);
      }
      if ($$self.$$.dirty & 992) {
        $:
          $$invalidate(4, attributes = {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-hidden": labelled ? void 0 : true,
            role: labelled ? "img" : void 0,
            focusable: tabindex === "0" ? true : focusable,
            tabindex
          });
      }
    };
    $$props = exclude_internal_props($$props);
    return [
      className,
      id,
      title2,
      style,
      attributes,
      tabindex,
      focusable,
      labelled,
      ariaLabelledBy,
      ariaLabel,
      $$scope,
      slots,
      click_handler,
      mouseover_handler,
      mouseenter_handler,
      mouseleave_handler,
      keyup_handler,
      keydown_handler
    ];
  }
  var Layers16 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance33, create_fragment33, safe_not_equal, {
        class: 0,
        id: 1,
        tabindex: 5,
        focusable: 6,
        title: 2,
        style: 3
      });
    }
  };
  var Layers16_default = Layers16;

  // elos-web/node_modules/carbon-icons-svelte/lib/Layers16/index.js
  var Layers16_default2 = Layers16_default;

  // elos-web/node_modules/carbon-icons-svelte/lib/Login16/Login16.svelte
  function create_if_block33(ctx) {
    let title_1;
    let t;
    return {
      c() {
        title_1 = svg_element("title");
        t = text(ctx[2]);
      },
      m(target, anchor) {
        insert(target, title_1, anchor);
        append(title_1, t);
      },
      p(ctx2, dirty) {
        if (dirty & 4)
          set_data(t, ctx2[2]);
      },
      d(detaching) {
        if (detaching)
          detach(title_1);
      }
    };
  }
  function fallback_block33(ctx) {
    let if_block_anchor;
    let if_block = ctx[2] && create_if_block33(ctx);
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (ctx2[2]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block33(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach(if_block_anchor);
      }
    };
  }
  function create_fragment34(ctx) {
    let svg;
    let path0;
    let path1;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[11].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
    const default_slot_or_fallback = default_slot || fallback_block33(ctx);
    let svg_levels = [
      { "data-carbon-icon": "Login16" },
      { xmlns: "http://www.w3.org/2000/svg" },
      { viewBox: "0 0 32 32" },
      { fill: "currentColor" },
      { width: "16" },
      { height: "16" },
      { class: ctx[0] },
      { preserveAspectRatio: "xMidYMid meet" },
      { style: ctx[3] },
      { id: ctx[1] },
      ctx[4]
    ];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    return {
      c() {
        svg = svg_element("svg");
        path0 = svg_element("path");
        path1 = svg_element("path");
        if (default_slot_or_fallback)
          default_slot_or_fallback.c();
        attr(path0, "d", "M26,30H14a2,2,0,0,1-2-2V25h2v3H26V4H14V7H12V4a2,2,0,0,1,2-2H26a2,2,0,0,1,2,2V28A2,2,0,0,1,26,30Z");
        attr(path1, "d", "M14.59 20.59L18.17 17 4 17 4 15 18.17 15 14.59 11.41 16 10 22 16 16 22 14.59 20.59z");
        set_svg_attributes(svg, svg_data);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path0);
        append(svg, path1);
        if (default_slot_or_fallback) {
          default_slot_or_fallback.m(svg, null);
        }
        current = true;
        if (!mounted) {
          dispose = [
            listen(svg, "click", ctx[12]),
            listen(svg, "mouseover", ctx[13]),
            listen(svg, "mouseenter", ctx[14]),
            listen(svg, "mouseleave", ctx[15]),
            listen(svg, "keyup", ctx[16]),
            listen(svg, "keydown", ctx[17])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1024)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
          }
        } else {
          if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
            default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
          }
        }
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
          { "data-carbon-icon": "Login16" },
          { xmlns: "http://www.w3.org/2000/svg" },
          { viewBox: "0 0 32 32" },
          { fill: "currentColor" },
          { width: "16" },
          { height: "16" },
          (!current || dirty & 1) && { class: ctx2[0] },
          { preserveAspectRatio: "xMidYMid meet" },
          (!current || dirty & 8) && { style: ctx2[3] },
          (!current || dirty & 2) && { id: ctx2[1] },
          dirty & 16 && ctx2[4]
        ]));
      },
      i(local) {
        if (current)
          return;
        transition_in(default_slot_or_fallback, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot_or_fallback, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(svg);
        if (default_slot_or_fallback)
          default_slot_or_fallback.d(detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance34($$self, $$props, $$invalidate) {
    let ariaLabel;
    let ariaLabelledBy;
    let labelled;
    let attributes;
    let { $$slots: slots = {}, $$scope } = $$props;
    let { class: className = void 0 } = $$props;
    let { id = void 0 } = $$props;
    let { tabindex = void 0 } = $$props;
    let { focusable = false } = $$props;
    let { title: title2 = void 0 } = $$props;
    let { style = void 0 } = $$props;
    function click_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseover_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseenter_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseleave_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keyup_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keydown_handler(event) {
      bubble.call(this, $$self, event);
    }
    $$self.$$set = ($$new_props) => {
      $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
      if ("class" in $$new_props)
        $$invalidate(0, className = $$new_props.class);
      if ("id" in $$new_props)
        $$invalidate(1, id = $$new_props.id);
      if ("tabindex" in $$new_props)
        $$invalidate(5, tabindex = $$new_props.tabindex);
      if ("focusable" in $$new_props)
        $$invalidate(6, focusable = $$new_props.focusable);
      if ("title" in $$new_props)
        $$invalidate(2, title2 = $$new_props.title);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("$$scope" in $$new_props)
        $$invalidate(10, $$scope = $$new_props.$$scope);
    };
    $$self.$$.update = () => {
      $:
        $$invalidate(9, ariaLabel = $$props["aria-label"]);
      $:
        $$invalidate(8, ariaLabelledBy = $$props["aria-labelledby"]);
      if ($$self.$$.dirty & 772) {
        $:
          $$invalidate(7, labelled = ariaLabel || ariaLabelledBy || title2);
      }
      if ($$self.$$.dirty & 992) {
        $:
          $$invalidate(4, attributes = {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-hidden": labelled ? void 0 : true,
            role: labelled ? "img" : void 0,
            focusable: tabindex === "0" ? true : focusable,
            tabindex
          });
      }
    };
    $$props = exclude_internal_props($$props);
    return [
      className,
      id,
      title2,
      style,
      attributes,
      tabindex,
      focusable,
      labelled,
      ariaLabelledBy,
      ariaLabel,
      $$scope,
      slots,
      click_handler,
      mouseover_handler,
      mouseenter_handler,
      mouseleave_handler,
      keyup_handler,
      keydown_handler
    ];
  }
  var Login16 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance34, create_fragment34, safe_not_equal, {
        class: 0,
        id: 1,
        tabindex: 5,
        focusable: 6,
        title: 2,
        style: 3
      });
    }
  };
  var Login16_default = Login16;

  // elos-web/node_modules/carbon-icons-svelte/lib/Login16/index.js
  var Login16_default2 = Login16_default;

  // elos-web/node_modules/carbon-icons-svelte/lib/Maximize16/Maximize16.svelte
  function create_if_block34(ctx) {
    let title_1;
    let t;
    return {
      c() {
        title_1 = svg_element("title");
        t = text(ctx[2]);
      },
      m(target, anchor) {
        insert(target, title_1, anchor);
        append(title_1, t);
      },
      p(ctx2, dirty) {
        if (dirty & 4)
          set_data(t, ctx2[2]);
      },
      d(detaching) {
        if (detaching)
          detach(title_1);
      }
    };
  }
  function fallback_block34(ctx) {
    let if_block_anchor;
    let if_block = ctx[2] && create_if_block34(ctx);
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (ctx2[2]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block34(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach(if_block_anchor);
      }
    };
  }
  function create_fragment35(ctx) {
    let svg;
    let path;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[11].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
    const default_slot_or_fallback = default_slot || fallback_block34(ctx);
    let svg_levels = [
      { "data-carbon-icon": "Maximize16" },
      { xmlns: "http://www.w3.org/2000/svg" },
      { viewBox: "0 0 16 16" },
      { fill: "currentColor" },
      { width: "16" },
      { height: "16" },
      { class: ctx[0] },
      { preserveAspectRatio: "xMidYMid meet" },
      { style: ctx[3] },
      { id: ctx[1] },
      ctx[4]
    ];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        if (default_slot_or_fallback)
          default_slot_or_fallback.c();
        attr(path, "d", "M6 15L6 14 2.7 14 7 9.7 6.3 9 2 13.3 2 10 1 10 1 15zM10 1L10 2 13.3 2 9 6.3 9.7 7 14 2.7 14 6 15 6 15 1z");
        set_svg_attributes(svg, svg_data);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        if (default_slot_or_fallback) {
          default_slot_or_fallback.m(svg, null);
        }
        current = true;
        if (!mounted) {
          dispose = [
            listen(svg, "click", ctx[12]),
            listen(svg, "mouseover", ctx[13]),
            listen(svg, "mouseenter", ctx[14]),
            listen(svg, "mouseleave", ctx[15]),
            listen(svg, "keyup", ctx[16]),
            listen(svg, "keydown", ctx[17])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1024)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
          }
        } else {
          if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
            default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
          }
        }
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
          { "data-carbon-icon": "Maximize16" },
          { xmlns: "http://www.w3.org/2000/svg" },
          { viewBox: "0 0 16 16" },
          { fill: "currentColor" },
          { width: "16" },
          { height: "16" },
          (!current || dirty & 1) && { class: ctx2[0] },
          { preserveAspectRatio: "xMidYMid meet" },
          (!current || dirty & 8) && { style: ctx2[3] },
          (!current || dirty & 2) && { id: ctx2[1] },
          dirty & 16 && ctx2[4]
        ]));
      },
      i(local) {
        if (current)
          return;
        transition_in(default_slot_or_fallback, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot_or_fallback, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(svg);
        if (default_slot_or_fallback)
          default_slot_or_fallback.d(detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance35($$self, $$props, $$invalidate) {
    let ariaLabel;
    let ariaLabelledBy;
    let labelled;
    let attributes;
    let { $$slots: slots = {}, $$scope } = $$props;
    let { class: className = void 0 } = $$props;
    let { id = void 0 } = $$props;
    let { tabindex = void 0 } = $$props;
    let { focusable = false } = $$props;
    let { title: title2 = void 0 } = $$props;
    let { style = void 0 } = $$props;
    function click_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseover_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseenter_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseleave_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keyup_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keydown_handler(event) {
      bubble.call(this, $$self, event);
    }
    $$self.$$set = ($$new_props) => {
      $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
      if ("class" in $$new_props)
        $$invalidate(0, className = $$new_props.class);
      if ("id" in $$new_props)
        $$invalidate(1, id = $$new_props.id);
      if ("tabindex" in $$new_props)
        $$invalidate(5, tabindex = $$new_props.tabindex);
      if ("focusable" in $$new_props)
        $$invalidate(6, focusable = $$new_props.focusable);
      if ("title" in $$new_props)
        $$invalidate(2, title2 = $$new_props.title);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("$$scope" in $$new_props)
        $$invalidate(10, $$scope = $$new_props.$$scope);
    };
    $$self.$$.update = () => {
      $:
        $$invalidate(9, ariaLabel = $$props["aria-label"]);
      $:
        $$invalidate(8, ariaLabelledBy = $$props["aria-labelledby"]);
      if ($$self.$$.dirty & 772) {
        $:
          $$invalidate(7, labelled = ariaLabel || ariaLabelledBy || title2);
      }
      if ($$self.$$.dirty & 992) {
        $:
          $$invalidate(4, attributes = {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-hidden": labelled ? void 0 : true,
            role: labelled ? "img" : void 0,
            focusable: tabindex === "0" ? true : focusable,
            tabindex
          });
      }
    };
    $$props = exclude_internal_props($$props);
    return [
      className,
      id,
      title2,
      style,
      attributes,
      tabindex,
      focusable,
      labelled,
      ariaLabelledBy,
      ariaLabel,
      $$scope,
      slots,
      click_handler,
      mouseover_handler,
      mouseenter_handler,
      mouseleave_handler,
      keyup_handler,
      keydown_handler
    ];
  }
  var Maximize16 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance35, create_fragment35, safe_not_equal, {
        class: 0,
        id: 1,
        tabindex: 5,
        focusable: 6,
        title: 2,
        style: 3
      });
    }
  };
  var Maximize16_default = Maximize16;

  // elos-web/node_modules/carbon-icons-svelte/lib/Maximize16/index.js
  var Maximize16_default2 = Maximize16_default;

  // elos-web/node_modules/carbon-icons-svelte/lib/Menu16/Menu16.svelte
  function create_if_block35(ctx) {
    let title_1;
    let t;
    return {
      c() {
        title_1 = svg_element("title");
        t = text(ctx[2]);
      },
      m(target, anchor) {
        insert(target, title_1, anchor);
        append(title_1, t);
      },
      p(ctx2, dirty) {
        if (dirty & 4)
          set_data(t, ctx2[2]);
      },
      d(detaching) {
        if (detaching)
          detach(title_1);
      }
    };
  }
  function fallback_block35(ctx) {
    let if_block_anchor;
    let if_block = ctx[2] && create_if_block35(ctx);
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (ctx2[2]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block35(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach(if_block_anchor);
      }
    };
  }
  function create_fragment36(ctx) {
    let svg;
    let path;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[11].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
    const default_slot_or_fallback = default_slot || fallback_block35(ctx);
    let svg_levels = [
      { "data-carbon-icon": "Menu16" },
      { xmlns: "http://www.w3.org/2000/svg" },
      { viewBox: "0 0 16 16" },
      { fill: "currentColor" },
      { width: "16" },
      { height: "16" },
      { class: ctx[0] },
      { preserveAspectRatio: "xMidYMid meet" },
      { style: ctx[3] },
      { id: ctx[1] },
      ctx[4]
    ];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        if (default_slot_or_fallback)
          default_slot_or_fallback.c();
        attr(path, "d", "M2 12H14V13H2zM2 9H14V10H2zM2 6H14V7H2zM2 3H14V4H2z");
        set_svg_attributes(svg, svg_data);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        if (default_slot_or_fallback) {
          default_slot_or_fallback.m(svg, null);
        }
        current = true;
        if (!mounted) {
          dispose = [
            listen(svg, "click", ctx[12]),
            listen(svg, "mouseover", ctx[13]),
            listen(svg, "mouseenter", ctx[14]),
            listen(svg, "mouseleave", ctx[15]),
            listen(svg, "keyup", ctx[16]),
            listen(svg, "keydown", ctx[17])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1024)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
          }
        } else {
          if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
            default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
          }
        }
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
          { "data-carbon-icon": "Menu16" },
          { xmlns: "http://www.w3.org/2000/svg" },
          { viewBox: "0 0 16 16" },
          { fill: "currentColor" },
          { width: "16" },
          { height: "16" },
          (!current || dirty & 1) && { class: ctx2[0] },
          { preserveAspectRatio: "xMidYMid meet" },
          (!current || dirty & 8) && { style: ctx2[3] },
          (!current || dirty & 2) && { id: ctx2[1] },
          dirty & 16 && ctx2[4]
        ]));
      },
      i(local) {
        if (current)
          return;
        transition_in(default_slot_or_fallback, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot_or_fallback, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(svg);
        if (default_slot_or_fallback)
          default_slot_or_fallback.d(detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance36($$self, $$props, $$invalidate) {
    let ariaLabel;
    let ariaLabelledBy;
    let labelled;
    let attributes;
    let { $$slots: slots = {}, $$scope } = $$props;
    let { class: className = void 0 } = $$props;
    let { id = void 0 } = $$props;
    let { tabindex = void 0 } = $$props;
    let { focusable = false } = $$props;
    let { title: title2 = void 0 } = $$props;
    let { style = void 0 } = $$props;
    function click_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseover_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseenter_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseleave_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keyup_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keydown_handler(event) {
      bubble.call(this, $$self, event);
    }
    $$self.$$set = ($$new_props) => {
      $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
      if ("class" in $$new_props)
        $$invalidate(0, className = $$new_props.class);
      if ("id" in $$new_props)
        $$invalidate(1, id = $$new_props.id);
      if ("tabindex" in $$new_props)
        $$invalidate(5, tabindex = $$new_props.tabindex);
      if ("focusable" in $$new_props)
        $$invalidate(6, focusable = $$new_props.focusable);
      if ("title" in $$new_props)
        $$invalidate(2, title2 = $$new_props.title);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("$$scope" in $$new_props)
        $$invalidate(10, $$scope = $$new_props.$$scope);
    };
    $$self.$$.update = () => {
      $:
        $$invalidate(9, ariaLabel = $$props["aria-label"]);
      $:
        $$invalidate(8, ariaLabelledBy = $$props["aria-labelledby"]);
      if ($$self.$$.dirty & 772) {
        $:
          $$invalidate(7, labelled = ariaLabel || ariaLabelledBy || title2);
      }
      if ($$self.$$.dirty & 992) {
        $:
          $$invalidate(4, attributes = {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-hidden": labelled ? void 0 : true,
            role: labelled ? "img" : void 0,
            focusable: tabindex === "0" ? true : focusable,
            tabindex
          });
      }
    };
    $$props = exclude_internal_props($$props);
    return [
      className,
      id,
      title2,
      style,
      attributes,
      tabindex,
      focusable,
      labelled,
      ariaLabelledBy,
      ariaLabel,
      $$scope,
      slots,
      click_handler,
      mouseover_handler,
      mouseenter_handler,
      mouseleave_handler,
      keyup_handler,
      keydown_handler
    ];
  }
  var Menu16 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance36, create_fragment36, safe_not_equal, {
        class: 0,
        id: 1,
        tabindex: 5,
        focusable: 6,
        title: 2,
        style: 3
      });
    }
  };
  var Menu16_default = Menu16;

  // elos-web/node_modules/carbon-icons-svelte/lib/Menu16/index.js
  var Menu16_default2 = Menu16_default;

  // elos-web/node_modules/carbon-icons-svelte/lib/ModelAlt16/ModelAlt16.svelte
  function create_if_block36(ctx) {
    let title_1;
    let t;
    return {
      c() {
        title_1 = svg_element("title");
        t = text(ctx[2]);
      },
      m(target, anchor) {
        insert(target, title_1, anchor);
        append(title_1, t);
      },
      p(ctx2, dirty) {
        if (dirty & 4)
          set_data(t, ctx2[2]);
      },
      d(detaching) {
        if (detaching)
          detach(title_1);
      }
    };
  }
  function fallback_block36(ctx) {
    let if_block_anchor;
    let if_block = ctx[2] && create_if_block36(ctx);
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (ctx2[2]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block36(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach(if_block_anchor);
      }
    };
  }
  function create_fragment37(ctx) {
    let svg;
    let path;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[11].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
    const default_slot_or_fallback = default_slot || fallback_block36(ctx);
    let svg_levels = [
      { "data-carbon-icon": "ModelAlt16" },
      { xmlns: "http://www.w3.org/2000/svg" },
      { viewBox: "0 0 32 32" },
      { fill: "currentColor" },
      { width: "16" },
      { height: "16" },
      { class: ctx[0] },
      { preserveAspectRatio: "xMidYMid meet" },
      { style: ctx[3] },
      { id: ctx[1] },
      ctx[4]
    ];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        if (default_slot_or_fallback)
          default_slot_or_fallback.c();
        attr(path, "d", "M28.4473,16.1055,23,13.3818V7a1,1,0,0,0-.5527-.8945l-6-3a1.0008,1.0008,0,0,0-.8946,0l-6,3A1,1,0,0,0,9,7v6.3818L3.5527,16.1055A1,1,0,0,0,3,17v7a1,1,0,0,0,.5527.8945l6,3a1.001,1.001,0,0,0,.8946,0L16,25.1182l5.5527,2.7763a1.001,1.001,0,0,0,.8946,0l6-3A1,1,0,0,0,29,24V17A1,1,0,0,0,28.4473,16.1055ZM21,13.3818l-4,2V10.6182l4-2ZM16,5.1182,19.7637,7,16,8.8818,12.2363,7Zm-5,3.5,4,2v4.7636l-4-2ZM9,25.3818l-4-2V18.6182l4,2Zm1-6.5L6.2363,17,10,15.1182,13.7637,17Zm1,1.7364,4-2v4.7636l-4,2Zm10,4.7636-4-2V18.6182l4,2Zm1-6.5L18.2363,17,22,15.1182,25.7637,17Zm5,4.5-4,2V20.6182l4-2Z");
        set_svg_attributes(svg, svg_data);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        if (default_slot_or_fallback) {
          default_slot_or_fallback.m(svg, null);
        }
        current = true;
        if (!mounted) {
          dispose = [
            listen(svg, "click", ctx[12]),
            listen(svg, "mouseover", ctx[13]),
            listen(svg, "mouseenter", ctx[14]),
            listen(svg, "mouseleave", ctx[15]),
            listen(svg, "keyup", ctx[16]),
            listen(svg, "keydown", ctx[17])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1024)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
          }
        } else {
          if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
            default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
          }
        }
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
          { "data-carbon-icon": "ModelAlt16" },
          { xmlns: "http://www.w3.org/2000/svg" },
          { viewBox: "0 0 32 32" },
          { fill: "currentColor" },
          { width: "16" },
          { height: "16" },
          (!current || dirty & 1) && { class: ctx2[0] },
          { preserveAspectRatio: "xMidYMid meet" },
          (!current || dirty & 8) && { style: ctx2[3] },
          (!current || dirty & 2) && { id: ctx2[1] },
          dirty & 16 && ctx2[4]
        ]));
      },
      i(local) {
        if (current)
          return;
        transition_in(default_slot_or_fallback, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot_or_fallback, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(svg);
        if (default_slot_or_fallback)
          default_slot_or_fallback.d(detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance37($$self, $$props, $$invalidate) {
    let ariaLabel;
    let ariaLabelledBy;
    let labelled;
    let attributes;
    let { $$slots: slots = {}, $$scope } = $$props;
    let { class: className = void 0 } = $$props;
    let { id = void 0 } = $$props;
    let { tabindex = void 0 } = $$props;
    let { focusable = false } = $$props;
    let { title: title2 = void 0 } = $$props;
    let { style = void 0 } = $$props;
    function click_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseover_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseenter_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseleave_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keyup_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keydown_handler(event) {
      bubble.call(this, $$self, event);
    }
    $$self.$$set = ($$new_props) => {
      $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
      if ("class" in $$new_props)
        $$invalidate(0, className = $$new_props.class);
      if ("id" in $$new_props)
        $$invalidate(1, id = $$new_props.id);
      if ("tabindex" in $$new_props)
        $$invalidate(5, tabindex = $$new_props.tabindex);
      if ("focusable" in $$new_props)
        $$invalidate(6, focusable = $$new_props.focusable);
      if ("title" in $$new_props)
        $$invalidate(2, title2 = $$new_props.title);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("$$scope" in $$new_props)
        $$invalidate(10, $$scope = $$new_props.$$scope);
    };
    $$self.$$.update = () => {
      $:
        $$invalidate(9, ariaLabel = $$props["aria-label"]);
      $:
        $$invalidate(8, ariaLabelledBy = $$props["aria-labelledby"]);
      if ($$self.$$.dirty & 772) {
        $:
          $$invalidate(7, labelled = ariaLabel || ariaLabelledBy || title2);
      }
      if ($$self.$$.dirty & 992) {
        $:
          $$invalidate(4, attributes = {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-hidden": labelled ? void 0 : true,
            role: labelled ? "img" : void 0,
            focusable: tabindex === "0" ? true : focusable,
            tabindex
          });
      }
    };
    $$props = exclude_internal_props($$props);
    return [
      className,
      id,
      title2,
      style,
      attributes,
      tabindex,
      focusable,
      labelled,
      ariaLabelledBy,
      ariaLabel,
      $$scope,
      slots,
      click_handler,
      mouseover_handler,
      mouseenter_handler,
      mouseleave_handler,
      keyup_handler,
      keydown_handler
    ];
  }
  var ModelAlt16 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance37, create_fragment37, safe_not_equal, {
        class: 0,
        id: 1,
        tabindex: 5,
        focusable: 6,
        title: 2,
        style: 3
      });
    }
  };
  var ModelAlt16_default = ModelAlt16;

  // elos-web/node_modules/carbon-icons-svelte/lib/ModelAlt16/index.js
  var ModelAlt16_default2 = ModelAlt16_default;

  // elos-web/node_modules/carbon-icons-svelte/lib/Pdf16/Pdf16.svelte
  function create_if_block37(ctx) {
    let title_1;
    let t;
    return {
      c() {
        title_1 = svg_element("title");
        t = text(ctx[2]);
      },
      m(target, anchor) {
        insert(target, title_1, anchor);
        append(title_1, t);
      },
      p(ctx2, dirty) {
        if (dirty & 4)
          set_data(t, ctx2[2]);
      },
      d(detaching) {
        if (detaching)
          detach(title_1);
      }
    };
  }
  function fallback_block37(ctx) {
    let if_block_anchor;
    let if_block = ctx[2] && create_if_block37(ctx);
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (ctx2[2]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block37(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach(if_block_anchor);
      }
    };
  }
  function create_fragment38(ctx) {
    let svg;
    let path;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[11].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
    const default_slot_or_fallback = default_slot || fallback_block37(ctx);
    let svg_levels = [
      { "data-carbon-icon": "Pdf16" },
      { xmlns: "http://www.w3.org/2000/svg" },
      { viewBox: "0 0 32 32" },
      { fill: "currentColor" },
      { width: "16" },
      { height: "16" },
      { class: ctx[0] },
      { preserveAspectRatio: "xMidYMid meet" },
      { style: ctx[3] },
      { id: ctx[1] },
      ctx[4]
    ];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        if (default_slot_or_fallback)
          default_slot_or_fallback.c();
        attr(path, "d", "M30 11L30 9 22 9 22 23 24 23 24 17 29 17 29 15 24 15 24 11 30 11zM8 9H2V23H4V18H8a2 2 0 002-2V11A2 2 0 008 9zm0 7H4V11H8zM16 23H12V9h4a4 4 0 014 4v6A4 4 0 0116 23zm-2-2h2a2 2 0 002-2V13a2 2 0 00-2-2H14z");
        set_svg_attributes(svg, svg_data);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        if (default_slot_or_fallback) {
          default_slot_or_fallback.m(svg, null);
        }
        current = true;
        if (!mounted) {
          dispose = [
            listen(svg, "click", ctx[12]),
            listen(svg, "mouseover", ctx[13]),
            listen(svg, "mouseenter", ctx[14]),
            listen(svg, "mouseleave", ctx[15]),
            listen(svg, "keyup", ctx[16]),
            listen(svg, "keydown", ctx[17])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1024)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
          }
        } else {
          if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
            default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
          }
        }
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
          { "data-carbon-icon": "Pdf16" },
          { xmlns: "http://www.w3.org/2000/svg" },
          { viewBox: "0 0 32 32" },
          { fill: "currentColor" },
          { width: "16" },
          { height: "16" },
          (!current || dirty & 1) && { class: ctx2[0] },
          { preserveAspectRatio: "xMidYMid meet" },
          (!current || dirty & 8) && { style: ctx2[3] },
          (!current || dirty & 2) && { id: ctx2[1] },
          dirty & 16 && ctx2[4]
        ]));
      },
      i(local) {
        if (current)
          return;
        transition_in(default_slot_or_fallback, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot_or_fallback, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(svg);
        if (default_slot_or_fallback)
          default_slot_or_fallback.d(detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance38($$self, $$props, $$invalidate) {
    let ariaLabel;
    let ariaLabelledBy;
    let labelled;
    let attributes;
    let { $$slots: slots = {}, $$scope } = $$props;
    let { class: className = void 0 } = $$props;
    let { id = void 0 } = $$props;
    let { tabindex = void 0 } = $$props;
    let { focusable = false } = $$props;
    let { title: title2 = void 0 } = $$props;
    let { style = void 0 } = $$props;
    function click_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseover_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseenter_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseleave_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keyup_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keydown_handler(event) {
      bubble.call(this, $$self, event);
    }
    $$self.$$set = ($$new_props) => {
      $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
      if ("class" in $$new_props)
        $$invalidate(0, className = $$new_props.class);
      if ("id" in $$new_props)
        $$invalidate(1, id = $$new_props.id);
      if ("tabindex" in $$new_props)
        $$invalidate(5, tabindex = $$new_props.tabindex);
      if ("focusable" in $$new_props)
        $$invalidate(6, focusable = $$new_props.focusable);
      if ("title" in $$new_props)
        $$invalidate(2, title2 = $$new_props.title);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("$$scope" in $$new_props)
        $$invalidate(10, $$scope = $$new_props.$$scope);
    };
    $$self.$$.update = () => {
      $:
        $$invalidate(9, ariaLabel = $$props["aria-label"]);
      $:
        $$invalidate(8, ariaLabelledBy = $$props["aria-labelledby"]);
      if ($$self.$$.dirty & 772) {
        $:
          $$invalidate(7, labelled = ariaLabel || ariaLabelledBy || title2);
      }
      if ($$self.$$.dirty & 992) {
        $:
          $$invalidate(4, attributes = {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-hidden": labelled ? void 0 : true,
            role: labelled ? "img" : void 0,
            focusable: tabindex === "0" ? true : focusable,
            tabindex
          });
      }
    };
    $$props = exclude_internal_props($$props);
    return [
      className,
      id,
      title2,
      style,
      attributes,
      tabindex,
      focusable,
      labelled,
      ariaLabelledBy,
      ariaLabel,
      $$scope,
      slots,
      click_handler,
      mouseover_handler,
      mouseenter_handler,
      mouseleave_handler,
      keyup_handler,
      keydown_handler
    ];
  }
  var Pdf16 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance38, create_fragment38, safe_not_equal, {
        class: 0,
        id: 1,
        tabindex: 5,
        focusable: 6,
        title: 2,
        style: 3
      });
    }
  };
  var Pdf16_default = Pdf16;

  // elos-web/node_modules/carbon-icons-svelte/lib/Pdf16/index.js
  var Pdf16_default2 = Pdf16_default;

  // elos-web/node_modules/carbon-icons-svelte/lib/Pin16/Pin16.svelte
  function create_if_block38(ctx) {
    let title_1;
    let t;
    return {
      c() {
        title_1 = svg_element("title");
        t = text(ctx[2]);
      },
      m(target, anchor) {
        insert(target, title_1, anchor);
        append(title_1, t);
      },
      p(ctx2, dirty) {
        if (dirty & 4)
          set_data(t, ctx2[2]);
      },
      d(detaching) {
        if (detaching)
          detach(title_1);
      }
    };
  }
  function fallback_block38(ctx) {
    let if_block_anchor;
    let if_block = ctx[2] && create_if_block38(ctx);
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (ctx2[2]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block38(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach(if_block_anchor);
      }
    };
  }
  function create_fragment39(ctx) {
    let svg;
    let path;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[11].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
    const default_slot_or_fallback = default_slot || fallback_block38(ctx);
    let svg_levels = [
      { "data-carbon-icon": "Pin16" },
      { xmlns: "http://www.w3.org/2000/svg" },
      { viewBox: "0 0 32 32" },
      { fill: "currentColor" },
      { width: "16" },
      { height: "16" },
      { class: ctx[0] },
      { preserveAspectRatio: "xMidYMid meet" },
      { style: ctx[3] },
      { id: ctx[1] },
      ctx[4]
    ];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        if (default_slot_or_fallback)
          default_slot_or_fallback.c();
        attr(path, "d", "M28.59,13.31,30,11.9,20,2,18.69,3.42,19.87,4.6,8.38,14.32,6.66,12.61,5.25,14l5.66,5.68L2,28.58,3.41,30l8.91-8.91L18,26.75l1.39-1.42-1.71-1.71L27.4,12.13ZM16.26,22.2,9.8,15.74,21.29,6,26,10.71Z");
        set_svg_attributes(svg, svg_data);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        if (default_slot_or_fallback) {
          default_slot_or_fallback.m(svg, null);
        }
        current = true;
        if (!mounted) {
          dispose = [
            listen(svg, "click", ctx[12]),
            listen(svg, "mouseover", ctx[13]),
            listen(svg, "mouseenter", ctx[14]),
            listen(svg, "mouseleave", ctx[15]),
            listen(svg, "keyup", ctx[16]),
            listen(svg, "keydown", ctx[17])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1024)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
          }
        } else {
          if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
            default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
          }
        }
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
          { "data-carbon-icon": "Pin16" },
          { xmlns: "http://www.w3.org/2000/svg" },
          { viewBox: "0 0 32 32" },
          { fill: "currentColor" },
          { width: "16" },
          { height: "16" },
          (!current || dirty & 1) && { class: ctx2[0] },
          { preserveAspectRatio: "xMidYMid meet" },
          (!current || dirty & 8) && { style: ctx2[3] },
          (!current || dirty & 2) && { id: ctx2[1] },
          dirty & 16 && ctx2[4]
        ]));
      },
      i(local) {
        if (current)
          return;
        transition_in(default_slot_or_fallback, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot_or_fallback, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(svg);
        if (default_slot_or_fallback)
          default_slot_or_fallback.d(detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance39($$self, $$props, $$invalidate) {
    let ariaLabel;
    let ariaLabelledBy;
    let labelled;
    let attributes;
    let { $$slots: slots = {}, $$scope } = $$props;
    let { class: className = void 0 } = $$props;
    let { id = void 0 } = $$props;
    let { tabindex = void 0 } = $$props;
    let { focusable = false } = $$props;
    let { title: title2 = void 0 } = $$props;
    let { style = void 0 } = $$props;
    function click_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseover_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseenter_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseleave_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keyup_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keydown_handler(event) {
      bubble.call(this, $$self, event);
    }
    $$self.$$set = ($$new_props) => {
      $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
      if ("class" in $$new_props)
        $$invalidate(0, className = $$new_props.class);
      if ("id" in $$new_props)
        $$invalidate(1, id = $$new_props.id);
      if ("tabindex" in $$new_props)
        $$invalidate(5, tabindex = $$new_props.tabindex);
      if ("focusable" in $$new_props)
        $$invalidate(6, focusable = $$new_props.focusable);
      if ("title" in $$new_props)
        $$invalidate(2, title2 = $$new_props.title);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("$$scope" in $$new_props)
        $$invalidate(10, $$scope = $$new_props.$$scope);
    };
    $$self.$$.update = () => {
      $:
        $$invalidate(9, ariaLabel = $$props["aria-label"]);
      $:
        $$invalidate(8, ariaLabelledBy = $$props["aria-labelledby"]);
      if ($$self.$$.dirty & 772) {
        $:
          $$invalidate(7, labelled = ariaLabel || ariaLabelledBy || title2);
      }
      if ($$self.$$.dirty & 992) {
        $:
          $$invalidate(4, attributes = {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-hidden": labelled ? void 0 : true,
            role: labelled ? "img" : void 0,
            focusable: tabindex === "0" ? true : focusable,
            tabindex
          });
      }
    };
    $$props = exclude_internal_props($$props);
    return [
      className,
      id,
      title2,
      style,
      attributes,
      tabindex,
      focusable,
      labelled,
      ariaLabelledBy,
      ariaLabel,
      $$scope,
      slots,
      click_handler,
      mouseover_handler,
      mouseenter_handler,
      mouseleave_handler,
      keyup_handler,
      keydown_handler
    ];
  }
  var Pin16 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance39, create_fragment39, safe_not_equal, {
        class: 0,
        id: 1,
        tabindex: 5,
        focusable: 6,
        title: 2,
        style: 3
      });
    }
  };
  var Pin16_default = Pin16;

  // elos-web/node_modules/carbon-icons-svelte/lib/Pin16/index.js
  var Pin16_default2 = Pin16_default;

  // elos-web/node_modules/carbon-icons-svelte/lib/Settings16/Settings16.svelte
  function create_if_block39(ctx) {
    let title_1;
    let t;
    return {
      c() {
        title_1 = svg_element("title");
        t = text(ctx[2]);
      },
      m(target, anchor) {
        insert(target, title_1, anchor);
        append(title_1, t);
      },
      p(ctx2, dirty) {
        if (dirty & 4)
          set_data(t, ctx2[2]);
      },
      d(detaching) {
        if (detaching)
          detach(title_1);
      }
    };
  }
  function fallback_block39(ctx) {
    let if_block_anchor;
    let if_block = ctx[2] && create_if_block39(ctx);
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (ctx2[2]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block39(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach(if_block_anchor);
      }
    };
  }
  function create_fragment40(ctx) {
    let svg;
    let path0;
    let path1;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[11].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
    const default_slot_or_fallback = default_slot || fallback_block39(ctx);
    let svg_levels = [
      { "data-carbon-icon": "Settings16" },
      { xmlns: "http://www.w3.org/2000/svg" },
      { viewBox: "0 0 16 16" },
      { fill: "currentColor" },
      { width: "16" },
      { height: "16" },
      { class: ctx[0] },
      { preserveAspectRatio: "xMidYMid meet" },
      { style: ctx[3] },
      { id: ctx[1] },
      ctx[4]
    ];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    return {
      c() {
        svg = svg_element("svg");
        path0 = svg_element("path");
        path1 = svg_element("path");
        if (default_slot_or_fallback)
          default_slot_or_fallback.c();
        attr(path0, "d", "M13.5,8.4c0-0.1,0-0.3,0-0.4c0-0.1,0-0.3,0-0.4l1-0.8c0.4-0.3,0.4-0.9,0.2-1.3l-1.2-2C13.3,3.2,13,3,12.6,3	c-0.1,0-0.2,0-0.3,0.1l-1.2,0.4c-0.2-0.1-0.4-0.3-0.7-0.4l-0.3-1.3C10.1,1.3,9.7,1,9.2,1H6.8c-0.5,0-0.9,0.3-1,0.8L5.6,3.1	C5.3,3.2,5.1,3.3,4.9,3.4L3.7,3C3.6,3,3.5,3,3.4,3C3,3,2.7,3.2,2.5,3.5l-1.2,2C1.1,5.9,1.2,6.4,1.6,6.8l0.9,0.9c0,0.1,0,0.3,0,0.4	c0,0.1,0,0.3,0,0.4L1.6,9.2c-0.4,0.3-0.5,0.9-0.2,1.3l1.2,2C2.7,12.8,3,13,3.4,13c0.1,0,0.2,0,0.3-0.1l1.2-0.4	c0.2,0.1,0.4,0.3,0.7,0.4l0.3,1.3c0.1,0.5,0.5,0.8,1,0.8h2.4c0.5,0,0.9-0.3,1-0.8l0.3-1.3c0.2-0.1,0.4-0.2,0.7-0.4l1.2,0.4	c0.1,0,0.2,0.1,0.3,0.1c0.4,0,0.7-0.2,0.9-0.5l1.1-2c0.2-0.4,0.2-0.9-0.2-1.3L13.5,8.4z M12.6,12l-1.7-0.6c-0.4,0.3-0.9,0.6-1.4,0.8	L9.2,14H6.8l-0.4-1.8c-0.5-0.2-0.9-0.5-1.4-0.8L3.4,12l-1.2-2l1.4-1.2c-0.1-0.5-0.1-1.1,0-1.6L2.2,6l1.2-2l1.7,0.6	C5.5,4.2,6,4,6.5,3.8L6.8,2h2.4l0.4,1.8c0.5,0.2,0.9,0.5,1.4,0.8L12.6,4l1.2,2l-1.4,1.2c0.1,0.5,0.1,1.1,0,1.6l1.4,1.2L12.6,12z");
        attr(path1, "d", "M8,11c-1.7,0-3-1.3-3-3s1.3-3,3-3s3,1.3,3,3C11,9.6,9.7,11,8,11C8,11,8,11,8,11z M8,6C6.9,6,6,6.8,6,7.9C6,7.9,6,8,6,8	c0,1.1,0.8,2,1.9,2c0,0,0.1,0,0.1,0c1.1,0,2-0.8,2-1.9c0,0,0-0.1,0-0.1C10,6.9,9.2,6,8,6C8.1,6,8,6,8,6z");
        set_svg_attributes(svg, svg_data);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path0);
        append(svg, path1);
        if (default_slot_or_fallback) {
          default_slot_or_fallback.m(svg, null);
        }
        current = true;
        if (!mounted) {
          dispose = [
            listen(svg, "click", ctx[12]),
            listen(svg, "mouseover", ctx[13]),
            listen(svg, "mouseenter", ctx[14]),
            listen(svg, "mouseleave", ctx[15]),
            listen(svg, "keyup", ctx[16]),
            listen(svg, "keydown", ctx[17])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1024)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
          }
        } else {
          if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
            default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
          }
        }
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
          { "data-carbon-icon": "Settings16" },
          { xmlns: "http://www.w3.org/2000/svg" },
          { viewBox: "0 0 16 16" },
          { fill: "currentColor" },
          { width: "16" },
          { height: "16" },
          (!current || dirty & 1) && { class: ctx2[0] },
          { preserveAspectRatio: "xMidYMid meet" },
          (!current || dirty & 8) && { style: ctx2[3] },
          (!current || dirty & 2) && { id: ctx2[1] },
          dirty & 16 && ctx2[4]
        ]));
      },
      i(local) {
        if (current)
          return;
        transition_in(default_slot_or_fallback, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot_or_fallback, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(svg);
        if (default_slot_or_fallback)
          default_slot_or_fallback.d(detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance40($$self, $$props, $$invalidate) {
    let ariaLabel;
    let ariaLabelledBy;
    let labelled;
    let attributes;
    let { $$slots: slots = {}, $$scope } = $$props;
    let { class: className = void 0 } = $$props;
    let { id = void 0 } = $$props;
    let { tabindex = void 0 } = $$props;
    let { focusable = false } = $$props;
    let { title: title2 = void 0 } = $$props;
    let { style = void 0 } = $$props;
    function click_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseover_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseenter_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseleave_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keyup_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keydown_handler(event) {
      bubble.call(this, $$self, event);
    }
    $$self.$$set = ($$new_props) => {
      $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
      if ("class" in $$new_props)
        $$invalidate(0, className = $$new_props.class);
      if ("id" in $$new_props)
        $$invalidate(1, id = $$new_props.id);
      if ("tabindex" in $$new_props)
        $$invalidate(5, tabindex = $$new_props.tabindex);
      if ("focusable" in $$new_props)
        $$invalidate(6, focusable = $$new_props.focusable);
      if ("title" in $$new_props)
        $$invalidate(2, title2 = $$new_props.title);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("$$scope" in $$new_props)
        $$invalidate(10, $$scope = $$new_props.$$scope);
    };
    $$self.$$.update = () => {
      $:
        $$invalidate(9, ariaLabel = $$props["aria-label"]);
      $:
        $$invalidate(8, ariaLabelledBy = $$props["aria-labelledby"]);
      if ($$self.$$.dirty & 772) {
        $:
          $$invalidate(7, labelled = ariaLabel || ariaLabelledBy || title2);
      }
      if ($$self.$$.dirty & 992) {
        $:
          $$invalidate(4, attributes = {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-hidden": labelled ? void 0 : true,
            role: labelled ? "img" : void 0,
            focusable: tabindex === "0" ? true : focusable,
            tabindex
          });
      }
    };
    $$props = exclude_internal_props($$props);
    return [
      className,
      id,
      title2,
      style,
      attributes,
      tabindex,
      focusable,
      labelled,
      ariaLabelledBy,
      ariaLabel,
      $$scope,
      slots,
      click_handler,
      mouseover_handler,
      mouseenter_handler,
      mouseleave_handler,
      keyup_handler,
      keydown_handler
    ];
  }
  var Settings16 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance40, create_fragment40, safe_not_equal, {
        class: 0,
        id: 1,
        tabindex: 5,
        focusable: 6,
        title: 2,
        style: 3
      });
    }
  };
  var Settings16_default = Settings16;

  // elos-web/node_modules/carbon-icons-svelte/lib/Settings16/index.js
  var Settings16_default2 = Settings16_default;

  // elos-web/node_modules/carbon-icons-svelte/lib/Switcher16/Switcher16.svelte
  function create_if_block40(ctx) {
    let title_1;
    let t;
    return {
      c() {
        title_1 = svg_element("title");
        t = text(ctx[2]);
      },
      m(target, anchor) {
        insert(target, title_1, anchor);
        append(title_1, t);
      },
      p(ctx2, dirty) {
        if (dirty & 4)
          set_data(t, ctx2[2]);
      },
      d(detaching) {
        if (detaching)
          detach(title_1);
      }
    };
  }
  function fallback_block40(ctx) {
    let if_block_anchor;
    let if_block = ctx[2] && create_if_block40(ctx);
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (ctx2[2]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block40(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach(if_block_anchor);
      }
    };
  }
  function create_fragment41(ctx) {
    let svg;
    let path;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[11].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
    const default_slot_or_fallback = default_slot || fallback_block40(ctx);
    let svg_levels = [
      { "data-carbon-icon": "Switcher16" },
      { xmlns: "http://www.w3.org/2000/svg" },
      { viewBox: "0 0 32 32" },
      { fill: "currentColor" },
      { width: "16" },
      { height: "16" },
      { class: ctx[0] },
      { preserveAspectRatio: "xMidYMid meet" },
      { style: ctx[3] },
      { id: ctx[1] },
      ctx[4]
    ];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        if (default_slot_or_fallback)
          default_slot_or_fallback.c();
        attr(path, "d", "M14 4H18V8H14zM4 4H8V8H4zM24 4H28V8H24zM14 14H18V18H14zM4 14H8V18H4zM24 14H28V18H24zM14 24H18V28H14zM4 24H8V28H4zM24 24H28V28H24z");
        set_svg_attributes(svg, svg_data);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        if (default_slot_or_fallback) {
          default_slot_or_fallback.m(svg, null);
        }
        current = true;
        if (!mounted) {
          dispose = [
            listen(svg, "click", ctx[12]),
            listen(svg, "mouseover", ctx[13]),
            listen(svg, "mouseenter", ctx[14]),
            listen(svg, "mouseleave", ctx[15]),
            listen(svg, "keyup", ctx[16]),
            listen(svg, "keydown", ctx[17])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1024)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
          }
        } else {
          if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
            default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
          }
        }
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
          { "data-carbon-icon": "Switcher16" },
          { xmlns: "http://www.w3.org/2000/svg" },
          { viewBox: "0 0 32 32" },
          { fill: "currentColor" },
          { width: "16" },
          { height: "16" },
          (!current || dirty & 1) && { class: ctx2[0] },
          { preserveAspectRatio: "xMidYMid meet" },
          (!current || dirty & 8) && { style: ctx2[3] },
          (!current || dirty & 2) && { id: ctx2[1] },
          dirty & 16 && ctx2[4]
        ]));
      },
      i(local) {
        if (current)
          return;
        transition_in(default_slot_or_fallback, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot_or_fallback, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(svg);
        if (default_slot_or_fallback)
          default_slot_or_fallback.d(detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance41($$self, $$props, $$invalidate) {
    let ariaLabel;
    let ariaLabelledBy;
    let labelled;
    let attributes;
    let { $$slots: slots = {}, $$scope } = $$props;
    let { class: className = void 0 } = $$props;
    let { id = void 0 } = $$props;
    let { tabindex = void 0 } = $$props;
    let { focusable = false } = $$props;
    let { title: title2 = void 0 } = $$props;
    let { style = void 0 } = $$props;
    function click_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseover_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseenter_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseleave_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keyup_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keydown_handler(event) {
      bubble.call(this, $$self, event);
    }
    $$self.$$set = ($$new_props) => {
      $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
      if ("class" in $$new_props)
        $$invalidate(0, className = $$new_props.class);
      if ("id" in $$new_props)
        $$invalidate(1, id = $$new_props.id);
      if ("tabindex" in $$new_props)
        $$invalidate(5, tabindex = $$new_props.tabindex);
      if ("focusable" in $$new_props)
        $$invalidate(6, focusable = $$new_props.focusable);
      if ("title" in $$new_props)
        $$invalidate(2, title2 = $$new_props.title);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("$$scope" in $$new_props)
        $$invalidate(10, $$scope = $$new_props.$$scope);
    };
    $$self.$$.update = () => {
      $:
        $$invalidate(9, ariaLabel = $$props["aria-label"]);
      $:
        $$invalidate(8, ariaLabelledBy = $$props["aria-labelledby"]);
      if ($$self.$$.dirty & 772) {
        $:
          $$invalidate(7, labelled = ariaLabel || ariaLabelledBy || title2);
      }
      if ($$self.$$.dirty & 992) {
        $:
          $$invalidate(4, attributes = {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-hidden": labelled ? void 0 : true,
            role: labelled ? "img" : void 0,
            focusable: tabindex === "0" ? true : focusable,
            tabindex
          });
      }
    };
    $$props = exclude_internal_props($$props);
    return [
      className,
      id,
      title2,
      style,
      attributes,
      tabindex,
      focusable,
      labelled,
      ariaLabelledBy,
      ariaLabel,
      $$scope,
      slots,
      click_handler,
      mouseover_handler,
      mouseenter_handler,
      mouseleave_handler,
      keyup_handler,
      keydown_handler
    ];
  }
  var Switcher16 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance41, create_fragment41, safe_not_equal, {
        class: 0,
        id: 1,
        tabindex: 5,
        focusable: 6,
        title: 2,
        style: 3
      });
    }
  };
  var Switcher16_default = Switcher16;

  // elos-web/node_modules/carbon-icons-svelte/lib/Switcher16/index.js
  var Switcher16_default2 = Switcher16_default;

  // elos-web/node_modules/carbon-icons-svelte/lib/Sql16/Sql16.svelte
  function create_if_block41(ctx) {
    let title_1;
    let t;
    return {
      c() {
        title_1 = svg_element("title");
        t = text(ctx[2]);
      },
      m(target, anchor) {
        insert(target, title_1, anchor);
        append(title_1, t);
      },
      p(ctx2, dirty) {
        if (dirty & 4)
          set_data(t, ctx2[2]);
      },
      d(detaching) {
        if (detaching)
          detach(title_1);
      }
    };
  }
  function fallback_block41(ctx) {
    let if_block_anchor;
    let if_block = ctx[2] && create_if_block41(ctx);
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (ctx2[2]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block41(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach(if_block_anchor);
      }
    };
  }
  function create_fragment42(ctx) {
    let svg;
    let path;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[11].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
    const default_slot_or_fallback = default_slot || fallback_block41(ctx);
    let svg_levels = [
      { "data-carbon-icon": "Sql16" },
      { xmlns: "http://www.w3.org/2000/svg" },
      { viewBox: "0 0 32 32" },
      { fill: "currentColor" },
      { width: "16" },
      { height: "16" },
      { class: ctx[0] },
      { preserveAspectRatio: "xMidYMid meet" },
      { style: ctx[3] },
      { id: ctx[1] },
      ctx[4]
    ];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        if (default_slot_or_fallback)
          default_slot_or_fallback.c();
        attr(path, "d", "M24 21L24 9 22 9 22 23 30 23 30 21 24 21zM18 9H14a2 2 0 00-2 2V21a2 2 0 002 2h1v2a2 2 0 002 2h2V25H17V23h1a2 2 0 002-2V11A2 2 0 0018 9zM14 21V11h4V21zM8 23H2V21H8V17H4a2 2 0 01-2-2V11A2 2 0 014 9h6v2H4v4H8a2 2 0 012 2v4A2 2 0 018 23z");
        set_svg_attributes(svg, svg_data);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        if (default_slot_or_fallback) {
          default_slot_or_fallback.m(svg, null);
        }
        current = true;
        if (!mounted) {
          dispose = [
            listen(svg, "click", ctx[12]),
            listen(svg, "mouseover", ctx[13]),
            listen(svg, "mouseenter", ctx[14]),
            listen(svg, "mouseleave", ctx[15]),
            listen(svg, "keyup", ctx[16]),
            listen(svg, "keydown", ctx[17])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1024)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
          }
        } else {
          if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
            default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
          }
        }
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
          { "data-carbon-icon": "Sql16" },
          { xmlns: "http://www.w3.org/2000/svg" },
          { viewBox: "0 0 32 32" },
          { fill: "currentColor" },
          { width: "16" },
          { height: "16" },
          (!current || dirty & 1) && { class: ctx2[0] },
          { preserveAspectRatio: "xMidYMid meet" },
          (!current || dirty & 8) && { style: ctx2[3] },
          (!current || dirty & 2) && { id: ctx2[1] },
          dirty & 16 && ctx2[4]
        ]));
      },
      i(local) {
        if (current)
          return;
        transition_in(default_slot_or_fallback, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot_or_fallback, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(svg);
        if (default_slot_or_fallback)
          default_slot_or_fallback.d(detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance42($$self, $$props, $$invalidate) {
    let ariaLabel;
    let ariaLabelledBy;
    let labelled;
    let attributes;
    let { $$slots: slots = {}, $$scope } = $$props;
    let { class: className = void 0 } = $$props;
    let { id = void 0 } = $$props;
    let { tabindex = void 0 } = $$props;
    let { focusable = false } = $$props;
    let { title: title2 = void 0 } = $$props;
    let { style = void 0 } = $$props;
    function click_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseover_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseenter_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseleave_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keyup_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keydown_handler(event) {
      bubble.call(this, $$self, event);
    }
    $$self.$$set = ($$new_props) => {
      $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
      if ("class" in $$new_props)
        $$invalidate(0, className = $$new_props.class);
      if ("id" in $$new_props)
        $$invalidate(1, id = $$new_props.id);
      if ("tabindex" in $$new_props)
        $$invalidate(5, tabindex = $$new_props.tabindex);
      if ("focusable" in $$new_props)
        $$invalidate(6, focusable = $$new_props.focusable);
      if ("title" in $$new_props)
        $$invalidate(2, title2 = $$new_props.title);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("$$scope" in $$new_props)
        $$invalidate(10, $$scope = $$new_props.$$scope);
    };
    $$self.$$.update = () => {
      $:
        $$invalidate(9, ariaLabel = $$props["aria-label"]);
      $:
        $$invalidate(8, ariaLabelledBy = $$props["aria-labelledby"]);
      if ($$self.$$.dirty & 772) {
        $:
          $$invalidate(7, labelled = ariaLabel || ariaLabelledBy || title2);
      }
      if ($$self.$$.dirty & 992) {
        $:
          $$invalidate(4, attributes = {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-hidden": labelled ? void 0 : true,
            role: labelled ? "img" : void 0,
            focusable: tabindex === "0" ? true : focusable,
            tabindex
          });
      }
    };
    $$props = exclude_internal_props($$props);
    return [
      className,
      id,
      title2,
      style,
      attributes,
      tabindex,
      focusable,
      labelled,
      ariaLabelledBy,
      ariaLabel,
      $$scope,
      slots,
      click_handler,
      mouseover_handler,
      mouseenter_handler,
      mouseleave_handler,
      keyup_handler,
      keydown_handler
    ];
  }
  var Sql16 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance42, create_fragment42, safe_not_equal, {
        class: 0,
        id: 1,
        tabindex: 5,
        focusable: 6,
        title: 2,
        style: 3
      });
    }
  };
  var Sql16_default = Sql16;

  // elos-web/node_modules/carbon-icons-svelte/lib/Sql16/index.js
  var Sql16_default2 = Sql16_default;

  // elos-web/node_modules/carbon-icons-svelte/lib/Terminal16/Terminal16.svelte
  function create_if_block42(ctx) {
    let title_1;
    let t;
    return {
      c() {
        title_1 = svg_element("title");
        t = text(ctx[2]);
      },
      m(target, anchor) {
        insert(target, title_1, anchor);
        append(title_1, t);
      },
      p(ctx2, dirty) {
        if (dirty & 4)
          set_data(t, ctx2[2]);
      },
      d(detaching) {
        if (detaching)
          detach(title_1);
      }
    };
  }
  function fallback_block42(ctx) {
    let if_block_anchor;
    let if_block = ctx[2] && create_if_block42(ctx);
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (ctx2[2]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block42(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach(if_block_anchor);
      }
    };
  }
  function create_fragment43(ctx) {
    let svg;
    let path0;
    let path1;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[11].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
    const default_slot_or_fallback = default_slot || fallback_block42(ctx);
    let svg_levels = [
      { "data-carbon-icon": "Terminal16" },
      { xmlns: "http://www.w3.org/2000/svg" },
      { viewBox: "0 0 32 32" },
      { fill: "currentColor" },
      { width: "16" },
      { height: "16" },
      { class: ctx[0] },
      { preserveAspectRatio: "xMidYMid meet" },
      { style: ctx[3] },
      { id: ctx[1] },
      ctx[4]
    ];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    return {
      c() {
        svg = svg_element("svg");
        path0 = svg_element("path");
        path1 = svg_element("path");
        if (default_slot_or_fallback)
          default_slot_or_fallback.c();
        attr(path0, "d", "M26,4H6A2,2,0,0,0,4,6V26a2,2,0,0,0,2,2H26a2,2,0,0,0,2-2V6A2,2,0,0,0,26,4Zm0,2v4H6V6ZM6,26V12H26V26Z");
        attr(path0, "transform", "translate(0 .01)");
        attr(path1, "d", "M10.76 16.18L13.58 19.01 10.76 21.84 12.17 23.25 16.41 19.01 12.17 14.77 10.76 16.18z");
        set_svg_attributes(svg, svg_data);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path0);
        append(svg, path1);
        if (default_slot_or_fallback) {
          default_slot_or_fallback.m(svg, null);
        }
        current = true;
        if (!mounted) {
          dispose = [
            listen(svg, "click", ctx[12]),
            listen(svg, "mouseover", ctx[13]),
            listen(svg, "mouseenter", ctx[14]),
            listen(svg, "mouseleave", ctx[15]),
            listen(svg, "keyup", ctx[16]),
            listen(svg, "keydown", ctx[17])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1024)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
          }
        } else {
          if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
            default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
          }
        }
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
          { "data-carbon-icon": "Terminal16" },
          { xmlns: "http://www.w3.org/2000/svg" },
          { viewBox: "0 0 32 32" },
          { fill: "currentColor" },
          { width: "16" },
          { height: "16" },
          (!current || dirty & 1) && { class: ctx2[0] },
          { preserveAspectRatio: "xMidYMid meet" },
          (!current || dirty & 8) && { style: ctx2[3] },
          (!current || dirty & 2) && { id: ctx2[1] },
          dirty & 16 && ctx2[4]
        ]));
      },
      i(local) {
        if (current)
          return;
        transition_in(default_slot_or_fallback, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot_or_fallback, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(svg);
        if (default_slot_or_fallback)
          default_slot_or_fallback.d(detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance43($$self, $$props, $$invalidate) {
    let ariaLabel;
    let ariaLabelledBy;
    let labelled;
    let attributes;
    let { $$slots: slots = {}, $$scope } = $$props;
    let { class: className = void 0 } = $$props;
    let { id = void 0 } = $$props;
    let { tabindex = void 0 } = $$props;
    let { focusable = false } = $$props;
    let { title: title2 = void 0 } = $$props;
    let { style = void 0 } = $$props;
    function click_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseover_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseenter_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseleave_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keyup_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keydown_handler(event) {
      bubble.call(this, $$self, event);
    }
    $$self.$$set = ($$new_props) => {
      $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
      if ("class" in $$new_props)
        $$invalidate(0, className = $$new_props.class);
      if ("id" in $$new_props)
        $$invalidate(1, id = $$new_props.id);
      if ("tabindex" in $$new_props)
        $$invalidate(5, tabindex = $$new_props.tabindex);
      if ("focusable" in $$new_props)
        $$invalidate(6, focusable = $$new_props.focusable);
      if ("title" in $$new_props)
        $$invalidate(2, title2 = $$new_props.title);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("$$scope" in $$new_props)
        $$invalidate(10, $$scope = $$new_props.$$scope);
    };
    $$self.$$.update = () => {
      $:
        $$invalidate(9, ariaLabel = $$props["aria-label"]);
      $:
        $$invalidate(8, ariaLabelledBy = $$props["aria-labelledby"]);
      if ($$self.$$.dirty & 772) {
        $:
          $$invalidate(7, labelled = ariaLabel || ariaLabelledBy || title2);
      }
      if ($$self.$$.dirty & 992) {
        $:
          $$invalidate(4, attributes = {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-hidden": labelled ? void 0 : true,
            role: labelled ? "img" : void 0,
            focusable: tabindex === "0" ? true : focusable,
            tabindex
          });
      }
    };
    $$props = exclude_internal_props($$props);
    return [
      className,
      id,
      title2,
      style,
      attributes,
      tabindex,
      focusable,
      labelled,
      ariaLabelledBy,
      ariaLabel,
      $$scope,
      slots,
      click_handler,
      mouseover_handler,
      mouseenter_handler,
      mouseleave_handler,
      keyup_handler,
      keydown_handler
    ];
  }
  var Terminal16 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance43, create_fragment43, safe_not_equal, {
        class: 0,
        id: 1,
        tabindex: 5,
        focusable: 6,
        title: 2,
        style: 3
      });
    }
  };
  var Terminal16_default = Terminal16;

  // elos-web/node_modules/carbon-icons-svelte/lib/Terminal16/index.js
  var Terminal16_default2 = Terminal16_default;

  // elos-web/node_modules/carbon-icons-svelte/lib/ToolsAlt16/ToolsAlt16.svelte
  function create_if_block43(ctx) {
    let title_1;
    let t;
    return {
      c() {
        title_1 = svg_element("title");
        t = text(ctx[2]);
      },
      m(target, anchor) {
        insert(target, title_1, anchor);
        append(title_1, t);
      },
      p(ctx2, dirty) {
        if (dirty & 4)
          set_data(t, ctx2[2]);
      },
      d(detaching) {
        if (detaching)
          detach(title_1);
      }
    };
  }
  function fallback_block43(ctx) {
    let if_block_anchor;
    let if_block = ctx[2] && create_if_block43(ctx);
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (ctx2[2]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block43(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach(if_block_anchor);
      }
    };
  }
  function create_fragment44(ctx) {
    let svg;
    let path;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[11].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
    const default_slot_or_fallback = default_slot || fallback_block43(ctx);
    let svg_levels = [
      { "data-carbon-icon": "ToolsAlt16" },
      { xmlns: "http://www.w3.org/2000/svg" },
      { viewBox: "0 0 32 32" },
      { fill: "currentColor" },
      { width: "16" },
      { height: "16" },
      { class: ctx[0] },
      { preserveAspectRatio: "xMidYMid meet" },
      { style: ctx[3] },
      { id: ctx[1] },
      ctx[4]
    ];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        if (default_slot_or_fallback)
          default_slot_or_fallback.c();
        attr(path, "d", "M29.4148,21.6664,23.08,15.3305l6.3337-6.334a2,2,0,0,0,.0017-2.8281l-.0017-.002-3.58-3.58a2,2,0,0,0-2.8284-.0015l-.0017.0015L16.67,8.9194,10.3352,2.5839a2.0037,2.0037,0,0,0-2.8281.0005L2.5854,7.5063a2.0011,2.0011,0,0,0,0,2.8286l6.3338,6.3345L2,23.5883V30H8.4106l6.919-6.9194,6.3354,6.3364a2.0076,2.0076,0,0,0,2.8291,0l4.9207-4.9223A2.0011,2.0011,0,0,0,29.4148,21.6664Zm-5.0015-17.67,3.59,3.59L21.67,13.92l-3.59-3.59ZM8,28H4V24.4086L10.3291,18.08l3.677,3.6778Zm15.08.0035L4,8.9213,8.9219,4,12.71,7.7875,10.458,10.04l1.4153,1.4141,2.2507-2.252,4.1294,4.1294L16,15.5834l1.416,1.4141,2.2517-2.252,4.13,4.13-2.2517,2.251,1.4141,1.415L25.2117,20.29l2.7907,2.791Z");
        set_svg_attributes(svg, svg_data);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        if (default_slot_or_fallback) {
          default_slot_or_fallback.m(svg, null);
        }
        current = true;
        if (!mounted) {
          dispose = [
            listen(svg, "click", ctx[12]),
            listen(svg, "mouseover", ctx[13]),
            listen(svg, "mouseenter", ctx[14]),
            listen(svg, "mouseleave", ctx[15]),
            listen(svg, "keyup", ctx[16]),
            listen(svg, "keydown", ctx[17])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1024)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
          }
        } else {
          if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
            default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
          }
        }
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
          { "data-carbon-icon": "ToolsAlt16" },
          { xmlns: "http://www.w3.org/2000/svg" },
          { viewBox: "0 0 32 32" },
          { fill: "currentColor" },
          { width: "16" },
          { height: "16" },
          (!current || dirty & 1) && { class: ctx2[0] },
          { preserveAspectRatio: "xMidYMid meet" },
          (!current || dirty & 8) && { style: ctx2[3] },
          (!current || dirty & 2) && { id: ctx2[1] },
          dirty & 16 && ctx2[4]
        ]));
      },
      i(local) {
        if (current)
          return;
        transition_in(default_slot_or_fallback, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot_or_fallback, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(svg);
        if (default_slot_or_fallback)
          default_slot_or_fallback.d(detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance44($$self, $$props, $$invalidate) {
    let ariaLabel;
    let ariaLabelledBy;
    let labelled;
    let attributes;
    let { $$slots: slots = {}, $$scope } = $$props;
    let { class: className = void 0 } = $$props;
    let { id = void 0 } = $$props;
    let { tabindex = void 0 } = $$props;
    let { focusable = false } = $$props;
    let { title: title2 = void 0 } = $$props;
    let { style = void 0 } = $$props;
    function click_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseover_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseenter_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseleave_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keyup_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keydown_handler(event) {
      bubble.call(this, $$self, event);
    }
    $$self.$$set = ($$new_props) => {
      $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
      if ("class" in $$new_props)
        $$invalidate(0, className = $$new_props.class);
      if ("id" in $$new_props)
        $$invalidate(1, id = $$new_props.id);
      if ("tabindex" in $$new_props)
        $$invalidate(5, tabindex = $$new_props.tabindex);
      if ("focusable" in $$new_props)
        $$invalidate(6, focusable = $$new_props.focusable);
      if ("title" in $$new_props)
        $$invalidate(2, title2 = $$new_props.title);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("$$scope" in $$new_props)
        $$invalidate(10, $$scope = $$new_props.$$scope);
    };
    $$self.$$.update = () => {
      $:
        $$invalidate(9, ariaLabel = $$props["aria-label"]);
      $:
        $$invalidate(8, ariaLabelledBy = $$props["aria-labelledby"]);
      if ($$self.$$.dirty & 772) {
        $:
          $$invalidate(7, labelled = ariaLabel || ariaLabelledBy || title2);
      }
      if ($$self.$$.dirty & 992) {
        $:
          $$invalidate(4, attributes = {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-hidden": labelled ? void 0 : true,
            role: labelled ? "img" : void 0,
            focusable: tabindex === "0" ? true : focusable,
            tabindex
          });
      }
    };
    $$props = exclude_internal_props($$props);
    return [
      className,
      id,
      title2,
      style,
      attributes,
      tabindex,
      focusable,
      labelled,
      ariaLabelledBy,
      ariaLabel,
      $$scope,
      slots,
      click_handler,
      mouseover_handler,
      mouseenter_handler,
      mouseleave_handler,
      keyup_handler,
      keydown_handler
    ];
  }
  var ToolsAlt16 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance44, create_fragment44, safe_not_equal, {
        class: 0,
        id: 1,
        tabindex: 5,
        focusable: 6,
        title: 2,
        style: 3
      });
    }
  };
  var ToolsAlt16_default = ToolsAlt16;

  // elos-web/node_modules/carbon-icons-svelte/lib/ToolsAlt16/index.js
  var ToolsAlt16_default2 = ToolsAlt16_default;

  // elos-web/node_modules/carbon-icons-svelte/lib/Txt16/Txt16.svelte
  function create_if_block44(ctx) {
    let title_1;
    let t;
    return {
      c() {
        title_1 = svg_element("title");
        t = text(ctx[2]);
      },
      m(target, anchor) {
        insert(target, title_1, anchor);
        append(title_1, t);
      },
      p(ctx2, dirty) {
        if (dirty & 4)
          set_data(t, ctx2[2]);
      },
      d(detaching) {
        if (detaching)
          detach(title_1);
      }
    };
  }
  function fallback_block44(ctx) {
    let if_block_anchor;
    let if_block = ctx[2] && create_if_block44(ctx);
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (ctx2[2]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block44(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach(if_block_anchor);
      }
    };
  }
  function create_fragment45(ctx) {
    let svg;
    let path;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[11].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
    const default_slot_or_fallback = default_slot || fallback_block44(ctx);
    let svg_levels = [
      { "data-carbon-icon": "Txt16" },
      { xmlns: "http://www.w3.org/2000/svg" },
      { viewBox: "0 0 32 32" },
      { fill: "currentColor" },
      { width: "16" },
      { height: "16" },
      { class: ctx[0] },
      { preserveAspectRatio: "xMidYMid meet" },
      { style: ctx[3] },
      { id: ctx[1] },
      ctx[4]
    ];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        if (default_slot_or_fallback)
          default_slot_or_fallback.c();
        attr(path, "d", "M21 11L24 11 24 23 26 23 26 11 29 11 29 9 21 9 21 11zM20 9L18 9 16 15 14 9 12 9 14.75 16 12 23 14 23 16 17 18 23 20 23 17.25 16 20 9zM3 11L6 11 6 23 8 23 8 11 11 11 11 9 3 9 3 11z");
        set_svg_attributes(svg, svg_data);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        if (default_slot_or_fallback) {
          default_slot_or_fallback.m(svg, null);
        }
        current = true;
        if (!mounted) {
          dispose = [
            listen(svg, "click", ctx[12]),
            listen(svg, "mouseover", ctx[13]),
            listen(svg, "mouseenter", ctx[14]),
            listen(svg, "mouseleave", ctx[15]),
            listen(svg, "keyup", ctx[16]),
            listen(svg, "keydown", ctx[17])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1024)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
          }
        } else {
          if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
            default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
          }
        }
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
          { "data-carbon-icon": "Txt16" },
          { xmlns: "http://www.w3.org/2000/svg" },
          { viewBox: "0 0 32 32" },
          { fill: "currentColor" },
          { width: "16" },
          { height: "16" },
          (!current || dirty & 1) && { class: ctx2[0] },
          { preserveAspectRatio: "xMidYMid meet" },
          (!current || dirty & 8) && { style: ctx2[3] },
          (!current || dirty & 2) && { id: ctx2[1] },
          dirty & 16 && ctx2[4]
        ]));
      },
      i(local) {
        if (current)
          return;
        transition_in(default_slot_or_fallback, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot_or_fallback, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(svg);
        if (default_slot_or_fallback)
          default_slot_or_fallback.d(detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance45($$self, $$props, $$invalidate) {
    let ariaLabel;
    let ariaLabelledBy;
    let labelled;
    let attributes;
    let { $$slots: slots = {}, $$scope } = $$props;
    let { class: className = void 0 } = $$props;
    let { id = void 0 } = $$props;
    let { tabindex = void 0 } = $$props;
    let { focusable = false } = $$props;
    let { title: title2 = void 0 } = $$props;
    let { style = void 0 } = $$props;
    function click_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseover_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseenter_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseleave_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keyup_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keydown_handler(event) {
      bubble.call(this, $$self, event);
    }
    $$self.$$set = ($$new_props) => {
      $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
      if ("class" in $$new_props)
        $$invalidate(0, className = $$new_props.class);
      if ("id" in $$new_props)
        $$invalidate(1, id = $$new_props.id);
      if ("tabindex" in $$new_props)
        $$invalidate(5, tabindex = $$new_props.tabindex);
      if ("focusable" in $$new_props)
        $$invalidate(6, focusable = $$new_props.focusable);
      if ("title" in $$new_props)
        $$invalidate(2, title2 = $$new_props.title);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("$$scope" in $$new_props)
        $$invalidate(10, $$scope = $$new_props.$$scope);
    };
    $$self.$$.update = () => {
      $:
        $$invalidate(9, ariaLabel = $$props["aria-label"]);
      $:
        $$invalidate(8, ariaLabelledBy = $$props["aria-labelledby"]);
      if ($$self.$$.dirty & 772) {
        $:
          $$invalidate(7, labelled = ariaLabel || ariaLabelledBy || title2);
      }
      if ($$self.$$.dirty & 992) {
        $:
          $$invalidate(4, attributes = {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-hidden": labelled ? void 0 : true,
            role: labelled ? "img" : void 0,
            focusable: tabindex === "0" ? true : focusable,
            tabindex
          });
      }
    };
    $$props = exclude_internal_props($$props);
    return [
      className,
      id,
      title2,
      style,
      attributes,
      tabindex,
      focusable,
      labelled,
      ariaLabelledBy,
      ariaLabel,
      $$scope,
      slots,
      click_handler,
      mouseover_handler,
      mouseenter_handler,
      mouseleave_handler,
      keyup_handler,
      keydown_handler
    ];
  }
  var Txt16 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance45, create_fragment45, safe_not_equal, {
        class: 0,
        id: 1,
        tabindex: 5,
        focusable: 6,
        title: 2,
        style: 3
      });
    }
  };
  var Txt16_default = Txt16;

  // elos-web/node_modules/carbon-icons-svelte/lib/Txt16/index.js
  var Txt16_default2 = Txt16_default;

  // elos-web/node_modules/carbon-icons-svelte/lib/UserAvatarFilled16/UserAvatarFilled16.svelte
  function create_if_block45(ctx) {
    let title_1;
    let t;
    return {
      c() {
        title_1 = svg_element("title");
        t = text(ctx[2]);
      },
      m(target, anchor) {
        insert(target, title_1, anchor);
        append(title_1, t);
      },
      p(ctx2, dirty) {
        if (dirty & 4)
          set_data(t, ctx2[2]);
      },
      d(detaching) {
        if (detaching)
          detach(title_1);
      }
    };
  }
  function fallback_block45(ctx) {
    let if_block_anchor;
    let if_block = ctx[2] && create_if_block45(ctx);
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (ctx2[2]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block45(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach(if_block_anchor);
      }
    };
  }
  function create_fragment46(ctx) {
    let svg;
    let path0;
    let path1;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[11].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
    const default_slot_or_fallback = default_slot || fallback_block45(ctx);
    let svg_levels = [
      { "data-carbon-icon": "UserAvatarFilled16" },
      { xmlns: "http://www.w3.org/2000/svg" },
      { viewBox: "0 0 32 32" },
      { fill: "currentColor" },
      { width: "16" },
      { height: "16" },
      { class: ctx[0] },
      { preserveAspectRatio: "xMidYMid meet" },
      { style: ctx[3] },
      { id: ctx[1] },
      ctx[4]
    ];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    return {
      c() {
        svg = svg_element("svg");
        path0 = svg_element("path");
        path1 = svg_element("path");
        if (default_slot_or_fallback)
          default_slot_or_fallback.c();
        attr(path0, "fill", "none");
        attr(path0, "d", "M8.0071,24.93A4.9958,4.9958,0,0,1,13,20h6a4.9959,4.9959,0,0,1,4.9929,4.93,11.94,11.94,0,0,1-15.9858,0ZM20.5,12.5A4.5,4.5,0,1,1,16,8,4.5,4.5,0,0,1,20.5,12.5Z");
        attr(path1, "d", "M26.7489,24.93A13.9893,13.9893,0,1,0,2,16a13.899,13.899,0,0,0,3.2511,8.93l-.02.0166c.07.0845.15.1567.2222.2392.09.1036.1864.2.28.3008.28.3033.5674.5952.87.87.0915.0831.1864.1612.28.2417.32.2759.6484.5372.99.7813.0441.0312.0832.0693.1276.1006v-.0127a13.9011,13.9011,0,0,0,16,0V27.48c.0444-.0313.0835-.0694.1276-.1006.3412-.2441.67-.5054.99-.7813.0936-.08.1885-.1586.28-.2417.3025-.2749.59-.5668.87-.87.0933-.1006.1894-.1972.28-.3008.0719-.0825.1522-.1547.2222-.2392ZM16,8a4.5,4.5,0,1,1-4.5,4.5A4.5,4.5,0,0,1,16,8ZM8.0071,24.93A4.9957,4.9957,0,0,1,13,20h6a4.9958,4.9958,0,0,1,4.9929,4.93,11.94,11.94,0,0,1-15.9858,0Z");
        set_svg_attributes(svg, svg_data);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path0);
        append(svg, path1);
        if (default_slot_or_fallback) {
          default_slot_or_fallback.m(svg, null);
        }
        current = true;
        if (!mounted) {
          dispose = [
            listen(svg, "click", ctx[12]),
            listen(svg, "mouseover", ctx[13]),
            listen(svg, "mouseenter", ctx[14]),
            listen(svg, "mouseleave", ctx[15]),
            listen(svg, "keyup", ctx[16]),
            listen(svg, "keydown", ctx[17])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1024)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
          }
        } else {
          if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
            default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
          }
        }
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
          { "data-carbon-icon": "UserAvatarFilled16" },
          { xmlns: "http://www.w3.org/2000/svg" },
          { viewBox: "0 0 32 32" },
          { fill: "currentColor" },
          { width: "16" },
          { height: "16" },
          (!current || dirty & 1) && { class: ctx2[0] },
          { preserveAspectRatio: "xMidYMid meet" },
          (!current || dirty & 8) && { style: ctx2[3] },
          (!current || dirty & 2) && { id: ctx2[1] },
          dirty & 16 && ctx2[4]
        ]));
      },
      i(local) {
        if (current)
          return;
        transition_in(default_slot_or_fallback, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot_or_fallback, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(svg);
        if (default_slot_or_fallback)
          default_slot_or_fallback.d(detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance46($$self, $$props, $$invalidate) {
    let ariaLabel;
    let ariaLabelledBy;
    let labelled;
    let attributes;
    let { $$slots: slots = {}, $$scope } = $$props;
    let { class: className = void 0 } = $$props;
    let { id = void 0 } = $$props;
    let { tabindex = void 0 } = $$props;
    let { focusable = false } = $$props;
    let { title: title2 = void 0 } = $$props;
    let { style = void 0 } = $$props;
    function click_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseover_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseenter_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseleave_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keyup_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keydown_handler(event) {
      bubble.call(this, $$self, event);
    }
    $$self.$$set = ($$new_props) => {
      $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
      if ("class" in $$new_props)
        $$invalidate(0, className = $$new_props.class);
      if ("id" in $$new_props)
        $$invalidate(1, id = $$new_props.id);
      if ("tabindex" in $$new_props)
        $$invalidate(5, tabindex = $$new_props.tabindex);
      if ("focusable" in $$new_props)
        $$invalidate(6, focusable = $$new_props.focusable);
      if ("title" in $$new_props)
        $$invalidate(2, title2 = $$new_props.title);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("$$scope" in $$new_props)
        $$invalidate(10, $$scope = $$new_props.$$scope);
    };
    $$self.$$.update = () => {
      $:
        $$invalidate(9, ariaLabel = $$props["aria-label"]);
      $:
        $$invalidate(8, ariaLabelledBy = $$props["aria-labelledby"]);
      if ($$self.$$.dirty & 772) {
        $:
          $$invalidate(7, labelled = ariaLabel || ariaLabelledBy || title2);
      }
      if ($$self.$$.dirty & 992) {
        $:
          $$invalidate(4, attributes = {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-hidden": labelled ? void 0 : true,
            role: labelled ? "img" : void 0,
            focusable: tabindex === "0" ? true : focusable,
            tabindex
          });
      }
    };
    $$props = exclude_internal_props($$props);
    return [
      className,
      id,
      title2,
      style,
      attributes,
      tabindex,
      focusable,
      labelled,
      ariaLabelledBy,
      ariaLabel,
      $$scope,
      slots,
      click_handler,
      mouseover_handler,
      mouseenter_handler,
      mouseleave_handler,
      keyup_handler,
      keydown_handler
    ];
  }
  var UserAvatarFilled16 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance46, create_fragment46, safe_not_equal, {
        class: 0,
        id: 1,
        tabindex: 5,
        focusable: 6,
        title: 2,
        style: 3
      });
    }
  };
  var UserAvatarFilled16_default = UserAvatarFilled16;

  // elos-web/node_modules/carbon-icons-svelte/lib/UserAvatarFilled16/index.js
  var UserAvatarFilled16_default2 = UserAvatarFilled16_default;

  // elos-web/node_modules/carbon-icons-svelte/lib/ViewMode_116/ViewMode_116.svelte
  function create_if_block46(ctx) {
    let title_1;
    let t;
    return {
      c() {
        title_1 = svg_element("title");
        t = text(ctx[2]);
      },
      m(target, anchor) {
        insert(target, title_1, anchor);
        append(title_1, t);
      },
      p(ctx2, dirty) {
        if (dirty & 4)
          set_data(t, ctx2[2]);
      },
      d(detaching) {
        if (detaching)
          detach(title_1);
      }
    };
  }
  function fallback_block46(ctx) {
    let if_block_anchor;
    let if_block = ctx[2] && create_if_block46(ctx);
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (ctx2[2]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block46(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach(if_block_anchor);
      }
    };
  }
  function create_fragment47(ctx) {
    let svg;
    let path;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[11].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
    const default_slot_or_fallback = default_slot || fallback_block46(ctx);
    let svg_levels = [
      { "data-carbon-icon": "ViewMode_116" },
      { xmlns: "http://www.w3.org/2000/svg" },
      { viewBox: "0 0 32 32" },
      { fill: "currentColor" },
      { width: "16" },
      { height: "16" },
      { class: ctx[0] },
      { preserveAspectRatio: "xMidYMid meet" },
      { style: ctx[3] },
      { id: ctx[1] },
      ctx[4]
    ];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        if (default_slot_or_fallback)
          default_slot_or_fallback.c();
        attr(path, "d", "M4 26H28V28H4zM4 19H28V21H4zM26 6v6H6V6H26m0-2H6A2 2 0 004 6v6a2 2 0 002 2H26a2 2 0 002-2V6a2 2 0 00-2-2z");
        set_svg_attributes(svg, svg_data);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        if (default_slot_or_fallback) {
          default_slot_or_fallback.m(svg, null);
        }
        current = true;
        if (!mounted) {
          dispose = [
            listen(svg, "click", ctx[12]),
            listen(svg, "mouseover", ctx[13]),
            listen(svg, "mouseenter", ctx[14]),
            listen(svg, "mouseleave", ctx[15]),
            listen(svg, "keyup", ctx[16]),
            listen(svg, "keydown", ctx[17])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1024)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
          }
        } else {
          if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
            default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
          }
        }
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
          { "data-carbon-icon": "ViewMode_116" },
          { xmlns: "http://www.w3.org/2000/svg" },
          { viewBox: "0 0 32 32" },
          { fill: "currentColor" },
          { width: "16" },
          { height: "16" },
          (!current || dirty & 1) && { class: ctx2[0] },
          { preserveAspectRatio: "xMidYMid meet" },
          (!current || dirty & 8) && { style: ctx2[3] },
          (!current || dirty & 2) && { id: ctx2[1] },
          dirty & 16 && ctx2[4]
        ]));
      },
      i(local) {
        if (current)
          return;
        transition_in(default_slot_or_fallback, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot_or_fallback, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(svg);
        if (default_slot_or_fallback)
          default_slot_or_fallback.d(detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance47($$self, $$props, $$invalidate) {
    let ariaLabel;
    let ariaLabelledBy;
    let labelled;
    let attributes;
    let { $$slots: slots = {}, $$scope } = $$props;
    let { class: className = void 0 } = $$props;
    let { id = void 0 } = $$props;
    let { tabindex = void 0 } = $$props;
    let { focusable = false } = $$props;
    let { title: title2 = void 0 } = $$props;
    let { style = void 0 } = $$props;
    function click_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseover_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseenter_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseleave_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keyup_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keydown_handler(event) {
      bubble.call(this, $$self, event);
    }
    $$self.$$set = ($$new_props) => {
      $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
      if ("class" in $$new_props)
        $$invalidate(0, className = $$new_props.class);
      if ("id" in $$new_props)
        $$invalidate(1, id = $$new_props.id);
      if ("tabindex" in $$new_props)
        $$invalidate(5, tabindex = $$new_props.tabindex);
      if ("focusable" in $$new_props)
        $$invalidate(6, focusable = $$new_props.focusable);
      if ("title" in $$new_props)
        $$invalidate(2, title2 = $$new_props.title);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("$$scope" in $$new_props)
        $$invalidate(10, $$scope = $$new_props.$$scope);
    };
    $$self.$$.update = () => {
      $:
        $$invalidate(9, ariaLabel = $$props["aria-label"]);
      $:
        $$invalidate(8, ariaLabelledBy = $$props["aria-labelledby"]);
      if ($$self.$$.dirty & 772) {
        $:
          $$invalidate(7, labelled = ariaLabel || ariaLabelledBy || title2);
      }
      if ($$self.$$.dirty & 992) {
        $:
          $$invalidate(4, attributes = {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-hidden": labelled ? void 0 : true,
            role: labelled ? "img" : void 0,
            focusable: tabindex === "0" ? true : focusable,
            tabindex
          });
      }
    };
    $$props = exclude_internal_props($$props);
    return [
      className,
      id,
      title2,
      style,
      attributes,
      tabindex,
      focusable,
      labelled,
      ariaLabelledBy,
      ariaLabel,
      $$scope,
      slots,
      click_handler,
      mouseover_handler,
      mouseenter_handler,
      mouseleave_handler,
      keyup_handler,
      keydown_handler
    ];
  }
  var ViewMode_116 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance47, create_fragment47, safe_not_equal, {
        class: 0,
        id: 1,
        tabindex: 5,
        focusable: 6,
        title: 2,
        style: 3
      });
    }
  };
  var ViewMode_116_default = ViewMode_116;

  // elos-web/node_modules/carbon-icons-svelte/lib/ViewMode_116/index.js
  var ViewMode_116_default2 = ViewMode_116_default;

  // elos-web/node_modules/carbon-icons-svelte/lib/ViewMode_216/ViewMode_216.svelte
  function create_if_block47(ctx) {
    let title_1;
    let t;
    return {
      c() {
        title_1 = svg_element("title");
        t = text(ctx[2]);
      },
      m(target, anchor) {
        insert(target, title_1, anchor);
        append(title_1, t);
      },
      p(ctx2, dirty) {
        if (dirty & 4)
          set_data(t, ctx2[2]);
      },
      d(detaching) {
        if (detaching)
          detach(title_1);
      }
    };
  }
  function fallback_block47(ctx) {
    let if_block_anchor;
    let if_block = ctx[2] && create_if_block47(ctx);
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (ctx2[2]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block47(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach(if_block_anchor);
      }
    };
  }
  function create_fragment48(ctx) {
    let svg;
    let path;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[11].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
    const default_slot_or_fallback = default_slot || fallback_block47(ctx);
    let svg_levels = [
      { "data-carbon-icon": "ViewMode_216" },
      { xmlns: "http://www.w3.org/2000/svg" },
      { viewBox: "0 0 32 32" },
      { fill: "currentColor" },
      { width: "16" },
      { height: "16" },
      { class: ctx[0] },
      { preserveAspectRatio: "xMidYMid meet" },
      { style: ctx[3] },
      { id: ctx[1] },
      ctx[4]
    ];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        if (default_slot_or_fallback)
          default_slot_or_fallback.c();
        attr(path, "d", "M4 26H28V28H4zM4 19H28V21H4zM12 6v6H6V6h6m0-2H6A2 2 0 004 6v6a2 2 0 002 2h6a2 2 0 002-2V6a2 2 0 00-2-2zM26 6v6H20V6h6m0-2H20a2 2 0 00-2 2v6a2 2 0 002 2h6a2 2 0 002-2V6a2 2 0 00-2-2z");
        set_svg_attributes(svg, svg_data);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        if (default_slot_or_fallback) {
          default_slot_or_fallback.m(svg, null);
        }
        current = true;
        if (!mounted) {
          dispose = [
            listen(svg, "click", ctx[12]),
            listen(svg, "mouseover", ctx[13]),
            listen(svg, "mouseenter", ctx[14]),
            listen(svg, "mouseleave", ctx[15]),
            listen(svg, "keyup", ctx[16]),
            listen(svg, "keydown", ctx[17])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1024)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
          }
        } else {
          if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
            default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
          }
        }
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
          { "data-carbon-icon": "ViewMode_216" },
          { xmlns: "http://www.w3.org/2000/svg" },
          { viewBox: "0 0 32 32" },
          { fill: "currentColor" },
          { width: "16" },
          { height: "16" },
          (!current || dirty & 1) && { class: ctx2[0] },
          { preserveAspectRatio: "xMidYMid meet" },
          (!current || dirty & 8) && { style: ctx2[3] },
          (!current || dirty & 2) && { id: ctx2[1] },
          dirty & 16 && ctx2[4]
        ]));
      },
      i(local) {
        if (current)
          return;
        transition_in(default_slot_or_fallback, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot_or_fallback, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(svg);
        if (default_slot_or_fallback)
          default_slot_or_fallback.d(detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance48($$self, $$props, $$invalidate) {
    let ariaLabel;
    let ariaLabelledBy;
    let labelled;
    let attributes;
    let { $$slots: slots = {}, $$scope } = $$props;
    let { class: className = void 0 } = $$props;
    let { id = void 0 } = $$props;
    let { tabindex = void 0 } = $$props;
    let { focusable = false } = $$props;
    let { title: title2 = void 0 } = $$props;
    let { style = void 0 } = $$props;
    function click_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseover_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseenter_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseleave_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keyup_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keydown_handler(event) {
      bubble.call(this, $$self, event);
    }
    $$self.$$set = ($$new_props) => {
      $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
      if ("class" in $$new_props)
        $$invalidate(0, className = $$new_props.class);
      if ("id" in $$new_props)
        $$invalidate(1, id = $$new_props.id);
      if ("tabindex" in $$new_props)
        $$invalidate(5, tabindex = $$new_props.tabindex);
      if ("focusable" in $$new_props)
        $$invalidate(6, focusable = $$new_props.focusable);
      if ("title" in $$new_props)
        $$invalidate(2, title2 = $$new_props.title);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("$$scope" in $$new_props)
        $$invalidate(10, $$scope = $$new_props.$$scope);
    };
    $$self.$$.update = () => {
      $:
        $$invalidate(9, ariaLabel = $$props["aria-label"]);
      $:
        $$invalidate(8, ariaLabelledBy = $$props["aria-labelledby"]);
      if ($$self.$$.dirty & 772) {
        $:
          $$invalidate(7, labelled = ariaLabel || ariaLabelledBy || title2);
      }
      if ($$self.$$.dirty & 992) {
        $:
          $$invalidate(4, attributes = {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-hidden": labelled ? void 0 : true,
            role: labelled ? "img" : void 0,
            focusable: tabindex === "0" ? true : focusable,
            tabindex
          });
      }
    };
    $$props = exclude_internal_props($$props);
    return [
      className,
      id,
      title2,
      style,
      attributes,
      tabindex,
      focusable,
      labelled,
      ariaLabelledBy,
      ariaLabel,
      $$scope,
      slots,
      click_handler,
      mouseover_handler,
      mouseenter_handler,
      mouseleave_handler,
      keyup_handler,
      keydown_handler
    ];
  }
  var ViewMode_216 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance48, create_fragment48, safe_not_equal, {
        class: 0,
        id: 1,
        tabindex: 5,
        focusable: 6,
        title: 2,
        style: 3
      });
    }
  };
  var ViewMode_216_default = ViewMode_216;

  // elos-web/node_modules/carbon-icons-svelte/lib/ViewMode_216/index.js
  var ViewMode_216_default2 = ViewMode_216_default;

  // elos-web/node_modules/carbon-icons-svelte/lib/Warning16/Warning16.svelte
  function create_if_block48(ctx) {
    let title_1;
    let t;
    return {
      c() {
        title_1 = svg_element("title");
        t = text(ctx[2]);
      },
      m(target, anchor) {
        insert(target, title_1, anchor);
        append(title_1, t);
      },
      p(ctx2, dirty) {
        if (dirty & 4)
          set_data(t, ctx2[2]);
      },
      d(detaching) {
        if (detaching)
          detach(title_1);
      }
    };
  }
  function fallback_block48(ctx) {
    let if_block_anchor;
    let if_block = ctx[2] && create_if_block48(ctx);
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (ctx2[2]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block48(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach(if_block_anchor);
      }
    };
  }
  function create_fragment49(ctx) {
    let svg;
    let path0;
    let path1;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[11].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
    const default_slot_or_fallback = default_slot || fallback_block48(ctx);
    let svg_levels = [
      { "data-carbon-icon": "Warning16" },
      { xmlns: "http://www.w3.org/2000/svg" },
      { viewBox: "0 0 16 16" },
      { fill: "currentColor" },
      { width: "16" },
      { height: "16" },
      { class: ctx[0] },
      { preserveAspectRatio: "xMidYMid meet" },
      { style: ctx[3] },
      { id: ctx[1] },
      ctx[4]
    ];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    return {
      c() {
        svg = svg_element("svg");
        path0 = svg_element("path");
        path1 = svg_element("path");
        if (default_slot_or_fallback)
          default_slot_or_fallback.c();
        attr(path0, "d", "M8,1C4.1,1,1,4.1,1,8s3.1,7,7,7s7-3.1,7-7S11.9,1,8,1z M8,14c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S11.3,14,8,14z");
        attr(path1, "d", "M7.5 4H8.5V9H7.5zM8 10.2c-.4 0-.8.3-.8.8s.3.8.8.8c.4 0 .8-.3.8-.8S8.4 10.2 8 10.2z");
        set_svg_attributes(svg, svg_data);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path0);
        append(svg, path1);
        if (default_slot_or_fallback) {
          default_slot_or_fallback.m(svg, null);
        }
        current = true;
        if (!mounted) {
          dispose = [
            listen(svg, "click", ctx[12]),
            listen(svg, "mouseover", ctx[13]),
            listen(svg, "mouseenter", ctx[14]),
            listen(svg, "mouseleave", ctx[15]),
            listen(svg, "keyup", ctx[16]),
            listen(svg, "keydown", ctx[17])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1024)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
          }
        } else {
          if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
            default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
          }
        }
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
          { "data-carbon-icon": "Warning16" },
          { xmlns: "http://www.w3.org/2000/svg" },
          { viewBox: "0 0 16 16" },
          { fill: "currentColor" },
          { width: "16" },
          { height: "16" },
          (!current || dirty & 1) && { class: ctx2[0] },
          { preserveAspectRatio: "xMidYMid meet" },
          (!current || dirty & 8) && { style: ctx2[3] },
          (!current || dirty & 2) && { id: ctx2[1] },
          dirty & 16 && ctx2[4]
        ]));
      },
      i(local) {
        if (current)
          return;
        transition_in(default_slot_or_fallback, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot_or_fallback, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(svg);
        if (default_slot_or_fallback)
          default_slot_or_fallback.d(detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance49($$self, $$props, $$invalidate) {
    let ariaLabel;
    let ariaLabelledBy;
    let labelled;
    let attributes;
    let { $$slots: slots = {}, $$scope } = $$props;
    let { class: className = void 0 } = $$props;
    let { id = void 0 } = $$props;
    let { tabindex = void 0 } = $$props;
    let { focusable = false } = $$props;
    let { title: title2 = void 0 } = $$props;
    let { style = void 0 } = $$props;
    function click_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseover_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseenter_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseleave_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keyup_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keydown_handler(event) {
      bubble.call(this, $$self, event);
    }
    $$self.$$set = ($$new_props) => {
      $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
      if ("class" in $$new_props)
        $$invalidate(0, className = $$new_props.class);
      if ("id" in $$new_props)
        $$invalidate(1, id = $$new_props.id);
      if ("tabindex" in $$new_props)
        $$invalidate(5, tabindex = $$new_props.tabindex);
      if ("focusable" in $$new_props)
        $$invalidate(6, focusable = $$new_props.focusable);
      if ("title" in $$new_props)
        $$invalidate(2, title2 = $$new_props.title);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("$$scope" in $$new_props)
        $$invalidate(10, $$scope = $$new_props.$$scope);
    };
    $$self.$$.update = () => {
      $:
        $$invalidate(9, ariaLabel = $$props["aria-label"]);
      $:
        $$invalidate(8, ariaLabelledBy = $$props["aria-labelledby"]);
      if ($$self.$$.dirty & 772) {
        $:
          $$invalidate(7, labelled = ariaLabel || ariaLabelledBy || title2);
      }
      if ($$self.$$.dirty & 992) {
        $:
          $$invalidate(4, attributes = {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-hidden": labelled ? void 0 : true,
            role: labelled ? "img" : void 0,
            focusable: tabindex === "0" ? true : focusable,
            tabindex
          });
      }
    };
    $$props = exclude_internal_props($$props);
    return [
      className,
      id,
      title2,
      style,
      attributes,
      tabindex,
      focusable,
      labelled,
      ariaLabelledBy,
      ariaLabel,
      $$scope,
      slots,
      click_handler,
      mouseover_handler,
      mouseenter_handler,
      mouseleave_handler,
      keyup_handler,
      keydown_handler
    ];
  }
  var Warning16 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance49, create_fragment49, safe_not_equal, {
        class: 0,
        id: 1,
        tabindex: 5,
        focusable: 6,
        title: 2,
        style: 3
      });
    }
  };
  var Warning16_default = Warning16;

  // elos-web/node_modules/carbon-icons-svelte/lib/Warning16/index.js
  var Warning16_default2 = Warning16_default;

  // elos-web/node_modules/carbon-icons-svelte/lib/WatsonHealthCutInHalf16/WatsonHealthCutInHalf16.svelte
  function create_if_block49(ctx) {
    let title_1;
    let t;
    return {
      c() {
        title_1 = svg_element("title");
        t = text(ctx[2]);
      },
      m(target, anchor) {
        insert(target, title_1, anchor);
        append(title_1, t);
      },
      p(ctx2, dirty) {
        if (dirty & 4)
          set_data(t, ctx2[2]);
      },
      d(detaching) {
        if (detaching)
          detach(title_1);
      }
    };
  }
  function fallback_block49(ctx) {
    let if_block_anchor;
    let if_block = ctx[2] && create_if_block49(ctx);
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (ctx2[2]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block49(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach(if_block_anchor);
      }
    };
  }
  function create_fragment50(ctx) {
    let svg;
    let path;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[11].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
    const default_slot_or_fallback = default_slot || fallback_block49(ctx);
    let svg_levels = [
      {
        "data-carbon-icon": "WatsonHealthCutInHalf16"
      },
      { xmlns: "http://www.w3.org/2000/svg" },
      { viewBox: "0 0 32 32" },
      { fill: "currentColor" },
      { width: "16" },
      { height: "16" },
      { class: ctx[0] },
      { preserveAspectRatio: "xMidYMid meet" },
      { style: ctx[3] },
      { id: ctx[1] },
      ctx[4]
    ];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        if (default_slot_or_fallback)
          default_slot_or_fallback.c();
        attr(path, "d", "M28,4H4A2.0023,2.0023,0,0,0,2,6V26a2.0023,2.0023,0,0,0,2,2H28a2.0023,2.0023,0,0,0,2-2V6A2.0023,2.0023,0,0,0,28,4ZM4,6H16V26H4Z");
        set_svg_attributes(svg, svg_data);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        if (default_slot_or_fallback) {
          default_slot_or_fallback.m(svg, null);
        }
        current = true;
        if (!mounted) {
          dispose = [
            listen(svg, "click", ctx[12]),
            listen(svg, "mouseover", ctx[13]),
            listen(svg, "mouseenter", ctx[14]),
            listen(svg, "mouseleave", ctx[15]),
            listen(svg, "keyup", ctx[16]),
            listen(svg, "keydown", ctx[17])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1024)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
          }
        } else {
          if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
            default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
          }
        }
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
          {
            "data-carbon-icon": "WatsonHealthCutInHalf16"
          },
          { xmlns: "http://www.w3.org/2000/svg" },
          { viewBox: "0 0 32 32" },
          { fill: "currentColor" },
          { width: "16" },
          { height: "16" },
          (!current || dirty & 1) && { class: ctx2[0] },
          { preserveAspectRatio: "xMidYMid meet" },
          (!current || dirty & 8) && { style: ctx2[3] },
          (!current || dirty & 2) && { id: ctx2[1] },
          dirty & 16 && ctx2[4]
        ]));
      },
      i(local) {
        if (current)
          return;
        transition_in(default_slot_or_fallback, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot_or_fallback, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(svg);
        if (default_slot_or_fallback)
          default_slot_or_fallback.d(detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance50($$self, $$props, $$invalidate) {
    let ariaLabel;
    let ariaLabelledBy;
    let labelled;
    let attributes;
    let { $$slots: slots = {}, $$scope } = $$props;
    let { class: className = void 0 } = $$props;
    let { id = void 0 } = $$props;
    let { tabindex = void 0 } = $$props;
    let { focusable = false } = $$props;
    let { title: title2 = void 0 } = $$props;
    let { style = void 0 } = $$props;
    function click_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseover_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseenter_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseleave_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keyup_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keydown_handler(event) {
      bubble.call(this, $$self, event);
    }
    $$self.$$set = ($$new_props) => {
      $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
      if ("class" in $$new_props)
        $$invalidate(0, className = $$new_props.class);
      if ("id" in $$new_props)
        $$invalidate(1, id = $$new_props.id);
      if ("tabindex" in $$new_props)
        $$invalidate(5, tabindex = $$new_props.tabindex);
      if ("focusable" in $$new_props)
        $$invalidate(6, focusable = $$new_props.focusable);
      if ("title" in $$new_props)
        $$invalidate(2, title2 = $$new_props.title);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("$$scope" in $$new_props)
        $$invalidate(10, $$scope = $$new_props.$$scope);
    };
    $$self.$$.update = () => {
      $:
        $$invalidate(9, ariaLabel = $$props["aria-label"]);
      $:
        $$invalidate(8, ariaLabelledBy = $$props["aria-labelledby"]);
      if ($$self.$$.dirty & 772) {
        $:
          $$invalidate(7, labelled = ariaLabel || ariaLabelledBy || title2);
      }
      if ($$self.$$.dirty & 992) {
        $:
          $$invalidate(4, attributes = {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-hidden": labelled ? void 0 : true,
            role: labelled ? "img" : void 0,
            focusable: tabindex === "0" ? true : focusable,
            tabindex
          });
      }
    };
    $$props = exclude_internal_props($$props);
    return [
      className,
      id,
      title2,
      style,
      attributes,
      tabindex,
      focusable,
      labelled,
      ariaLabelledBy,
      ariaLabel,
      $$scope,
      slots,
      click_handler,
      mouseover_handler,
      mouseenter_handler,
      mouseleave_handler,
      keyup_handler,
      keydown_handler
    ];
  }
  var WatsonHealthCutInHalf16 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance50, create_fragment50, safe_not_equal, {
        class: 0,
        id: 1,
        tabindex: 5,
        focusable: 6,
        title: 2,
        style: 3
      });
    }
  };
  var WatsonHealthCutInHalf16_default = WatsonHealthCutInHalf16;

  // elos-web/node_modules/carbon-icons-svelte/lib/WatsonHealthCutInHalf16/index.js
  var WatsonHealthCutInHalf16_default2 = WatsonHealthCutInHalf16_default;

  // elos-web/node_modules/carbon-icons-svelte/lib/WatsonHealthStackedScrolling_116/WatsonHealthStackedScrolling_116.svelte
  function create_if_block50(ctx) {
    let title_1;
    let t;
    return {
      c() {
        title_1 = svg_element("title");
        t = text(ctx[2]);
      },
      m(target, anchor) {
        insert(target, title_1, anchor);
        append(title_1, t);
      },
      p(ctx2, dirty) {
        if (dirty & 4)
          set_data(t, ctx2[2]);
      },
      d(detaching) {
        if (detaching)
          detach(title_1);
      }
    };
  }
  function fallback_block50(ctx) {
    let if_block_anchor;
    let if_block = ctx[2] && create_if_block50(ctx);
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (ctx2[2]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block50(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach(if_block_anchor);
      }
    };
  }
  function create_fragment51(ctx) {
    let svg;
    let path0;
    let path1;
    let path2;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[11].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
    const default_slot_or_fallback = default_slot || fallback_block50(ctx);
    let svg_levels = [
      {
        "data-carbon-icon": "WatsonHealthStackedScrolling_116"
      },
      { xmlns: "http://www.w3.org/2000/svg" },
      { viewBox: "0 0 32 32" },
      { fill: "currentColor" },
      { width: "16" },
      { height: "16" },
      { class: ctx[0] },
      { preserveAspectRatio: "xMidYMid meet" },
      { style: ctx[3] },
      { id: ctx[1] },
      ctx[4]
    ];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    return {
      c() {
        svg = svg_element("svg");
        path0 = svg_element("path");
        path1 = svg_element("path");
        path2 = svg_element("path");
        if (default_slot_or_fallback)
          default_slot_or_fallback.c();
        attr(path0, "d", "M18,30H4a2,2,0,0,1-2-2V14a2,2,0,0,1,2-2H18a2,2,0,0,1,2,2V28A2,2,0,0,1,18,30ZM4,14V28H18V14Z");
        attr(path1, "d", "M25,23H23V9H9V7H23a2,2,0,0,1,2,2Z");
        attr(path2, "d", "M30,16H28V4H16V2H28a2,2,0,0,1,2,2Z");
        set_svg_attributes(svg, svg_data);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path0);
        append(svg, path1);
        append(svg, path2);
        if (default_slot_or_fallback) {
          default_slot_or_fallback.m(svg, null);
        }
        current = true;
        if (!mounted) {
          dispose = [
            listen(svg, "click", ctx[12]),
            listen(svg, "mouseover", ctx[13]),
            listen(svg, "mouseenter", ctx[14]),
            listen(svg, "mouseleave", ctx[15]),
            listen(svg, "keyup", ctx[16]),
            listen(svg, "keydown", ctx[17])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1024)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
          }
        } else {
          if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
            default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
          }
        }
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
          {
            "data-carbon-icon": "WatsonHealthStackedScrolling_116"
          },
          { xmlns: "http://www.w3.org/2000/svg" },
          { viewBox: "0 0 32 32" },
          { fill: "currentColor" },
          { width: "16" },
          { height: "16" },
          (!current || dirty & 1) && { class: ctx2[0] },
          { preserveAspectRatio: "xMidYMid meet" },
          (!current || dirty & 8) && { style: ctx2[3] },
          (!current || dirty & 2) && { id: ctx2[1] },
          dirty & 16 && ctx2[4]
        ]));
      },
      i(local) {
        if (current)
          return;
        transition_in(default_slot_or_fallback, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot_or_fallback, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(svg);
        if (default_slot_or_fallback)
          default_slot_or_fallback.d(detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance51($$self, $$props, $$invalidate) {
    let ariaLabel;
    let ariaLabelledBy;
    let labelled;
    let attributes;
    let { $$slots: slots = {}, $$scope } = $$props;
    let { class: className = void 0 } = $$props;
    let { id = void 0 } = $$props;
    let { tabindex = void 0 } = $$props;
    let { focusable = false } = $$props;
    let { title: title2 = void 0 } = $$props;
    let { style = void 0 } = $$props;
    function click_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseover_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseenter_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseleave_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keyup_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keydown_handler(event) {
      bubble.call(this, $$self, event);
    }
    $$self.$$set = ($$new_props) => {
      $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
      if ("class" in $$new_props)
        $$invalidate(0, className = $$new_props.class);
      if ("id" in $$new_props)
        $$invalidate(1, id = $$new_props.id);
      if ("tabindex" in $$new_props)
        $$invalidate(5, tabindex = $$new_props.tabindex);
      if ("focusable" in $$new_props)
        $$invalidate(6, focusable = $$new_props.focusable);
      if ("title" in $$new_props)
        $$invalidate(2, title2 = $$new_props.title);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("$$scope" in $$new_props)
        $$invalidate(10, $$scope = $$new_props.$$scope);
    };
    $$self.$$.update = () => {
      $:
        $$invalidate(9, ariaLabel = $$props["aria-label"]);
      $:
        $$invalidate(8, ariaLabelledBy = $$props["aria-labelledby"]);
      if ($$self.$$.dirty & 772) {
        $:
          $$invalidate(7, labelled = ariaLabel || ariaLabelledBy || title2);
      }
      if ($$self.$$.dirty & 992) {
        $:
          $$invalidate(4, attributes = {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-hidden": labelled ? void 0 : true,
            role: labelled ? "img" : void 0,
            focusable: tabindex === "0" ? true : focusable,
            tabindex
          });
      }
    };
    $$props = exclude_internal_props($$props);
    return [
      className,
      id,
      title2,
      style,
      attributes,
      tabindex,
      focusable,
      labelled,
      ariaLabelledBy,
      ariaLabel,
      $$scope,
      slots,
      click_handler,
      mouseover_handler,
      mouseenter_handler,
      mouseleave_handler,
      keyup_handler,
      keydown_handler
    ];
  }
  var WatsonHealthStackedScrolling_116 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance51, create_fragment51, safe_not_equal, {
        class: 0,
        id: 1,
        tabindex: 5,
        focusable: 6,
        title: 2,
        style: 3
      });
    }
  };
  var WatsonHealthStackedScrolling_116_default = WatsonHealthStackedScrolling_116;

  // elos-web/node_modules/carbon-icons-svelte/lib/WatsonHealthStackedScrolling_116/index.js
  var WatsonHealthStackedScrolling_116_default2 = WatsonHealthStackedScrolling_116_default;

  // elos-web/node_modules/carbon-icons-svelte/lib/WatsonHealthThumbnailPreview16/WatsonHealthThumbnailPreview16.svelte
  function create_if_block51(ctx) {
    let title_1;
    let t;
    return {
      c() {
        title_1 = svg_element("title");
        t = text(ctx[2]);
      },
      m(target, anchor) {
        insert(target, title_1, anchor);
        append(title_1, t);
      },
      p(ctx2, dirty) {
        if (dirty & 4)
          set_data(t, ctx2[2]);
      },
      d(detaching) {
        if (detaching)
          detach(title_1);
      }
    };
  }
  function fallback_block51(ctx) {
    let if_block_anchor;
    let if_block = ctx[2] && create_if_block51(ctx);
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (ctx2[2]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block51(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach(if_block_anchor);
      }
    };
  }
  function create_fragment52(ctx) {
    let svg;
    let path0;
    let path1;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[11].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
    const default_slot_or_fallback = default_slot || fallback_block51(ctx);
    let svg_levels = [
      {
        "data-carbon-icon": "WatsonHealthThumbnailPreview16"
      },
      { xmlns: "http://www.w3.org/2000/svg" },
      { viewBox: "0 0 32 32" },
      { fill: "currentColor" },
      { width: "16" },
      { height: "16" },
      { class: ctx[0] },
      { preserveAspectRatio: "xMidYMid meet" },
      { style: ctx[3] },
      { id: ctx[1] },
      ctx[4]
    ];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    return {
      c() {
        svg = svg_element("svg");
        path0 = svg_element("path");
        path1 = svg_element("path");
        if (default_slot_or_fallback)
          default_slot_or_fallback.c();
        attr(path0, "d", "M28,12H4a2.0023,2.0023,0,0,0-2,2V28a2.002,2.002,0,0,0,2,2H28a2.0023,2.0023,0,0,0,2-2V14A2.0027,2.0027,0,0,0,28,12ZM20,28H12V27a1.0009,1.0009,0,0,1,1-1h6a1.0009,1.0009,0,0,1,1,1Zm8,0H22V27a3.0033,3.0033,0,0,0-3-3H13a3.0033,3.0033,0,0,0-3,3v1H4V14H28.002Z");
        attr(path1, "d", "M16 23a4 4 0 114-4A4.0042 4.0042 0 0116 23zm0-6a2 2 0 102 2A2.0023 2.0023 0 0016 17zM30 4V8a2.0027 2.0027 0 01-2 2H24a2.0027 2.0027 0 01-2-2V4a2.0027 2.0027 0 012-2h4A2.0027 2.0027 0 0130 4zM28 8l.002-4H24V8zM20 4V8a2.0027 2.0027 0 01-2 2H14a2.0023 2.0023 0 01-2-2V4a2.0023 2.0023 0 012-2h4A2.0027 2.0027 0 0120 4zM18 8l.002-4H14V8zM10 4V8a2.0023 2.0023 0 01-2 2H4A2.0023 2.0023 0 012 8V4A2.0023 2.0023 0 014 2H8A2.0023 2.0023 0 0110 4zM8 8l.0015-4H4V8z");
        set_svg_attributes(svg, svg_data);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path0);
        append(svg, path1);
        if (default_slot_or_fallback) {
          default_slot_or_fallback.m(svg, null);
        }
        current = true;
        if (!mounted) {
          dispose = [
            listen(svg, "click", ctx[12]),
            listen(svg, "mouseover", ctx[13]),
            listen(svg, "mouseenter", ctx[14]),
            listen(svg, "mouseleave", ctx[15]),
            listen(svg, "keyup", ctx[16]),
            listen(svg, "keydown", ctx[17])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1024)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
          }
        } else {
          if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
            default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
          }
        }
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
          {
            "data-carbon-icon": "WatsonHealthThumbnailPreview16"
          },
          { xmlns: "http://www.w3.org/2000/svg" },
          { viewBox: "0 0 32 32" },
          { fill: "currentColor" },
          { width: "16" },
          { height: "16" },
          (!current || dirty & 1) && { class: ctx2[0] },
          { preserveAspectRatio: "xMidYMid meet" },
          (!current || dirty & 8) && { style: ctx2[3] },
          (!current || dirty & 2) && { id: ctx2[1] },
          dirty & 16 && ctx2[4]
        ]));
      },
      i(local) {
        if (current)
          return;
        transition_in(default_slot_or_fallback, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot_or_fallback, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(svg);
        if (default_slot_or_fallback)
          default_slot_or_fallback.d(detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance52($$self, $$props, $$invalidate) {
    let ariaLabel;
    let ariaLabelledBy;
    let labelled;
    let attributes;
    let { $$slots: slots = {}, $$scope } = $$props;
    let { class: className = void 0 } = $$props;
    let { id = void 0 } = $$props;
    let { tabindex = void 0 } = $$props;
    let { focusable = false } = $$props;
    let { title: title2 = void 0 } = $$props;
    let { style = void 0 } = $$props;
    function click_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseover_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseenter_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseleave_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keyup_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keydown_handler(event) {
      bubble.call(this, $$self, event);
    }
    $$self.$$set = ($$new_props) => {
      $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
      if ("class" in $$new_props)
        $$invalidate(0, className = $$new_props.class);
      if ("id" in $$new_props)
        $$invalidate(1, id = $$new_props.id);
      if ("tabindex" in $$new_props)
        $$invalidate(5, tabindex = $$new_props.tabindex);
      if ("focusable" in $$new_props)
        $$invalidate(6, focusable = $$new_props.focusable);
      if ("title" in $$new_props)
        $$invalidate(2, title2 = $$new_props.title);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("$$scope" in $$new_props)
        $$invalidate(10, $$scope = $$new_props.$$scope);
    };
    $$self.$$.update = () => {
      $:
        $$invalidate(9, ariaLabel = $$props["aria-label"]);
      $:
        $$invalidate(8, ariaLabelledBy = $$props["aria-labelledby"]);
      if ($$self.$$.dirty & 772) {
        $:
          $$invalidate(7, labelled = ariaLabel || ariaLabelledBy || title2);
      }
      if ($$self.$$.dirty & 992) {
        $:
          $$invalidate(4, attributes = {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-hidden": labelled ? void 0 : true,
            role: labelled ? "img" : void 0,
            focusable: tabindex === "0" ? true : focusable,
            tabindex
          });
      }
    };
    $$props = exclude_internal_props($$props);
    return [
      className,
      id,
      title2,
      style,
      attributes,
      tabindex,
      focusable,
      labelled,
      ariaLabelledBy,
      ariaLabel,
      $$scope,
      slots,
      click_handler,
      mouseover_handler,
      mouseenter_handler,
      mouseleave_handler,
      keyup_handler,
      keydown_handler
    ];
  }
  var WatsonHealthThumbnailPreview16 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance52, create_fragment52, safe_not_equal, {
        class: 0,
        id: 1,
        tabindex: 5,
        focusable: 6,
        title: 2,
        style: 3
      });
    }
  };
  var WatsonHealthThumbnailPreview16_default = WatsonHealthThumbnailPreview16;

  // elos-web/node_modules/carbon-icons-svelte/lib/WatsonHealthThumbnailPreview16/index.js
  var WatsonHealthThumbnailPreview16_default2 = WatsonHealthThumbnailPreview16_default;

  // elos-web/node_modules/carbon-icons-svelte/lib/WifiOff16/WifiOff16.svelte
  function create_if_block52(ctx) {
    let title_1;
    let t;
    return {
      c() {
        title_1 = svg_element("title");
        t = text(ctx[2]);
      },
      m(target, anchor) {
        insert(target, title_1, anchor);
        append(title_1, t);
      },
      p(ctx2, dirty) {
        if (dirty & 4)
          set_data(t, ctx2[2]);
      },
      d(detaching) {
        if (detaching)
          detach(title_1);
      }
    };
  }
  function fallback_block52(ctx) {
    let if_block_anchor;
    let if_block = ctx[2] && create_if_block52(ctx);
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (ctx2[2]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block52(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach(if_block_anchor);
      }
    };
  }
  function create_fragment53(ctx) {
    let svg;
    let circle;
    let path;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[11].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
    const default_slot_or_fallback = default_slot || fallback_block52(ctx);
    let svg_levels = [
      { "data-carbon-icon": "WifiOff16" },
      { xmlns: "http://www.w3.org/2000/svg" },
      { viewBox: "0 0 32 32" },
      { fill: "currentColor" },
      { width: "16" },
      { height: "16" },
      { class: ctx[0] },
      { preserveAspectRatio: "xMidYMid meet" },
      { style: ctx[3] },
      { id: ctx[1] },
      ctx[4]
    ];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    return {
      c() {
        svg = svg_element("svg");
        circle = svg_element("circle");
        path = svg_element("path");
        if (default_slot_or_fallback)
          default_slot_or_fallback.c();
        attr(circle, "cx", "16");
        attr(circle, "cy", "25");
        attr(circle, "r", "2");
        attr(path, "d", "M30 3.4141L28.5859 2 2 28.5859 3.4141 30 14.0962 19.3179a5.9359 5.9359 0 016.01 1.3193L21.52 19.2236a7.9669 7.9669 0 00-5.125-2.2041l3.3875-3.3877a11.9908 11.9908 0 014.5647 2.7647L25.76 14.9829A13.975 13.975 0 0021.334 12.08L24.3308 9.083a17.9364 17.9364 0 014.2546 3.0747L30 10.7432v-.002a20.02 20.02 0 00-4.1895-3.1377zM14.68 13.0776l2.0415-2.0415C16.481 11.0234 16.2437 11 16 11a13.9447 13.9447 0 00-9.771 3.9927l1.4136 1.4136A11.97 11.97 0 0114.68 13.0776zM16 7a17.87 17.87 0 014.2324.5254L21.875 5.8828A19.9537 19.9537 0 002 10.7412v.0225L3.4043 12.168A17.9193 17.9193 0 0116 7z");
        set_svg_attributes(svg, svg_data);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, circle);
        append(svg, path);
        if (default_slot_or_fallback) {
          default_slot_or_fallback.m(svg, null);
        }
        current = true;
        if (!mounted) {
          dispose = [
            listen(svg, "click", ctx[12]),
            listen(svg, "mouseover", ctx[13]),
            listen(svg, "mouseenter", ctx[14]),
            listen(svg, "mouseleave", ctx[15]),
            listen(svg, "keyup", ctx[16]),
            listen(svg, "keydown", ctx[17])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1024)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
          }
        } else {
          if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
            default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
          }
        }
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
          { "data-carbon-icon": "WifiOff16" },
          { xmlns: "http://www.w3.org/2000/svg" },
          { viewBox: "0 0 32 32" },
          { fill: "currentColor" },
          { width: "16" },
          { height: "16" },
          (!current || dirty & 1) && { class: ctx2[0] },
          { preserveAspectRatio: "xMidYMid meet" },
          (!current || dirty & 8) && { style: ctx2[3] },
          (!current || dirty & 2) && { id: ctx2[1] },
          dirty & 16 && ctx2[4]
        ]));
      },
      i(local) {
        if (current)
          return;
        transition_in(default_slot_or_fallback, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot_or_fallback, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(svg);
        if (default_slot_or_fallback)
          default_slot_or_fallback.d(detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance53($$self, $$props, $$invalidate) {
    let ariaLabel;
    let ariaLabelledBy;
    let labelled;
    let attributes;
    let { $$slots: slots = {}, $$scope } = $$props;
    let { class: className = void 0 } = $$props;
    let { id = void 0 } = $$props;
    let { tabindex = void 0 } = $$props;
    let { focusable = false } = $$props;
    let { title: title2 = void 0 } = $$props;
    let { style = void 0 } = $$props;
    function click_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseover_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseenter_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseleave_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keyup_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keydown_handler(event) {
      bubble.call(this, $$self, event);
    }
    $$self.$$set = ($$new_props) => {
      $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
      if ("class" in $$new_props)
        $$invalidate(0, className = $$new_props.class);
      if ("id" in $$new_props)
        $$invalidate(1, id = $$new_props.id);
      if ("tabindex" in $$new_props)
        $$invalidate(5, tabindex = $$new_props.tabindex);
      if ("focusable" in $$new_props)
        $$invalidate(6, focusable = $$new_props.focusable);
      if ("title" in $$new_props)
        $$invalidate(2, title2 = $$new_props.title);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("$$scope" in $$new_props)
        $$invalidate(10, $$scope = $$new_props.$$scope);
    };
    $$self.$$.update = () => {
      $:
        $$invalidate(9, ariaLabel = $$props["aria-label"]);
      $:
        $$invalidate(8, ariaLabelledBy = $$props["aria-labelledby"]);
      if ($$self.$$.dirty & 772) {
        $:
          $$invalidate(7, labelled = ariaLabel || ariaLabelledBy || title2);
      }
      if ($$self.$$.dirty & 992) {
        $:
          $$invalidate(4, attributes = {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-hidden": labelled ? void 0 : true,
            role: labelled ? "img" : void 0,
            focusable: tabindex === "0" ? true : focusable,
            tabindex
          });
      }
    };
    $$props = exclude_internal_props($$props);
    return [
      className,
      id,
      title2,
      style,
      attributes,
      tabindex,
      focusable,
      labelled,
      ariaLabelledBy,
      ariaLabel,
      $$scope,
      slots,
      click_handler,
      mouseover_handler,
      mouseenter_handler,
      mouseleave_handler,
      keyup_handler,
      keydown_handler
    ];
  }
  var WifiOff16 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance53, create_fragment53, safe_not_equal, {
        class: 0,
        id: 1,
        tabindex: 5,
        focusable: 6,
        title: 2,
        style: 3
      });
    }
  };
  var WifiOff16_default = WifiOff16;

  // elos-web/node_modules/carbon-icons-svelte/lib/WifiOff16/index.js
  var WifiOff16_default2 = WifiOff16_default;

  // elos-web/node_modules/carbon-icons-svelte/lib/Wifi16/Wifi16.svelte
  function create_if_block53(ctx) {
    let title_1;
    let t;
    return {
      c() {
        title_1 = svg_element("title");
        t = text(ctx[2]);
      },
      m(target, anchor) {
        insert(target, title_1, anchor);
        append(title_1, t);
      },
      p(ctx2, dirty) {
        if (dirty & 4)
          set_data(t, ctx2[2]);
      },
      d(detaching) {
        if (detaching)
          detach(title_1);
      }
    };
  }
  function fallback_block53(ctx) {
    let if_block_anchor;
    let if_block = ctx[2] && create_if_block53(ctx);
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (ctx2[2]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block53(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach(if_block_anchor);
      }
    };
  }
  function create_fragment54(ctx) {
    let svg;
    let circle;
    let path0;
    let path1;
    let path2;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[11].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
    const default_slot_or_fallback = default_slot || fallback_block53(ctx);
    let svg_levels = [
      { "data-carbon-icon": "Wifi16" },
      { xmlns: "http://www.w3.org/2000/svg" },
      { viewBox: "0 0 32 32" },
      { fill: "currentColor" },
      { width: "16" },
      { height: "16" },
      { class: ctx[0] },
      { preserveAspectRatio: "xMidYMid meet" },
      { style: ctx[3] },
      { id: ctx[1] },
      ctx[4]
    ];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    return {
      c() {
        svg = svg_element("svg");
        circle = svg_element("circle");
        path0 = svg_element("path");
        path1 = svg_element("path");
        path2 = svg_element("path");
        if (default_slot_or_fallback)
          default_slot_or_fallback.c();
        attr(circle, "cx", "16");
        attr(circle, "cy", "25");
        attr(circle, "r", "2");
        attr(path0, "d", "M10.47,19.2334l1.4136,1.4131a5.9688,5.9688,0,0,1,8.2229-.0093L21.52,19.2236a7.9629,7.9629,0,0,0-11.05.01Z");
        attr(path1, "d", "M6.229,14.9927l1.4136,1.4135a11.955,11.955,0,0,1,16.7041-.01L25.76,14.9829a13.9514,13.9514,0,0,0-19.5313.01Z");
        attr(path2, "d", "M30,10.7412a19.94,19.94,0,0,0-28,0v.0225L3.4043,12.168a17.9336,17.9336,0,0,1,25.1811-.01L30,10.7432Z");
        set_svg_attributes(svg, svg_data);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, circle);
        append(svg, path0);
        append(svg, path1);
        append(svg, path2);
        if (default_slot_or_fallback) {
          default_slot_or_fallback.m(svg, null);
        }
        current = true;
        if (!mounted) {
          dispose = [
            listen(svg, "click", ctx[12]),
            listen(svg, "mouseover", ctx[13]),
            listen(svg, "mouseenter", ctx[14]),
            listen(svg, "mouseleave", ctx[15]),
            listen(svg, "keyup", ctx[16]),
            listen(svg, "keydown", ctx[17])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1024)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
          }
        } else {
          if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
            default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
          }
        }
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
          { "data-carbon-icon": "Wifi16" },
          { xmlns: "http://www.w3.org/2000/svg" },
          { viewBox: "0 0 32 32" },
          { fill: "currentColor" },
          { width: "16" },
          { height: "16" },
          (!current || dirty & 1) && { class: ctx2[0] },
          { preserveAspectRatio: "xMidYMid meet" },
          (!current || dirty & 8) && { style: ctx2[3] },
          (!current || dirty & 2) && { id: ctx2[1] },
          dirty & 16 && ctx2[4]
        ]));
      },
      i(local) {
        if (current)
          return;
        transition_in(default_slot_or_fallback, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot_or_fallback, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(svg);
        if (default_slot_or_fallback)
          default_slot_or_fallback.d(detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance54($$self, $$props, $$invalidate) {
    let ariaLabel;
    let ariaLabelledBy;
    let labelled;
    let attributes;
    let { $$slots: slots = {}, $$scope } = $$props;
    let { class: className = void 0 } = $$props;
    let { id = void 0 } = $$props;
    let { tabindex = void 0 } = $$props;
    let { focusable = false } = $$props;
    let { title: title2 = void 0 } = $$props;
    let { style = void 0 } = $$props;
    function click_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseover_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseenter_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseleave_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keyup_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keydown_handler(event) {
      bubble.call(this, $$self, event);
    }
    $$self.$$set = ($$new_props) => {
      $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
      if ("class" in $$new_props)
        $$invalidate(0, className = $$new_props.class);
      if ("id" in $$new_props)
        $$invalidate(1, id = $$new_props.id);
      if ("tabindex" in $$new_props)
        $$invalidate(5, tabindex = $$new_props.tabindex);
      if ("focusable" in $$new_props)
        $$invalidate(6, focusable = $$new_props.focusable);
      if ("title" in $$new_props)
        $$invalidate(2, title2 = $$new_props.title);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("$$scope" in $$new_props)
        $$invalidate(10, $$scope = $$new_props.$$scope);
    };
    $$self.$$.update = () => {
      $:
        $$invalidate(9, ariaLabel = $$props["aria-label"]);
      $:
        $$invalidate(8, ariaLabelledBy = $$props["aria-labelledby"]);
      if ($$self.$$.dirty & 772) {
        $:
          $$invalidate(7, labelled = ariaLabel || ariaLabelledBy || title2);
      }
      if ($$self.$$.dirty & 992) {
        $:
          $$invalidate(4, attributes = {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-hidden": labelled ? void 0 : true,
            role: labelled ? "img" : void 0,
            focusable: tabindex === "0" ? true : focusable,
            tabindex
          });
      }
    };
    $$props = exclude_internal_props($$props);
    return [
      className,
      id,
      title2,
      style,
      attributes,
      tabindex,
      focusable,
      labelled,
      ariaLabelledBy,
      ariaLabel,
      $$scope,
      slots,
      click_handler,
      mouseover_handler,
      mouseenter_handler,
      mouseleave_handler,
      keyup_handler,
      keydown_handler
    ];
  }
  var Wifi16 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance54, create_fragment54, safe_not_equal, {
        class: 0,
        id: 1,
        tabindex: 5,
        focusable: 6,
        title: 2,
        style: 3
      });
    }
  };
  var Wifi16_default = Wifi16;

  // elos-web/node_modules/carbon-icons-svelte/lib/Wifi16/index.js
  var Wifi16_default2 = Wifi16_default;

  // elos-web/node_modules/carbon-icons-svelte/lib/Zip16/Zip16.svelte
  function create_if_block54(ctx) {
    let title_1;
    let t;
    return {
      c() {
        title_1 = svg_element("title");
        t = text(ctx[2]);
      },
      m(target, anchor) {
        insert(target, title_1, anchor);
        append(title_1, t);
      },
      p(ctx2, dirty) {
        if (dirty & 4)
          set_data(t, ctx2[2]);
      },
      d(detaching) {
        if (detaching)
          detach(title_1);
      }
    };
  }
  function fallback_block54(ctx) {
    let if_block_anchor;
    let if_block = ctx[2] && create_if_block54(ctx);
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (ctx2[2]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block54(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach(if_block_anchor);
      }
    };
  }
  function create_fragment55(ctx) {
    let svg;
    let path;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[11].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
    const default_slot_or_fallback = default_slot || fallback_block54(ctx);
    let svg_levels = [
      { "data-carbon-icon": "Zip16" },
      { xmlns: "http://www.w3.org/2000/svg" },
      { viewBox: "0 0 32 32" },
      { fill: "currentColor" },
      { width: "16" },
      { height: "16" },
      { class: ctx[0] },
      { preserveAspectRatio: "xMidYMid meet" },
      { style: ctx[3] },
      { id: ctx[1] },
      ctx[4]
    ];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        if (default_slot_or_fallback)
          default_slot_or_fallback.c();
        attr(path, "d", "M28 9H22V23h2V18h4a2 2 0 002-2V11A2 2 0 0028 9zm0 7H24V11h4zM12 9L12 11 15 11 15 21 12 21 12 23 20 23 20 21 17 21 17 11 20 11 20 9 12 9zM10 9L2 9 2 11 8 11 2 21 2 23 10 23 10 21 4 21 10 11 10 9z");
        set_svg_attributes(svg, svg_data);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        if (default_slot_or_fallback) {
          default_slot_or_fallback.m(svg, null);
        }
        current = true;
        if (!mounted) {
          dispose = [
            listen(svg, "click", ctx[12]),
            listen(svg, "mouseover", ctx[13]),
            listen(svg, "mouseenter", ctx[14]),
            listen(svg, "mouseleave", ctx[15]),
            listen(svg, "keyup", ctx[16]),
            listen(svg, "keydown", ctx[17])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1024)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
          }
        } else {
          if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
            default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
          }
        }
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
          { "data-carbon-icon": "Zip16" },
          { xmlns: "http://www.w3.org/2000/svg" },
          { viewBox: "0 0 32 32" },
          { fill: "currentColor" },
          { width: "16" },
          { height: "16" },
          (!current || dirty & 1) && { class: ctx2[0] },
          { preserveAspectRatio: "xMidYMid meet" },
          (!current || dirty & 8) && { style: ctx2[3] },
          (!current || dirty & 2) && { id: ctx2[1] },
          dirty & 16 && ctx2[4]
        ]));
      },
      i(local) {
        if (current)
          return;
        transition_in(default_slot_or_fallback, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot_or_fallback, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(svg);
        if (default_slot_or_fallback)
          default_slot_or_fallback.d(detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance55($$self, $$props, $$invalidate) {
    let ariaLabel;
    let ariaLabelledBy;
    let labelled;
    let attributes;
    let { $$slots: slots = {}, $$scope } = $$props;
    let { class: className = void 0 } = $$props;
    let { id = void 0 } = $$props;
    let { tabindex = void 0 } = $$props;
    let { focusable = false } = $$props;
    let { title: title2 = void 0 } = $$props;
    let { style = void 0 } = $$props;
    function click_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseover_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseenter_handler(event) {
      bubble.call(this, $$self, event);
    }
    function mouseleave_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keyup_handler(event) {
      bubble.call(this, $$self, event);
    }
    function keydown_handler(event) {
      bubble.call(this, $$self, event);
    }
    $$self.$$set = ($$new_props) => {
      $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
      if ("class" in $$new_props)
        $$invalidate(0, className = $$new_props.class);
      if ("id" in $$new_props)
        $$invalidate(1, id = $$new_props.id);
      if ("tabindex" in $$new_props)
        $$invalidate(5, tabindex = $$new_props.tabindex);
      if ("focusable" in $$new_props)
        $$invalidate(6, focusable = $$new_props.focusable);
      if ("title" in $$new_props)
        $$invalidate(2, title2 = $$new_props.title);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("$$scope" in $$new_props)
        $$invalidate(10, $$scope = $$new_props.$$scope);
    };
    $$self.$$.update = () => {
      $:
        $$invalidate(9, ariaLabel = $$props["aria-label"]);
      $:
        $$invalidate(8, ariaLabelledBy = $$props["aria-labelledby"]);
      if ($$self.$$.dirty & 772) {
        $:
          $$invalidate(7, labelled = ariaLabel || ariaLabelledBy || title2);
      }
      if ($$self.$$.dirty & 992) {
        $:
          $$invalidate(4, attributes = {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-hidden": labelled ? void 0 : true,
            role: labelled ? "img" : void 0,
            focusable: tabindex === "0" ? true : focusable,
            tabindex
          });
      }
    };
    $$props = exclude_internal_props($$props);
    return [
      className,
      id,
      title2,
      style,
      attributes,
      tabindex,
      focusable,
      labelled,
      ariaLabelledBy,
      ariaLabel,
      $$scope,
      slots,
      click_handler,
      mouseover_handler,
      mouseenter_handler,
      mouseleave_handler,
      keyup_handler,
      keydown_handler
    ];
  }
  var Zip16 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance55, create_fragment55, safe_not_equal, {
        class: 0,
        id: 1,
        tabindex: 5,
        focusable: 6,
        title: 2,
        style: 3
      });
    }
  };
  var Zip16_default = Zip16;

  // elos-web/node_modules/carbon-icons-svelte/lib/Zip16/index.js
  var Zip16_default2 = Zip16_default;

  // elos-web/src/lib/icons.js
  var icons = {
    "alarm": Alarm16_default2,
    "cli": Terminal16_default2,
    "code": Code16_default2,
    "list": CollapseCategories16_default2,
    "table": CrossTab16_default2,
    "image": Image16_default2,
    "files": Categories16_default2,
    "packages": ModelAlt16_default2,
    "education": Education16_default2,
    "profile": UserAvatarFilled16_default2,
    "settings": Settings16_default2,
    "preferences": AudioConsole16_default2,
    "polls": DeployRules16_default2,
    "status-hidden": AccessibilityColor16_default2,
    "status-visible": AccessibilityColorFilled16_default2,
    "status-checkmark": CheckmarkFilled16_default2,
    "status-closemark": CloseFilled16_default2,
    "status-online": Wifi16_default2,
    "status-offline": WifiOff16_default2,
    "status-pin": Pin16_default2,
    "action-add": AddFilled16_default2,
    "action-popout": Launch16_default2,
    "action-fullscreen": Maximize16_default2,
    "action-login": Login16_default2,
    "action-logout": Exit16_default2,
    "action-open-code": CodeReference16_default2,
    "task-add": AlarmAdd16_default2,
    "task-remove": AlarmSubtract16_default2,
    "task-merge": Compare16_default2,
    "apis": Api_116_default2,
    "apps": App16_default2,
    "transript": ClosedCaptionAlt16_default2,
    "download": Download16_default2,
    "upload": Export16_default2,
    "directions": Crossroads16_default2,
    "cut": Cut16_default2,
    "delete": Delete16_default2,
    "jpg": Jpg16_default2,
    "json": Json16_default2,
    "pdf": Pdf16_default2,
    "txt": Txt16_default2,
    "zip": Zip16_default2,
    "night-mode": Awake16_default2,
    "view-modes": Switcher16_default2,
    "view-mode-layers": Layers16_default2,
    "view-mode-workspaces": WatsonHealthStackedScrolling_116_default2,
    "view-mode-1": ViewMode_116_default2,
    "view-mode-2": ViewMode_216_default2,
    "view-mode-3": WatsonHealthCutInHalf16_default2,
    "view-mode-4": WatsonHealthThumbnailPreview16_default2,
    "menu": Menu16_default2,
    "sql": Sql16_default2,
    "tools": ToolsAlt16_default2,
    "warning": Warning16_default2
  };

  // elos-web/src/lib/layoutAction.js
  var dataStore = writable({});
  function _layoutAction(node, items) {
    let _items = writable(items);
    _items.subscribe((val) => {
      if (!val || val.length === 0 || !val.dirty)
        return;
      let __items = [];
      for (let x = 0; x < val.add.length; x++) {
        let pendingItem = val.add[x];
        __items.push(add(pendingItem[0], pendingItem[1]));
      }
      _items.update((n) => ({ ...n.items, add: [], dirty: false }));
    });
    const onAdd = (val) => {
      console.log("did onAdd", val);
      let item2 = val.detail;
      if (item2 && item2.event && item2.target in objects) {
        objects[item2.target].$on(item2.event.name, item2.event.callback);
      }
    };
    const remove = (item2) => {
      items = items.filter((value) => value.target !== item2);
      if (items.length > 0) {
        delete objects[item2];
      }
    };
    function togglePanel(e) {
      _togglePanel(e.detail.name);
    }
    function _togglePanel(itemName) {
      let _layout = items.filter((value) => value.target === itemName);
      if (_layout.length > 0)
        remove(itemName);
      else
        add(itemName);
    }
    ;
    const dispatch = createEventDispatcher();
    const clickHandler = (e) => {
      e.preventDefault();
      dispatch("activateItem", {
        source: node.name,
        data: item
      });
    };
    return {
      update(newVal) {
        console.log("widget did get update", newVal);
      },
      destroy() {
        console.log("widget was destroyed");
      }
    };
  }

  // elos-web/src/Options.svelte
  function get_each_context(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[2] = list[i];
    return child_ctx;
  }
  function create_else_block(ctx) {
    let t_value = ctx[2].title + "";
    let t;
    return {
      c() {
        t = text(t_value);
      },
      m(target, anchor) {
        insert(target, t, anchor);
      },
      p(ctx2, dirty) {
        if (dirty & 1 && t_value !== (t_value = ctx2[2].title + ""))
          set_data(t, t_value);
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(t);
      }
    };
  }
  function create_if_block55(ctx) {
    let switch_instance;
    let switch_instance_anchor;
    let current;
    var switch_value = icons[ctx[2].icon];
    function switch_props(ctx2) {
      return {};
    }
    if (switch_value) {
      switch_instance = new switch_value(switch_props(ctx));
    }
    return {
      c() {
        if (switch_instance)
          create_component(switch_instance.$$.fragment);
        switch_instance_anchor = empty();
      },
      m(target, anchor) {
        if (switch_instance) {
          mount_component(switch_instance, target, anchor);
        }
        insert(target, switch_instance_anchor, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        if (switch_value !== (switch_value = icons[ctx2[2].icon])) {
          if (switch_instance) {
            group_outros();
            const old_component = switch_instance;
            transition_out(old_component.$$.fragment, 1, 0, () => {
              destroy_component(old_component, 1);
            });
            check_outros();
          }
          if (switch_value) {
            switch_instance = new switch_value(switch_props(ctx2));
            create_component(switch_instance.$$.fragment);
            transition_in(switch_instance.$$.fragment, 1);
            mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
          } else {
            switch_instance = null;
          }
        } else if (switch_value) {
        }
      },
      i(local) {
        if (current)
          return;
        if (switch_instance)
          transition_in(switch_instance.$$.fragment, local);
        current = true;
      },
      o(local) {
        if (switch_instance)
          transition_out(switch_instance.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(switch_instance_anchor);
        if (switch_instance)
          destroy_component(switch_instance, detaching);
      }
    };
  }
  function create_each_block(key_1, ctx) {
    let a;
    let div;
    let current_block_type_index;
    let if_block;
    let _layoutAction_action;
    let t;
    let current;
    let mounted;
    let dispose;
    const if_block_creators = [create_if_block55, create_else_block];
    const if_blocks = [];
    function select_block_type(ctx2, dirty) {
      if (ctx2[2].icon)
        return 0;
      return 1;
    }
    current_block_type_index = select_block_type(ctx, -1);
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    return {
      key: key_1,
      first: null,
      c() {
        a = element("a");
        div = element("div");
        if_block.c();
        t = space();
        attr(a, "href", "#");
        attr(a, "class", "tag svelte-15zcbkn");
        this.first = a;
      },
      m(target, anchor) {
        insert(target, a, anchor);
        append(a, div);
        if_blocks[current_block_type_index].m(div, null);
        append(a, t);
        current = true;
        if (!mounted) {
          dispose = action_destroyer(_layoutAction_action = _layoutAction.call(null, div, ctx[2]));
          mounted = true;
        }
      },
      p(new_ctx, dirty) {
        ctx = new_ctx;
        let previous_block_index = current_block_type_index;
        current_block_type_index = select_block_type(ctx, dirty);
        if (current_block_type_index === previous_block_index) {
          if_blocks[current_block_type_index].p(ctx, dirty);
        } else {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
            if_block.c();
          } else {
            if_block.p(ctx, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
        if (_layoutAction_action && is_function(_layoutAction_action.update) && dirty & 1)
          _layoutAction_action.update.call(null, ctx[2]);
      },
      i(local) {
        if (current)
          return;
        transition_in(if_block);
        current = true;
      },
      o(local) {
        transition_out(if_block);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(a);
        if_blocks[current_block_type_index].d();
        mounted = false;
        dispose();
      }
    };
  }
  function create_fragment56(ctx) {
    let div;
    let each_blocks = [];
    let each_1_lookup = new Map();
    let current;
    let each_value = Object.entries(ctx[0]);
    const get_key = (ctx2) => ctx2[2][0];
    for (let i = 0; i < each_value.length; i += 1) {
      let child_ctx = get_each_context(ctx, each_value, i);
      let key = get_key(child_ctx);
      each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
    }
    return {
      c() {
        div = element("div");
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        attr(div, "id", "nav");
        attr(div, "class", "sidenav svelte-15zcbkn");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].m(div, null);
        }
        current = true;
      },
      p(ctx2, [dirty]) {
        if (dirty & 1) {
          each_value = Object.entries(ctx2[0]);
          group_outros();
          each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block, null, get_each_context);
          check_outros();
        }
      },
      i(local) {
        if (current)
          return;
        for (let i = 0; i < each_value.length; i += 1) {
          transition_in(each_blocks[i]);
        }
        current = true;
      },
      o(local) {
        for (let i = 0; i < each_blocks.length; i += 1) {
          transition_out(each_blocks[i]);
        }
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(div);
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].d();
        }
      }
    };
  }
  function instance56($$self, $$props, $$invalidate) {
    const dispatch = createEventDispatcher();
    let { config = {} } = $$props;
    onMount(async () => {
      console.log("Options mounted");
    });
    $$self.$$set = ($$props2) => {
      if ("config" in $$props2)
        $$invalidate(0, config = $$props2.config);
    };
    return [config];
  }
  var Options = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance56, create_fragment56, safe_not_equal, { config: 0 });
    }
  };
  var Options_default = Options;

  // elos-web/src/Toolbar.svelte
  function create_fragment57(ctx) {
    let section;
    return {
      c() {
        section = element("section");
      },
      m(target, anchor) {
        insert(target, section, anchor);
      },
      p: noop,
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(section);
      }
    };
  }
  function instance57($$self, $$props, $$invalidate) {
    let { item: item2 = {} } = $$props;
    let { options = {} } = $$props;
    const interpret_item = (item3) => {
      return {};
    };
    onMount(async () => {
      console.log("Toolbar mounted");
    });
    $$self.$$set = ($$props2) => {
      if ("item" in $$props2)
        $$invalidate(1, item2 = $$props2.item);
      if ("options" in $$props2)
        $$invalidate(0, options = $$props2.options);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 2) {
        $:
          $$invalidate(0, options = interpret_item(item2));
      }
    };
    return [options, item2];
  }
  var Toolbar = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance57, create_fragment57, safe_not_equal, { item: 1, options: 0 });
    }
  };
  var Toolbar_default = Toolbar;

  // elos-web/src/config/parameters.js
  var workspaceConfig = {
    loadedAt: new Date()
  };

  // elos-web/src/lib/stores.js
  var cacheFor = (name, otherwise = {}) => {
    let ret = localStorage.getItem(`${name}_cache`);
    return ret ? JSON.parse(ret) : otherwise;
  };
  var workspaceWritable = writable(workspaceConfig);
  var historyWritable2 = writable(cacheFor("history", []));
  var trackedWritable = writable(cacheFor("tracked", {}));
  var logWritable = writable(cacheFor("log", {}));
  var filesWritable = writable(cacheFor("files"));
  var layoutItemsWritable = writable(cacheFor("layoutItems", { items: [], add: [] }));
  var profileWritable = writable(cacheFor("profile"));
  var todoWritable = writable(cacheFor("todo", []));
  var pollsWritable = writable(cacheFor("polls", []));
  var registeredActions2 = writable({});
  var commandOptionsWritable = writable({
    polls: () => cacheFor("polls"),
    todo: () => cacheFor("todo"),
    workspace: () => cacheFor("workspace"),
    history: () => cacheFor("history"),
    tracked: () => cacheFor("tracked"),
    log: () => cacheFor("log"),
    layoutItems: () => cacheFor("layoutItems"),
    profile: () => cacheFor("profile"),
    actions: () => registeredActions2,
    links: () => writable({}),
    files: () => cacheFor("files", {
      files: [],
      filetype: "md",
      keywords: "",
      pageNum: 1,
      pageSize: 10,
      dirty: false
    })
  });
  var stores = {
    todo: todoWritable,
    polls: pollsWritable,
    history: historyWritable2,
    tracked: trackedWritable,
    log: logWritable,
    layoutItems: layoutItemsWritable,
    workspace: workspaceWritable,
    files: filesWritable,
    profile: profileWritable,
    actions: registeredActions2,
    commandOptions: commandOptionsWritable
  };
  for (let name in stores) {
    stores[name].subscribe((val) => {
      if (val !== void 0 && val !== "undefined") {
        localStorage.setItem(`${name}_cache`, JSON.stringify(val));
      }
    });
  }

  // elos-web/src/lib/commandLine.js
  var splitInputs = (val) => {
    return val.split(":");
  };
  function commandLine(node, store) {
    console.log("[init][action] commandLine", node, store);
    console.log("[->action]", get_store_value(store).actions());
    const dispatch = createEventDispatcher();
    store.subscribe((val) => {
      console.log("[action] commandLine got update", val);
    });
    const enterKeyPressed = (event) => {
      return event.keyCode === 13;
    };
    const inputTypes = {
      cmd: (args) => {
      },
      pref: (args) => {
      },
      panel: (args) => {
        get_store_value(registeredActions)[args[0]](args[1]);
      },
      do: (args) => {
      }
    };
    const submitCommand = (e) => {
      if (!enterKeyPressed(e)) {
        return e;
      }
      let cmd = node.value;
      let parts = splitInputs(cmd);
      if (parts.length === 0) {
      } else if (parts.length === 1 && parts[0] === cmd) {
      } else {
        let _cmdWord = parts[0];
        let _cmdArgs = parts[1].split(" ");
        let _cmdFunc = inputTypes[_cmdWord];
        if (!_cmdFunc) {
          console.log("no func for", _cmdWord, _cmdArgs);
        }
        let _cmdResult = _cmdFunc(_cmdArgs);
        console.log("cmd result was", _cmdWord, _cmdArgs, _cmdResult);
        historyWritable.update((n) => [...n || [], [_cmdWord, _cmdArgs, _cmdResult]]);
      }
    };
    node.placeholder = "'do:tutorial' to get started";
    node.addEventListener("keypress", submitCommand);
    return {
      update(newFile) {
        console.log("commandline got update", newFile);
      },
      destroy() {
        console.log("commandline is destroyed");
      }
    };
  }

  // elos-web/src/lib/apis.js
  var handleResponse = async (response) => {
    if (response.ok) {
      return await response.json();
    } else {
      console.log("HTTP-Error: ", response.status);
      return null;
    }
  };
  var _fetch = async (url, params2 = {}) => {
    let baseUrl = "http://localhost:3000";
    let _url = new URL(url, baseUrl);
    for (let arg in params2) {
      _url.searchParams.append(arg, params2[arg]);
    }
    let response = await fetch(_url);
    return await handleResponse(response);
  };
  var _send = async (url, params2 = {}) => {
    let baseUrl = "http://localhost:3000";
    let _url = new URL(url, baseUrl);
    params2.method = "POST";
    console.log("fetching", _url);
    let response = await fetch(_url, {
      method: "POST",
      headers: {
        "Accept": "application/json",
        "Content-Type": "application/json"
      },
      body: JSON.stringify(params2)
    });
    console.log("fetched", response);
    return handleResponse(response);
  };
  var getCurrentActiveTab = async () => {
    return browser.tabs.query({
      active: true,
      windowId: browser.windows.WINDOW_ID_CURRENT
    });
  };
  var fileList = async (params2) => {
    _fetch("/api/file/search", params2).then((data) => {
      stores.files.update((n) => ({ ...n, ...data, dirty: false }));
      console.log("updated filelist", data, params2);
    }).catch((err) => {
      console.log("failed to update filelist", err, params2);
    });
  };
  var findMatches = (options, searchTerm) => options.filter((option) => {
    const foundIndex = option.toLowerCase().indexOf(searchTerm.toLowerCase());
    return foundIndex > -1;
  });
  var spanWrapSearchTerm = (option, foundIndex, searchTermLength) => {
    const searchTerm = option.slice(foundIndex, foundIndex + searchTermLength);
    return `<span>${searchTerm}</span>`;
  };
  var boldSearchTerm = (option, searchTerm) => {
    const lowercaseOption = option.toLowerCase();
    const lowercaseSearchTerm = searchTerm.toLowerCase();
    let foundIndex = lowercaseOption.indexOf(lowercaseSearchTerm);
    let html = "";
    if (!searchTerm)
      return option;
    while (foundIndex !== -1) {
      const previousIndex = foundIndex;
      const searchTermLength = searchTerm.length;
      if (!html) {
        html = option.slice(0, foundIndex);
      }
      html += spanWrapSearchTerm(option, foundIndex, searchTermLength);
      foundIndex = lowercaseOption.indexOf(lowercaseSearchTerm, foundIndex + 1);
      if (foundIndex !== -1) {
        html += option.slice(previousIndex + searchTermLength, foundIndex);
      } else {
        html += option.slice(previousIndex + searchTermLength);
      }
    }
    return html || option;
  };
  var selectedFile = (item2) => item2 ? item2["locations"][0].split("/Volumes/ARCHIVE/")[1] : "";
  var selectedFilePath = (item2) => `/api/load?filepath=${selectedFile(item2)}`;
  function openFile(e) {
    console.log("open file", e);
    let data = e.detail;
    return _openFile(data);
  }
  function _openFile(data) {
    let target;
    if (["md", "txt", "json", "py", "js"].indexOf(data["file.ext"]) != -1) {
      target = "panel-editor";
    } else if (data["file.ext"] === "pdf") {
      target = "panel-pdf";
    } else if (["jpg", "gif", "png"].indexOf(data["file.ext"]) != -1) {
      target = "panel-gallery";
    }
    if (target !== void 0) {
      let options = {
        target_name: target,
        props: {
          data: selectedFilePath(data),
          language: data["file.ext"] || "markdown",
          theme: "vs-light",
          features: ["wordWrap"]
        }
      };
      console.log("data for open file", options);
      stores.layoutItems.update((n) => {
        n.add.push([target, options]);
        n.dirty = true;
        return n;
      });
    }
  }
  function _updateLog(val) {
    const date = dateStringFromDate(new Date());
    const fmtDate = clockFormatter.format(new Date());
    let _event = { ...val, at: [] };
    stores.log.update((n) => {
      let name = _event.name;
      if (name && !n[name]) {
        n[name] = _event;
      }
      n[name].at.push([Math.floor(Date.now() / 1e3), date, fmtDate]);
      return n;
    });
  }
  function updateLog(e) {
    let val = e.detail;
    _updateLog(val);
  }
  function updateFiletype(e) {
    let typeName = e.detail.name;
    _updateFiletype(typeName);
  }
  function _updateFiletype(typeName) {
    if (!typeName)
      return;
    stores.files.update((obj) => {
      obj.filetype = typeName;
      return obj;
    });
  }
  stores.layoutItems.subscribe((val) => {
    console.log("[update] stores.layoutItems update", val);
  });
  stores.files.subscribe((val) => {
    console.log("[update] stores.files update", val);
    if (val && val !== "undefined" && val.dirty) {
      fileList((({ files, dirty, ...rest }) => rest)(val));
    }
  });
  stores.workspace.subscribe((val) => {
    console.log("[update] stores.workspace update", val);
  });
  stores.log.subscribe((val) => {
    console.log("[update] stores.log update", val, Object.keys(val).length);
  });
  stores.history.subscribe((val) => {
    console.log("[update] stores.history update", val);
  });
  stores.profile.subscribe((val) => {
    console.log("[update] stores.profile update", val);
  });
  stores.actions.subscribe((val) => {
    console.log("[update] registeredActions update", val);
  });

  // elos-web/src/AutoComplete.svelte
  function get_each_context2(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[26] = list[i];
    child_ctx[28] = i;
    return child_ctx;
  }
  function create_else_block2(ctx) {
    let div1;
    let div0;
    let t;
    let ul;
    let each_blocks = [];
    let each_1_lookup = new Map();
    let mounted;
    let dispose;
    let each_value = ctx[10];
    const get_key = (ctx2) => ctx2[26];
    for (let i = 0; i < each_value.length; i += 1) {
      let child_ctx = get_each_context2(ctx, each_value, i);
      let key = get_key(child_ctx);
      each_1_lookup.set(key, each_blocks[i] = create_each_block2(key, child_ctx));
    }
    return {
      c() {
        div1 = element("div");
        div0 = element("div");
        t = space();
        ul = element("ul");
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        attr(div0, "class", "click-catcher svelte-z3l8tr");
        attr(ul, "class", "results-list svelte-z3l8tr");
        toggle_class(ul, "border-none", !ctx[10].length);
        attr(div1, "class", "svelte-autocomplete-results-container svelte-z3l8tr");
        attr(div1, "aria-hidden", ctx[8]);
        attr(div1, "autocapitalize", "none");
        attr(div1, "autocomplete", "off");
        attr(div1, "aria-autocomplete", "list");
        attr(div1, "role", "combobox");
        attr(div1, "aria-expanded", ctx[8]);
        toggle_class(div1, "showAutocompleteResults", ctx[8]);
      },
      m(target, anchor) {
        insert(target, div1, anchor);
        append(div1, div0);
        append(div1, t);
        append(div1, ul);
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].m(ul, null);
        }
        if (!mounted) {
          dispose = listen(div0, "click", ctx[13]);
          mounted = true;
        }
      },
      p(ctx2, dirty) {
        if (dirty & 134673) {
          each_value = ctx2[10];
          each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, ul, destroy_block, create_each_block2, null, get_each_context2);
        }
        if (dirty & 1024) {
          toggle_class(ul, "border-none", !ctx2[10].length);
        }
        if (dirty & 256) {
          attr(div1, "aria-hidden", ctx2[8]);
        }
        if (dirty & 256) {
          attr(div1, "aria-expanded", ctx2[8]);
        }
        if (dirty & 256) {
          toggle_class(div1, "showAutocompleteResults", ctx2[8]);
        }
      },
      d(detaching) {
        if (detaching)
          detach(div1);
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].d();
        }
        mounted = false;
        dispose();
      }
    };
  }
  function create_if_block56(ctx) {
    let span;
    let t;
    let span_resize_listener;
    let mounted;
    let dispose;
    return {
      c() {
        span = element("span");
        t = text(ctx[5]);
        attr(span, "class", "search-modifier svelte-z3l8tr");
        add_render_callback(() => ctx[22].call(span));
      },
      m(target, anchor) {
        insert(target, span, anchor);
        append(span, t);
        span_resize_listener = add_resize_listener(span, ctx[22].bind(span));
        if (!mounted) {
          dispose = listen(span, "click", ctx[14]);
          mounted = true;
        }
      },
      p(ctx2, dirty) {
        if (dirty & 32)
          set_data(t, ctx2[5]);
      },
      d(detaching) {
        if (detaching)
          detach(span);
        span_resize_listener();
        mounted = false;
        dispose();
      }
    };
  }
  function create_if_block_1(ctx) {
    let span;
    return {
      c() {
        span = element("span");
        span.textContent = "Search";
        attr(span, "class", "search-label svelte-z3l8tr");
      },
      m(target, anchor) {
        insert(target, span, anchor);
      },
      d(detaching) {
        if (detaching)
          detach(span);
      }
    };
  }
  function create_each_block2(key_1, ctx) {
    let li;
    let t0;
    let html_tag;
    let raw_value = boldSearchTerm(ctx[26], ctx[4]) + "";
    let t1;
    let li_aria_selected_value;
    let li_aria_label_value;
    let mounted;
    let dispose;
    let if_block = (ctx[28] >= ctx[0].length || ctx[11][ctx[26]]) && create_if_block_1(ctx);
    function click_handler() {
      return ctx[23](ctx[26]);
    }
    return {
      key: key_1,
      first: null,
      c() {
        li = element("li");
        if (if_block)
          if_block.c();
        t0 = space();
        html_tag = new HtmlTag();
        t1 = space();
        html_tag.a = t1;
        attr(li, "aria-selected", li_aria_selected_value = ctx[28] === ctx[9]);
        attr(li, "aria-label", li_aria_label_value = ctx[26]);
        attr(li, "role", "option");
        attr(li, "class", "svelte-z3l8tr");
        toggle_class(li, "modifier", ctx[11][ctx[26]]);
        toggle_class(li, "highlight", ctx[28] === ctx[9]);
        this.first = li;
      },
      m(target, anchor) {
        insert(target, li, anchor);
        if (if_block)
          if_block.m(li, null);
        append(li, t0);
        html_tag.m(raw_value, li);
        append(li, t1);
        if (!mounted) {
          dispose = listen(li, "click", click_handler);
          mounted = true;
        }
      },
      p(new_ctx, dirty) {
        ctx = new_ctx;
        if (ctx[28] >= ctx[0].length || ctx[11][ctx[26]]) {
          if (if_block) {
          } else {
            if_block = create_if_block_1(ctx);
            if_block.c();
            if_block.m(li, t0);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
        if (dirty & 1040 && raw_value !== (raw_value = boldSearchTerm(ctx[26], ctx[4]) + ""))
          html_tag.p(raw_value);
        if (dirty & 1536 && li_aria_selected_value !== (li_aria_selected_value = ctx[28] === ctx[9])) {
          attr(li, "aria-selected", li_aria_selected_value);
        }
        if (dirty & 1024 && li_aria_label_value !== (li_aria_label_value = ctx[26])) {
          attr(li, "aria-label", li_aria_label_value);
        }
        if (dirty & 3072) {
          toggle_class(li, "modifier", ctx[11][ctx[26]]);
        }
        if (dirty & 1536) {
          toggle_class(li, "highlight", ctx[28] === ctx[9]);
        }
      },
      d(detaching) {
        if (detaching)
          detach(li);
        if (if_block)
          if_block.d();
        mounted = false;
        dispose();
      }
    };
  }
  function create_fragment58(ctx) {
    let div;
    let input;
    let t;
    let div_class_value;
    let mounted;
    let dispose;
    function select_block_type(ctx2, dirty) {
      if (ctx2[5])
        return create_if_block56;
      return create_else_block2;
    }
    let current_block_type = select_block_type(ctx, -1);
    let if_block = current_block_type(ctx);
    return {
      c() {
        div = element("div");
        input = element("input");
        t = space();
        if_block.c();
        attr(input, "class", "svelte-z3l8tr");
        toggle_class(input, "modified-search", ctx[5]);
        attr(div, "class", div_class_value = "svelte-autocomplete " + ctx[1] + " svelte-z3l8tr");
        set_style(div, "--theme", ctx[2]);
        set_style(div, "--highlightTextColor", ctx[3]);
        set_style(div, "--modifier-label-width", ctx[6] + 8 + "px");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        append(div, input);
        set_input_value(input, ctx[4]);
        ctx[21](input);
        append(div, t);
        if_block.m(div, null);
        if (!mounted) {
          dispose = [
            listen(input, "input", ctx[20]),
            listen(input, "keydown", ctx[16]),
            listen(input, "input", ctx[15]),
            listen(input, "click", ctx[12])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (dirty & 16 && input.value !== ctx2[4]) {
          set_input_value(input, ctx2[4]);
        }
        if (dirty & 32) {
          toggle_class(input, "modified-search", ctx2[5]);
        }
        if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block.d(1);
          if_block = current_block_type(ctx2);
          if (if_block) {
            if_block.c();
            if_block.m(div, null);
          }
        }
        if (dirty & 2 && div_class_value !== (div_class_value = "svelte-autocomplete " + ctx2[1] + " svelte-z3l8tr")) {
          attr(div, "class", div_class_value);
        }
        if (dirty & 4) {
          set_style(div, "--theme", ctx2[2]);
        }
        if (dirty & 8) {
          set_style(div, "--highlightTextColor", ctx2[3]);
        }
        if (dirty & 64) {
          set_style(div, "--modifier-label-width", ctx2[6] + 8 + "px");
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(div);
        ctx[21](null);
        if_block.d();
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance58($$self, $$props, $$invalidate) {
    let matches;
    let { onSubmit = () => {
    } } = $$props;
    let { options = [] } = $$props;
    let { searchModifiers = [] } = $$props;
    let { className = "" } = $$props;
    let { themeColor = "#333" } = $$props;
    let { highlightTextColor = "#fff" } = $$props;
    const MODIFIERS = searchModifiers.reduce((acc, cur) => {
      acc[cur] = true;
      return acc;
    }, {});
    let results = [...options, ...searchModifiers];
    let searchModifier = "";
    let modifierLabelWidth;
    let inputRef;
    let showAutocompleteResults = false;
    let highlightIndex = 0;
    let selectedValue = "";
    const showResults = () => {
      $$invalidate(9, highlightIndex = 0);
      $$invalidate(8, showAutocompleteResults = true);
    };
    const hideResults = () => $$invalidate(8, showAutocompleteResults = false);
    const removeSearchModifier = () => {
      $$invalidate(5, searchModifier = "");
      inputRef.focus();
    };
    const handleInput = () => {
      if (!searchModifier) {
        showResults();
      }
    };
    const handleKeyDown = ({ key }) => {
      switch (key) {
        case "Escape":
          hideResults();
          break;
        case "ArrowUp":
          if (showAutocompleteResults && highlightIndex === 0) {
            $$invalidate(9, highlightIndex = matches.length - 1);
          } else {
            $$invalidate(9, highlightIndex -= 1);
          }
          break;
        case "ArrowDown":
          if (!selectedValue && !showAutocompleteResults) {
            showResults();
            break;
          }
          if (showAutocompleteResults && highlightIndex === matches.length - 1) {
            $$invalidate(9, highlightIndex = 0);
          } else {
            $$invalidate(9, highlightIndex += 1);
          }
          break;
        case "Tab":
          hideResults();
          break;
        case "Enter":
          const highlightedOption = matches[highlightIndex];
          const value = highlightedOption || selectedValue;
          handleSubmit(value);
          break;
        case "Backspace":
          if (!selectedValue) {
            removeSearchModifier();
          }
          break;
        default:
          return;
      }
    };
    const handleSubmit = (value) => {
      if (!value)
        return;
      if (searchModifiers.includes(value)) {
        $$invalidate(5, searchModifier = value);
      } else {
        onSubmit(value, searchModifier);
        removeSearchModifier();
      }
      $$invalidate(4, selectedValue = "");
      hideResults();
    };
    const highlight = (index) => index === highlightIndex;
    function input_input_handler() {
      selectedValue = this.value;
      $$invalidate(4, selectedValue);
    }
    function input_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        inputRef = $$value;
        $$invalidate(7, inputRef);
      });
    }
    function span_elementresize_handler() {
      modifierLabelWidth = this.clientWidth;
      $$invalidate(6, modifierLabelWidth);
    }
    const click_handler = (match) => handleSubmit(match);
    $$self.$$set = ($$props2) => {
      if ("onSubmit" in $$props2)
        $$invalidate(18, onSubmit = $$props2.onSubmit);
      if ("options" in $$props2)
        $$invalidate(0, options = $$props2.options);
      if ("searchModifiers" in $$props2)
        $$invalidate(19, searchModifiers = $$props2.searchModifiers);
      if ("className" in $$props2)
        $$invalidate(1, className = $$props2.className);
      if ("themeColor" in $$props2)
        $$invalidate(2, themeColor = $$props2.themeColor);
      if ("highlightTextColor" in $$props2)
        $$invalidate(3, highlightTextColor = $$props2.highlightTextColor);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 16) {
        $:
          $$invalidate(10, matches = findMatches(results, selectedValue));
      }
    };
    return [
      options,
      className,
      themeColor,
      highlightTextColor,
      selectedValue,
      searchModifier,
      modifierLabelWidth,
      inputRef,
      showAutocompleteResults,
      highlightIndex,
      matches,
      MODIFIERS,
      showResults,
      hideResults,
      removeSearchModifier,
      handleInput,
      handleKeyDown,
      handleSubmit,
      onSubmit,
      searchModifiers,
      input_input_handler,
      input_binding,
      span_elementresize_handler,
      click_handler
    ];
  }
  var AutoComplete = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance58, create_fragment58, safe_not_equal, {
        onSubmit: 18,
        options: 0,
        searchModifiers: 19,
        className: 1,
        themeColor: 2,
        highlightTextColor: 3
      });
    }
  };
  var AutoComplete_default = AutoComplete;

  // elos-web/src/CommandBar.svelte
  function create_fragment59(ctx) {
    let section;
    let span;
    let autocomplete;
    let commandLine_action;
    let current;
    let mounted;
    let dispose;
    autocomplete = new AutoComplete_default({
      props: {
        options: ctx[0],
        searchModifiers: ctx[2],
        onSubmit: ctx[3],
        themeColor: ctx[1][4]
      }
    });
    return {
      c() {
        section = element("section");
        span = element("span");
        create_component(autocomplete.$$.fragment);
        attr(span, "class", "header svelte-1furqj2");
        attr(section, "class", "title svelte-1furqj2");
      },
      m(target, anchor) {
        insert(target, section, anchor);
        append(section, span);
        mount_component(autocomplete, span, null);
        current = true;
        if (!mounted) {
          dispose = action_destroyer(commandLine_action = commandLine.call(null, span, commandOptionsWritable));
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        const autocomplete_changes = {};
        if (dirty & 1)
          autocomplete_changes.options = ctx2[0];
        autocomplete.$set(autocomplete_changes);
      },
      i(local) {
        if (current)
          return;
        transition_in(autocomplete.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(autocomplete.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(section);
        destroy_component(autocomplete);
        mounted = false;
        dispose();
      }
    };
  }
  function instance59($$self, $$props, $$invalidate) {
    const tagColors = ["#000", "#3298dc", "#f14668", "#48c774", "#3273dc"];
    const searchModifiers = ["cmd", "files", "do", "panel", "profile", "settings"];
    let { options = [] } = $$props;
    let { selectedOptions = [] } = $$props;
    commandOptionsWritable.subscribe((val) => {
      console.log("history", val.history());
    });
    const _handleSubmit = (selectedValue, category) => {
      if (options.indexOf(selectedValue) === -1) {
        $$invalidate(0, options = [...options, selectedValue]);
      }
      if (selectedOptions.indexOf(selectedValue) === -1) {
        $$invalidate(4, selectedOptions = [...selectedOptions, selectedValue]);
      }
    };
    const handleSubmit = (e) => {
      _handleSubmit(e.selected, searchModifiers);
    };
    onMount(async () => {
      console.log("CommandBar mounted");
    });
    $$self.$$set = ($$props2) => {
      if ("options" in $$props2)
        $$invalidate(0, options = $$props2.options);
      if ("selectedOptions" in $$props2)
        $$invalidate(4, selectedOptions = $$props2.selectedOptions);
    };
    return [options, tagColors, searchModifiers, handleSubmit, selectedOptions];
  }
  var CommandBar = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance59, create_fragment59, safe_not_equal, { options: 0, selectedOptions: 4 });
    }
  };
  var CommandBar_default = CommandBar;

  // elos-web/src/Clock.svelte
  function create_fragment60(ctx) {
    let section;
    let span;
    let clockAction_action;
    let mounted;
    let dispose;
    return {
      c() {
        section = element("section");
        span = element("span");
        attr(span, "class", "datetime svelte-137h0nn");
        attr(section, "class", "title svelte-137h0nn");
      },
      m(target, anchor) {
        insert(target, section, anchor);
        append(section, span);
        if (!mounted) {
          dispose = action_destroyer(clockAction_action = clockAction.call(null, span));
          mounted = true;
        }
      },
      p: noop,
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(section);
        mounted = false;
        dispose();
      }
    };
  }
  function instance60($$self) {
    onMount(async () => {
      console.log("Clock mounted");
    });
    return [];
  }
  var Clock = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance60, create_fragment60, safe_not_equal, {});
    }
  };
  var Clock_default = Clock;

  // elos-web/src/lib/profileEdit.js
  function profileEdit(node, params2) {
    const dispatch = createEventDispatcher();
    const openProfile = (e) => {
      e.preventDefault();
      console.log("got command submit", e);
    };
    node.addEventListener("click", openProfile);
    return {
      update(newFile) {
        console.log("profileEdit got update", newFile);
      },
      destroy() {
        console.log("profileEdit is destroyed");
        node.removeListener("click", openProfile);
      }
    };
  }

  // elos-web/src/Profile.svelte
  function create_fragment61(ctx) {
    let section;
    let img;
    let img_src_value;
    let profileEdit_action;
    let mounted;
    let dispose;
    return {
      c() {
        section = element("section");
        img = element("img");
        if (!src_url_equal(img.src, img_src_value = "img/img_avatar.png"))
          attr(img, "src", img_src_value);
        attr(img, "alt", "Avatar");
        attr(img, "class", "avatar svelte-j9o6c4");
        attr(section, "class", "title svelte-j9o6c4");
      },
      m(target, anchor) {
        insert(target, section, anchor);
        append(section, img);
        if (!mounted) {
          dispose = action_destroyer(profileEdit_action = profileEdit.call(null, img));
          mounted = true;
        }
      },
      p: noop,
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(section);
        mounted = false;
        dispose();
      }
    };
  }
  function instance61($$self, $$props, $$invalidate) {
    let { settings = {
      "default": 0,
      "persona_name": "random",
      "learning_method": "text-only"
    } } = $$props;
    onMount(async () => {
      console.log("Profile mounted");
    });
    $$self.$$set = ($$props2) => {
      if ("settings" in $$props2)
        $$invalidate(0, settings = $$props2.settings);
    };
    return [settings];
  }
  var Profile = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance61, create_fragment61, safe_not_equal, { settings: 0 });
    }
  };
  var Profile_default = Profile;

  // elos-web/src/config/layout.js
  var menuItems = [
    {
      name: "panel-actionmenu",
      value: { icon: "view-mode-2", highlight: "Menu of Browser Actions" },
      group: "1"
    },
    {
      name: "panel-location-ops",
      value: { icon: "view-mode-1", highlight: "Location Tagging" },
      group: "1"
    },
    {
      name: "panel-timer",
      value: { icon: "task-add", highlight: "Pomodoro Timer" },
      group: "1"
    },
    {
      name: "panel-entryform",
      value: { icon: "action-add", highlight: "Add Data" },
      group: "1"
    },
    {
      name: "panel-todo",
      value: { icon: "list", highlight: "TODO List" },
      group: "1"
    },
    {
      name: "panel-journal",
      value: { icon: "polls", highlight: "Journal" },
      group: "1"
    },
    {
      name: "panel-locations",
      value: { icon: "view-mode-3", highlight: "File/URL locations" },
      group: "2"
    }
  ];

  // elos-web/src/config/panels.js
  var layoutConfig = {
    panelGap: 5,
    columnMultiplier: 6,
    columnCount: 100,
    rowHeight: 65
  };
  var panelTypes = {
    "panel-mainmenu": {
      target: "panel-mainmenu",
      name: "mainmenu",
      w: layoutConfig.columnCount,
      h: 2,
      componentName: "selectlist",
      event: { name: "menuToggle", callback: "togglePanel" },
      props: {
        eventName: "menuToggle",
        items: menuItems,
        transform: (e) => {
          return e.value.icon;
        }
      }
    },
    "panel-actionmenu": {
      target: "panel-actionmenu",
      name: "actionmenu",
      w: layoutConfig.columnCount,
      h: 3,
      componentName: "actionmenu"
    },
    "panel-location-ops": {
      target: "panel-location-ops",
      name: "location-ops",
      w: layoutConfig.columnCount,
      h: 6,
      componentName: "location_ops"
    },
    "panel-web-players": {
      target: "panel-web-players",
      name: "web_players",
      w: layoutConfig.columnCount,
      h: 5,
      componentName: "web_players",
      event: {
        name: "filterType",
        callback: "updateLocations"
      },
      props: {
        eventName: "playPause",
        transform: (e) => e
      }
    },
    "panel-commandbar": {
      target: "panel-commandbar",
      name: "commandbar",
      w: layoutConfig.columnCount,
      h: 1,
      componentName: "commandbar",
      props: { overflow: "visible" }
    },
    "panel-layouts": {
      target: "toolbar",
      name: "toolbar",
      w: layoutConfig.columnCount,
      h: 1,
      componentName: "toolbar"
    },
    "panel-clock": {
      target: "panel-clock",
      name: "clock",
      w: layoutConfig.columnCount,
      h: 1,
      componentName: "clock",
      props: {
        timezone: "PST"
      }
    },
    "panel-timer": {
      target: "panel-timer",
      name: "timer",
      w: layoutConfig.columnCount,
      h: 4,
      componentName: "timer"
    },
    "panel-todo": {
      target: "panel-todo",
      name: "todo",
      w: layoutConfig.columnCount,
      componentName: "todo",
      props: {}
    },
    "panel-cando-list": {
      target: "panel-cando-list",
      name: "cando-list",
      componentName: "rotatelist",
      w: layoutConfig.columnCount,
      h: 8,
      props: {
        dataKey: "baitlist",
        dataStore: "profile"
      }
    },
    "panel-entryform": {
      target: "panel-entryform",
      name: "entryform",
      w: layoutConfig.columnCount,
      h: 8,
      componentName: "entryform",
      props: {
        dataStore: "profile"
      }
    },
    "panel-tracked": {
      target: "panel-tracked",
      name: "tracked",
      w: layoutConfig.columnCount,
      h: 8,
      componentName: "tracker",
      props: {
        dataStore: "tracked"
      }
    },
    "panel-drop": {
      target: "panel-drop",
      name: "drop",
      w: layoutConfig.columnCount,
      h: 8,
      componentName: "drop",
      props: {
        dataStore: "files"
      }
    },
    "panel-eventhistory": {
      target: "panel-eventhistory",
      name: "eventhistory",
      w: layoutConfig.columnCount,
      componentName: "itemlist",
      props: {
        readonly: true,
        dataStore: "history",
        transform: (x) => `${x.name} @ ${x.at[1]} `,
        transforms: {
          title: (x) => `${x.name} @ ${x.at[1]} `,
          api: (x) => x
        }
      }
    },
    "panel-actionhistory": {
      target: "panel-actionhistory",
      name: "actionhistory",
      w: layoutConfig.columnCount,
      componentName: "chart",
      props: {
        readonly: true,
        dataStore: "log"
      }
    },
    "panel-tags": {
      target: "panel-tags",
      name: "tags",
      w: layoutConfig.columnCount,
      componentName: "selectlist",
      event: {
        name: "filterType",
        callback: "updateLocations"
      },
      props: {
        eventName: "filterType",
        source: "/api/analysis/tags",
        transform: (e) => e
      }
    },
    "panel-locations": {
      target: "panel-locations",
      name: "locations",
      w: layoutConfig.columnCount,
      componentName: "itemlist",
      props: {
        readonly: true,
        dataStore: "links",
        dataSourcePath: "/api/location/search",
        titleKey: "label",
        transform: (x) => x
      }
    },
    "panel-journal": {
      target: "panel-journal",
      name: "journal",
      w: layoutConfig.columnCount,
      componentName: "expandlist",
      props: {
        readonly: true,
        dataStore: "profile",
        dataKey: "metrics",
        titleKey: "title",
        transform: (x) => x
      }
    },
    "panel-filetypes": {
      target: "panel-filetypes",
      name: "filetypes",
      w: layoutConfig.columnCount,
      componentName: "selectlist",
      event: {
        name: "filterType",
        callback: "updateFiletype"
      },
      props: {
        eventName: "filterType",
        source: "/api/file/types",
        transform: (e) => {
          return `${e.name} (${e.value})`;
        }
      }
    },
    "panel-files": {
      target: "panel-files",
      name: "files",
      w: layoutConfig.columnCount,
      toolbar: {},
      componentName: "files",
      event: { name: "openFile", callback: "openFile" }
    },
    "panel-panelhistory": {
      target: "panel-panelhistory",
      name: "history",
      w: layoutConfig.columnCount,
      componentName: "itemlist"
    },
    "panel-metrics": {
      target: "panel-metrics",
      name: "metrics",
      w: layoutConfig.columnCount,
      componentName: "datagrid",
      props: {
        dataStore: "profile",
        dataKey: "metrics"
      }
    },
    "panel-pdf": {
      target: "panel-pdf",
      name: "pdf",
      w: layoutConfig.columnCount,
      componentName: "pdf"
    },
    "panel-editor": {
      target: "panel-editor",
      name: "editor",
      w: layoutConfig.columnCount,
      componentName: "editor"
    },
    "panel-gallery": {
      target: "panel-gallery",
      name: "gallery",
      w: layoutConfig.columnCount,
      componentName: "imagegallery",
      props: {
        dataStore: "files",
        dataSourcePath: "/api/file/search"
      }
    },
    "panel-pkgindex": {
      target: "panel-pkgindex",
      name: "pkgindex",
      w: layoutConfig.columnCount,
      componentName: "pkgindex"
    },
    "panel-create": {
      target: "panel-create",
      name: "create",
      w: layoutConfig.columnCount,
      componentName: "pkgcreate"
    }
  };

  // elos-web/src/ItemList.svelte
  function get_each_context3(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[13] = list[i];
    return child_ctx;
  }
  function create_else_block_1(ctx) {
    let p;
    return {
      c() {
        p = element("p");
        p.textContent = "No Data";
        attr(p, "class", "svelte-yvmoz");
      },
      m(target, anchor) {
        insert(target, p, anchor);
      },
      p: noop,
      d(detaching) {
        if (detaching)
          detach(p);
      }
    };
  }
  function create_if_block57(ctx) {
    let ul;
    let t;
    let each_blocks = [];
    let each_1_lookup = new Map();
    let if_block = !ctx[0] && create_if_block_3(ctx);
    let each_value = ctx[5];
    const get_key = (ctx2) => ctx2[13].name;
    for (let i = 0; i < each_value.length; i += 1) {
      let child_ctx = get_each_context3(ctx, each_value, i);
      let key = get_key(child_ctx);
      each_1_lookup.set(key, each_blocks[i] = create_each_block3(key, child_ctx));
    }
    let each_1_else = null;
    if (!each_value.length) {
      each_1_else = create_else_block3(ctx);
    }
    return {
      c() {
        ul = element("ul");
        if (if_block)
          if_block.c();
        t = space();
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        if (each_1_else) {
          each_1_else.c();
        }
        attr(ul, "id", "task-list");
        attr(ul, "class", "svelte-yvmoz");
      },
      m(target, anchor) {
        insert(target, ul, anchor);
        if (if_block)
          if_block.m(ul, null);
        append(ul, t);
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].m(ul, null);
        }
        if (each_1_else) {
          each_1_else.m(ul, null);
        }
      },
      p(ctx2, dirty) {
        if (!ctx2[0]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block_3(ctx2);
            if_block.c();
            if_block.m(ul, t);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
        if (dirty & 242) {
          each_value = ctx2[5];
          each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, ul, destroy_block, create_each_block3, null, get_each_context3);
          if (each_value.length) {
            if (each_1_else) {
              each_1_else.d(1);
              each_1_else = null;
            }
          } else if (!each_1_else) {
            each_1_else = create_else_block3(ctx2);
            each_1_else.c();
            each_1_else.m(ul, null);
          }
        }
      },
      d(detaching) {
        if (detaching)
          detach(ul);
        if (if_block)
          if_block.d();
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].d();
        }
        if (each_1_else)
          each_1_else.d();
      }
    };
  }
  function create_if_block_3(ctx) {
    let li;
    let div;
    let form;
    let input;
    let t0;
    let button;
    let t1;
    let mounted;
    let dispose;
    return {
      c() {
        li = element("li");
        div = element("div");
        form = element("form");
        input = element("input");
        t0 = space();
        button = element("button");
        t1 = text(ctx[2]);
        attr(input, "type", "text");
        attr(input, "id", "task-input");
        attr(input, "placeholder", "");
        attr(input, "class", "svelte-yvmoz");
        attr(button, "type", "submit");
        attr(button, "class", "svelte-yvmoz");
        attr(form, "class", "svelte-yvmoz");
        attr(div, "id", "add-btn");
        attr(div, "class", "svelte-yvmoz");
        attr(li, "class", "svelte-yvmoz");
      },
      m(target, anchor) {
        insert(target, li, anchor);
        append(li, div);
        append(div, form);
        append(form, input);
        append(form, t0);
        append(form, button);
        append(button, t1);
        if (!mounted) {
          dispose = listen(form, "submit", prevent_default(function() {
            if (is_function(ctx[3]))
              ctx[3].apply(this, arguments);
          }));
          mounted = true;
        }
      },
      p(new_ctx, dirty) {
        ctx = new_ctx;
        if (dirty & 4)
          set_data(t1, ctx[2]);
      },
      d(detaching) {
        if (detaching)
          detach(li);
        mounted = false;
        dispose();
      }
    };
  }
  function create_else_block3(ctx) {
    let li;
    return {
      c() {
        li = element("li");
        li.textContent = "No Data";
        attr(li, "class", "svelte-yvmoz");
      },
      m(target, anchor) {
        insert(target, li, anchor);
      },
      d(detaching) {
        if (detaching)
          detach(li);
      }
    };
  }
  function create_if_block_2(ctx) {
    let span;
    let t_value = ctx[1](ctx[13]) + "";
    let t;
    return {
      c() {
        span = element("span");
        t = text(t_value);
        attr(span, "class", "svelte-yvmoz");
      },
      m(target, anchor) {
        insert(target, span, anchor);
        append(span, t);
      },
      p(ctx2, dirty) {
        if (dirty & 34 && t_value !== (t_value = ctx2[1](ctx2[13]) + ""))
          set_data(t, t_value);
      },
      d(detaching) {
        if (detaching)
          detach(span);
      }
    };
  }
  function create_if_block_12(ctx) {
    let span;
    let t_value = ctx[13][ctx[4]] + "";
    let t;
    return {
      c() {
        span = element("span");
        t = text(t_value);
        attr(span, "class", "svelte-yvmoz");
      },
      m(target, anchor) {
        insert(target, span, anchor);
        append(span, t);
      },
      p(ctx2, dirty) {
        if (dirty & 48 && t_value !== (t_value = ctx2[13][ctx2[4]] + ""))
          set_data(t, t_value);
      },
      d(detaching) {
        if (detaching)
          detach(span);
      }
    };
  }
  function create_each_block3(key_1, ctx) {
    let li;
    let t0;
    let span;
    let t1_value = "\xD7";
    let t1;
    let span_name_value;
    let t2;
    let mounted;
    let dispose;
    function select_block_type_1(ctx2, dirty) {
      if (ctx2[4])
        return create_if_block_12;
      if (ctx2[1])
        return create_if_block_2;
    }
    let current_block_type = select_block_type_1(ctx, -1);
    let if_block = current_block_type && current_block_type(ctx);
    function click_handler() {
      return ctx[11](ctx[13]);
    }
    return {
      key: key_1,
      first: null,
      c() {
        li = element("li");
        if (if_block)
          if_block.c();
        t0 = space();
        span = element("span");
        t1 = text(t1_value);
        t2 = space();
        attr(span, "class", "close svelte-yvmoz");
        attr(span, "name", span_name_value = ctx[13].name);
        attr(li, "class", "item svelte-yvmoz");
        toggle_class(li, "checked", ctx[13].checked);
        this.first = li;
      },
      m(target, anchor) {
        insert(target, li, anchor);
        if (if_block)
          if_block.m(li, null);
        append(li, t0);
        append(li, span);
        append(span, t1);
        append(li, t2);
        if (!mounted) {
          dispose = [
            listen(span, "click", ctx[7]),
            listen(li, "click", click_handler)
          ];
          mounted = true;
        }
      },
      p(new_ctx, dirty) {
        ctx = new_ctx;
        if (current_block_type === (current_block_type = select_block_type_1(ctx, dirty)) && if_block) {
          if_block.p(ctx, dirty);
        } else {
          if (if_block)
            if_block.d(1);
          if_block = current_block_type && current_block_type(ctx);
          if (if_block) {
            if_block.c();
            if_block.m(li, t0);
          }
        }
        if (dirty & 32 && span_name_value !== (span_name_value = ctx[13].name)) {
          attr(span, "name", span_name_value);
        }
        if (dirty & 32) {
          toggle_class(li, "checked", ctx[13].checked);
        }
      },
      d(detaching) {
        if (detaching)
          detach(li);
        if (if_block) {
          if_block.d();
        }
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function create_fragment62(ctx) {
    let section;
    function select_block_type(ctx2, dirty) {
      if (ctx2[5])
        return create_if_block57;
      return create_else_block_1;
    }
    let current_block_type = select_block_type(ctx, -1);
    let if_block = current_block_type(ctx);
    return {
      c() {
        section = element("section");
        if_block.c();
        attr(section, "class", "log-body svelte-yvmoz");
      },
      m(target, anchor) {
        insert(target, section, anchor);
        if_block.m(section, null);
      },
      p(ctx2, [dirty]) {
        if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block.d(1);
          if_block = current_block_type(ctx2);
          if (if_block) {
            if_block.c();
            if_block.m(section, null);
          }
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(section);
        if_block.d();
      }
    };
  }
  function instance62($$self, $$props, $$invalidate) {
    const dispatch = createEventDispatcher();
    let { dataSourcePath = null } = $$props;
    let { dataStore: dataStore2 = null } = $$props;
    let { dataKey = null } = $$props;
    let { readonly = false } = $$props;
    let { transform = (x) => x } = $$props;
    let queue = [];
    let { buttonName = "Add" } = $$props;
    let { inputEvent = null } = $$props;
    let { titleKey = null } = $$props;
    function didClick(e) {
      console.log("did click", e);
      dispatch("didClick", e);
    }
    function close(e) {
      var div = e.target.parentElement;
      div.style.display = "none";
      dispatch("removed", e);
    }
    onMount(async () => {
      console.log("ItemList mounted");
      if (dataStore2) {
        console.log("dataStore mounted in ItemList");
        dataStore2.subscribe((val) => {
          if (val) {
            console.log("ItemList update", val);
            if (dataKey) {
              $$invalidate(5, queue = val[dataKey]);
            } else {
              $$invalidate(5, queue = val);
            }
          } else {
            $$invalidate(5, queue = []);
          }
        });
      }
      if (dataSourcePath) {
        console.log("running dataSourcePath fetch", dataSourcePath);
        $$invalidate(5, queue = (await _fetch(dataSourcePath)).result);
        console.log("dataSourcePath GOT", queue);
        if (dataStore2) {
          dataStore2.update((n) => queue);
        }
      }
    });
    const click_handler = (_item) => didClick(_item);
    $$self.$$set = ($$props2) => {
      if ("dataSourcePath" in $$props2)
        $$invalidate(8, dataSourcePath = $$props2.dataSourcePath);
      if ("dataStore" in $$props2)
        $$invalidate(9, dataStore2 = $$props2.dataStore);
      if ("dataKey" in $$props2)
        $$invalidate(10, dataKey = $$props2.dataKey);
      if ("readonly" in $$props2)
        $$invalidate(0, readonly = $$props2.readonly);
      if ("transform" in $$props2)
        $$invalidate(1, transform = $$props2.transform);
      if ("buttonName" in $$props2)
        $$invalidate(2, buttonName = $$props2.buttonName);
      if ("inputEvent" in $$props2)
        $$invalidate(3, inputEvent = $$props2.inputEvent);
      if ("titleKey" in $$props2)
        $$invalidate(4, titleKey = $$props2.titleKey);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 12) {
        $:
          $$invalidate(0, readonly = !buttonName || !inputEvent);
      }
      if ($$self.$$.dirty & 16) {
        $:
          titleKey;
      }
    };
    return [
      readonly,
      transform,
      buttonName,
      inputEvent,
      titleKey,
      queue,
      didClick,
      close,
      dataSourcePath,
      dataStore2,
      dataKey,
      click_handler
    ];
  }
  var ItemList = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance62, create_fragment62, safe_not_equal, {
        dataSourcePath: 8,
        dataStore: 9,
        dataKey: 10,
        readonly: 0,
        transform: 1,
        buttonName: 2,
        inputEvent: 3,
        titleKey: 4
      });
    }
  };
  var ItemList_default = ItemList;

  // elos-web/src/Todo.svelte
  function create_fragment63(ctx) {
    let section;
    let p;
    let button;
    let t1;
    let itemlist;
    let current;
    let mounted;
    let dispose;
    itemlist = new ItemList_default({
      props: {
        dataStore: ctx[0],
        buttonName: "Add",
        titleKey: "name",
        inputEvent: ctx[1]
      }
    });
    itemlist.$on("didClick", updateLog);
    itemlist.$on("removed", ctx[2]);
    return {
      c() {
        section = element("section");
        p = element("p");
        button = element("button");
        button.textContent = "Clear";
        t1 = space();
        create_component(itemlist.$$.fragment);
        attr(button, "id", "clear");
      },
      m(target, anchor) {
        insert(target, section, anchor);
        append(section, p);
        append(p, button);
        append(section, t1);
        mount_component(itemlist, section, null);
        current = true;
        if (!mounted) {
          dispose = listen(button, "click", clearLog);
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        const itemlist_changes = {};
        if (dirty & 1)
          itemlist_changes.dataStore = ctx2[0];
        itemlist.$set(itemlist_changes);
      },
      i(local) {
        if (current)
          return;
        transition_in(itemlist.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(itemlist.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(section);
        destroy_component(itemlist);
        mounted = false;
        dispose();
      }
    };
  }
  function clearLog(e) {
  }
  function instance63($$self, $$props, $$invalidate) {
    let { dataStore: dataStore2 = stores.todo } = $$props;
    let template1 = [
      {
        type: "action",
        category: "drink",
        name: "Coffee",
        value: "count",
        checked: false
      },
      {
        type: "action",
        category: "exercise",
        name: "Walk",
        value: "duration",
        checked: false
      },
      {
        type: "action",
        category: "exercise",
        name: "Ring Fit",
        value: "duration",
        checked: false
      },
      {
        type: "action",
        category: "project",
        name: "eLOS",
        value: "duration",
        checked: false
      },
      {
        type: "action",
        category: "work",
        name: "Work",
        value: "duration",
        checked: false
      }
    ];
    let todoItems = [];
    function addEntry(e) {
      console.log("adding entry to listqueue:", e);
      let name = document.getElementById("task-input").value;
      if (dataStore2) {
        dataStore2.update((n) => [
          ...n,
          {
            name,
            checked: false,
            eventClick: (_n2) => {
              return _n2.filter((value) => value.name === name);
            }
          }
        ]);
      } else {
        console.log("[todo.py] NO DATASTORE");
      }
    }
    function removeEntry(e) {
      console.log("removing entry from listqueue:", e);
      var name = e.detail.name;
      dataStore2.update((n) => _n.filter((value) => value.name !== name));
    }
    onMount(async () => {
      console.log("Todo mounted");
      dataStore2.update((n) => [...n.length > 0 ? n : todoItems]);
    });
    $$self.$$set = ($$props2) => {
      if ("dataStore" in $$props2)
        $$invalidate(0, dataStore2 = $$props2.dataStore);
    };
    return [dataStore2, addEntry, removeEntry];
  }
  var Todo = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance63, create_fragment63, safe_not_equal, { dataStore: 0 });
    }
  };
  var Todo_default = Todo;

  // elos-web/src/lib/render.js
  var import_dompurify = __toModule(require_purify());
  var import_readability = __toModule(require_readability());
  function renderReadable(doc2, options) {
    let cleanDoc = import_dompurify.default.sanitize(doc2);
    return new import_readability.default(cleanDoc, options).parse();
  }
  function renderJSON(doc2) {
    let reader = renderReadable(doc2.cloneNode(true), {
      debug: true,
      keepClasses: false
    });
    return {
      type: "article",
      saveTo: "file",
      title: reader.title,
      url: reader.siteName,
      length: reader.length,
      exerpt: reader.exerpt,
      author: reader.byline,
      html: reader.content,
      text: reader.textContent
    };
  }

  // elos-web/src/ActionMenu.svelte
  function create_fragment64(ctx) {
    let section;
    let div1;
    let t1;
    let a0;
    let br0;
    let t3;
    let a1;
    let br1;
    let t5;
    let p0;
    let button0;
    let t7;
    let p1;
    let button1;
    let t9;
    let p2;
    let button2;
    let mounted;
    let dispose;
    return {
      c() {
        section = element("section");
        div1 = element("div");
        div1.innerHTML = `<div class="text-section-header">Window manipulator</div>`;
        t1 = space();
        a0 = element("a");
        a0.textContent = "Move Top Right";
        br0 = element("br");
        t3 = space();
        a1 = element("a");
        a1.textContent = "Resize window to 768x1024";
        br1 = element("br");
        t5 = space();
        p0 = element("p");
        button0 = element("button");
        button0.textContent = "Copy Selected Tabs";
        t7 = space();
        p1 = element("p");
        button1 = element("button");
        button1.textContent = "Save Reader PDF";
        t9 = space();
        p2 = element("p");
        button2 = element("button");
        button2.textContent = "Download Video";
        attr(div1, "class", "panel-section panel-section-header");
        attr(a0, "href", "#");
        attr(a0, "class", "svelte-14m6orm");
        attr(a1, "href", "#");
        attr(a1, "class", "svelte-14m6orm");
        attr(button0, "id", "copy-tabs");
        attr(button1, "id", "save-pdf");
        attr(button2, "id", "dl-video");
      },
      m(target, anchor) {
        insert(target, section, anchor);
        append(section, div1);
        append(section, t1);
        append(section, a0);
        append(section, br0);
        append(section, t3);
        append(section, a1);
        append(section, br1);
        append(section, t5);
        append(section, p0);
        append(p0, button0);
        append(section, t7);
        append(section, p1);
        append(p1, button1);
        append(section, t9);
        append(section, p2);
        append(p2, button2);
        if (!mounted) {
          dispose = [
            listen(a0, "click", prevent_default(ctx[2])),
            listen(a1, "click", prevent_default(ctx[3])),
            listen(button0, "click", doSelectedCopy),
            listen(button1, "click", ctx[1]),
            listen(button2, "click", ctx[0])
          ];
          mounted = true;
        }
      },
      p: noop,
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(section);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function updateClipboard(newClip) {
    navigator.clipboard.writeText(newClip).then(function() {
      console.log("copied succesfully: " + newClip);
    }, function() {
      console.log("failed to copy " + newClip);
    });
  }
  async function doSelectedCopy(e) {
    let tabs2 = await browser.tabs.query({
      highlighted: true,
      windowId: browser.windows.WINDOW_ID_CURRENT
    });
    console.log("doing selected copy:", browser.windows.WINDOW_ID_CURRENT, tabs2);
    updateClipboard(tabs2.map((x) => x.title + "," + x.url).join("\n"));
  }
  function instance64($$self, $$props, $$invalidate) {
    const doDownloadVideo = (params2) => {
      getCurrentActiveTab.then((tab) => {
        return _send("api/action/download/video", { uri: tab[0].url });
      }).then(printSuccess).catch(printFailure);
    };
    async function addMetric() {
      let elements = document.getElementById("metrics").elements;
      let entry = elements.map((x) => {
      });
      await _send("api/db/files", { table_name: "metric" });
    }
    let enabledCourseSites = ["coursera.org", "edx.org", "udemy.com", "khanacademy.org"];
    let registered = null;
    async function registerScript(message) {
      let hosts = message.hosts;
      let code = message.code;
      if (registered) {
        registered.unregister();
      }
      registered = await browser.contentScripts.register({
        matches: hosts,
        js: [{ code }],
        runAt: "document_idle"
      });
    }
    async function extractReaderText(e) {
      browser.runtime.onMessage.addListener(registerScript);
      let pageData = renderJSON(document);
      console.log("doing reader text:", pageData);
      if (tabs.isArticle && !tabs.isInReaderMode) {
        await browser.tabs.toggleReaderMode();
        await _send("api/analysis/data", renderJSON());
        await browser.tabs.toggleReaderMode();
      } else {
        await browser.tabs.saveAsPDF({});
      }
    }
    const window_update_move_topright = () => {
      browser.windows.update(browser.windows.WINDOW_ID_CURRENT, { left: 0, top: 0 });
    };
    const window_update_size_768 = () => {
      browser.windows.update(browser.windows.WINDOW_ID_CURRENT, { width: 768, height: 1024 });
    };
    const window_update = () => {
      browser.windows.update(browser.windows.WINDOW_ID_CURRENT, { state: "minimized" });
    };
    const window_create = () => {
      browser.windows.create({
        type: "detached_panel",
        incognito: true
      }).then(() => {
        console.log("The detached panel has been created");
      });
    };
    const window_stash = () => {
      browser.tabs.query({
        highlighted: true,
        windowId: browser.windows.WINDOW_ID_CURRENT
      }).then((tabs2) => {
        console.log("doing selected copy:", windows.WINDOW_ID_CURRENT, tabs2);
        return tabs2.map((x) => x.title + "," + x.url).join("\n");
      }).then(() => {
        browser.windows.remove(windows.WINDOW_ID_CURRENT);
      });
    };
    const window_resize_all = () => {
      browser.windows.getAll().then((windows2) => {
        for (var item2 of windows2) {
          browser.windows.update(item2.id, { width: 1024, height: 768 });
        }
      });
    };
    const window_preface_title = () => {
      browser.windows.update(browser.windows.WINDOW_ID_CURRENT, { titlePreface: "Preface | " });
    };
    onMount(async () => {
      console.log("ActionMenu mounted");
    });
    return [
      doDownloadVideo,
      extractReaderText,
      window_update_move_topright,
      window_update_size_768
    ];
  }
  var ActionMenu = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance64, create_fragment64, safe_not_equal, { doDownloadVideo: 0 });
    }
    get doDownloadVideo() {
      return this.$$.ctx[0];
    }
  };
  var ActionMenu_default = ActionMenu;

  // elos-web/src/SpotifyControls.svelte
  function create_fragment65(ctx) {
    let section;
    return {
      c() {
        section = element("section");
      },
      m(target, anchor) {
        insert(target, section, anchor);
      },
      p: noop,
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(section);
      }
    };
  }
  var SpotifyControls = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, null, create_fragment65, safe_not_equal, {});
    }
  };
  var SpotifyControls_default = SpotifyControls;

  // elos-web/src/LocationOps.svelte
  function create_fragment66(ctx) {
    let section;
    let ul;
    let li;
    let input;
    let t0;
    let button;
    let mounted;
    let dispose;
    return {
      c() {
        section = element("section");
        ul = element("ul");
        li = element("li");
        input = element("input");
        t0 = space();
        button = element("button");
        button.textContent = "Add";
        attr(input, "id", "tag_name");
        attr(input, "type", "text");
        attr(input, "name", "name");
        attr(button, "class", "add");
        attr(li, "class", "new-tag svelte-152z19a");
        attr(ul, "class", "panel svelte-152z19a");
      },
      m(target, anchor) {
        insert(target, section, anchor);
        append(section, ul);
        append(ul, li);
        append(li, input);
        append(li, t0);
        append(li, button);
        if (!mounted) {
          dispose = listen(button, "click", ctx[0]);
          mounted = true;
        }
      },
      p: noop,
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(section);
        mounted = false;
        dispose();
      }
    };
  }
  function instance65($$self) {
    async function sendLink(tagName) {
      browser.tabs.query({ currentWindow: true, active: true }).then(async (tabs2) => {
        let params2 = {
          label: tabs2[0].title,
          uri: tabs2[0].url,
          tag: tagName
        };
        console.log("SAVING", params2);
        let result = await _send("api/location/add", params2);
        console.log("DONE SAVING", result);
      }, console.error);
    }
    async function sendTag() {
      let newTagButton = document.querySelector("#tag_name");
      console.log("Sending new tag: ", newTagButton.value);
      let tagName = newTagButton.value;
      _send("api/analysis/tag", { name: tagName }).then(() => {
        renderTag(tagName);
      });
    }
    async function loadTags() {
      let results = await _fetch("api/analysis/tag");
      console.log("[remote][load#tags] ", results);
      for (let tag of results.names) {
        renderTag(tag[1]);
      }
    }
    function renderTag(tagName) {
      let tagContainer = document.querySelector(".panel");
      let tag = document.createElement("li");
      let tagLabel = document.createElement("p");
      tag.setAttribute("class", "tag");
      tagLabel.textContent = tagName;
      tag.appendChild(tagLabel);
      tagContainer.appendChild(tag);
      tagLabel.addEventListener("click", async () => {
        if (await sendLink(tagName) === 200) {
        }
      });
      return tag;
    }
    onMount(async () => {
      console.log("LocationOps mounted");
      await loadTags();
    });
    return [sendTag];
  }
  var LocationOps = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance65, create_fragment66, safe_not_equal, {});
    }
  };
  var LocationOps_default = LocationOps;

  // elos-web/src/WebPlayers.svelte
  function create_fragment67(ctx) {
    let section;
    let itemlist;
    let updating_items;
    let current;
    function itemlist_items_binding(value) {
      ctx[3](value);
    }
    let itemlist_props = { readonly: "true", titleKey: "title" };
    if (ctx[0] !== void 0) {
      itemlist_props.items = ctx[0];
    }
    itemlist = new ItemList_default({ props: itemlist_props });
    binding_callbacks.push(() => bind(itemlist, "items", itemlist_items_binding));
    itemlist.$on("didClick", ctx[1]);
    return {
      c() {
        section = element("section");
        create_component(itemlist.$$.fragment);
      },
      m(target, anchor) {
        insert(target, section, anchor);
        mount_component(itemlist, section, null);
        current = true;
      },
      p(ctx2, [dirty]) {
        const itemlist_changes = {};
        if (!updating_items && dirty & 1) {
          updating_items = true;
          itemlist_changes.items = ctx2[0];
          add_flush_callback(() => updating_items = false);
        }
        itemlist.$set(itemlist_changes);
      },
      i(local) {
        if (current)
          return;
        transition_in(itemlist.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(itemlist.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(section);
        destroy_component(itemlist);
      }
    };
  }
  function instance66($$self, $$props, $$invalidate) {
    let showType = ["audio", "video"];
    let items = [];
    let playingTabs = [];
    const movePlayingToCurrent = (e) => {
      let id = e.target.tabId;
    };
    const sendPlayPause = () => {
      console.log("sending playpause");
    };
    const updatePlaying = () => {
      browser.tabs.query({ audible: true }).then((tabs2) => {
        console.log("querying audible:", tabs2);
        $$invalidate(2, playingTabs = tabs2.map((tab) => {
          return {
            tabId: tab.id,
            windowId: tab.windowId,
            muted: tab.mutedInfo.muted,
            title: tab.title,
            url: tab.url
          };
        }));
      });
    };
    onMount(async () => {
      console.log("WebPlayers mounted");
      updatePlaying();
    });
    function itemlist_items_binding(value) {
      items = value;
      $$invalidate(0, items), $$invalidate(2, playingTabs);
    }
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 4) {
        $:
          $$invalidate(0, items = [...playingTabs, ...[]]);
      }
    };
    return [items, sendPlayPause, playingTabs, itemlist_items_binding];
  }
  var WebPlayers = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance66, create_fragment67, safe_not_equal, {});
    }
  };
  var WebPlayers_default = WebPlayers;

  // elos-web/src/Chart.svelte
  var import_chart = __toModule(require_Chart());
  function create_fragment68(ctx) {
    let section;
    return {
      c() {
        section = element("section");
        section.innerHTML = `<canvas id="chart" width="400" height="400"></canvas>`;
        attr(section, "class", "log-body");
      },
      m(target, anchor) {
        insert(target, section, anchor);
      },
      p: noop,
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(section);
      }
    };
  }
  function instance67($$self, $$props, $$invalidate) {
    const dispatch = createEventDispatcher();
    let { dataStore: dataStore2 = null } = $$props;
    let { dataKey = null } = $$props;
    let { readonly = false } = $$props;
    let { transform = (x) => x } = $$props;
    let { buttonName = null } = $$props;
    let { inputEvent = null } = $$props;
    let { titleKey = null } = $$props;
    let queue = null;
    let data = null;
    let chart = null;
    function didClick(e) {
      console.log("did click", e);
      dispatch("didClick", e);
    }
    function close(e) {
      var div = e.target.parentElement;
      div.style.display = "none";
      dispatch("removed", e);
    }
    function renderData() {
      return {
        labels: Object.keys(queue),
        datasets: [
          {
            label: "",
            data: Object.values(queue).map((x) => x.at.length),
            backgroundColor: [
              "rgba(255, 99, 132, 0.2)",
              "rgba(255, 159, 64, 0.2)",
              "rgba(255, 205, 86, 0.2)",
              "rgba(75, 192, 192, 0.2)",
              "rgba(54, 162, 235, 0.2)",
              "rgba(153, 102, 255, 0.2)",
              "rgba(201, 203, 207, 0.2)"
            ],
            borderColor: [
              "rgb(255, 99, 132)",
              "rgb(255, 159, 64)",
              "rgb(255, 205, 86)",
              "rgb(75, 192, 192)",
              "rgb(54, 162, 235)",
              "rgb(153, 102, 255)",
              "rgb(201, 203, 207)"
            ],
            borderWidth: 1
          }
        ]
      };
    }
    function createChart() {
      let ctx = document.getElementById("chart").getContext("2d");
      return new import_chart.Chart(ctx, {
        type: "bar",
        data: renderData(),
        options: {
          scales: {
            yAxes: [{ ticks: { beginAtZero: true } }]
          },
          fill: true,
          maintainAspectRatio: false,
          responsive: true,
          indexAxis: "y",
          elements: { bar: { borderWidth: 2 } },
          plugins: {
            legend: { position: "right" },
            title: {
              display: true,
              text: "Chart.js Horizontal Bar Chart"
            }
          }
        }
      });
    }
    onMount(async () => {
      console.log("ItemList mounted");
      if (dataStore2) {
        console.log("dataStore mounted in ItemList");
        dataStore2.subscribe((val) => {
          if (val) {
            console.log("ItemList update", val);
            if (dataKey) {
              $$invalidate(7, queue = val[dataKey]);
            } else {
              $$invalidate(7, queue = val);
            }
          }
        });
        $$invalidate(9, chart = createChart());
      }
    });
    $$self.$$set = ($$props2) => {
      if ("dataStore" in $$props2)
        $$invalidate(1, dataStore2 = $$props2.dataStore);
      if ("dataKey" in $$props2)
        $$invalidate(2, dataKey = $$props2.dataKey);
      if ("readonly" in $$props2)
        $$invalidate(0, readonly = $$props2.readonly);
      if ("transform" in $$props2)
        $$invalidate(3, transform = $$props2.transform);
      if ("buttonName" in $$props2)
        $$invalidate(4, buttonName = $$props2.buttonName);
      if ("inputEvent" in $$props2)
        $$invalidate(5, inputEvent = $$props2.inputEvent);
      if ("titleKey" in $$props2)
        $$invalidate(6, titleKey = $$props2.titleKey);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 48) {
        $:
          $$invalidate(0, readonly = !buttonName || !inputEvent);
      }
      if ($$self.$$.dirty & 64) {
        $:
          titleKey;
      }
      if ($$self.$$.dirty & 896) {
        $: {
          if (queue) {
            $$invalidate(8, data = renderData());
            console.log(chart);
            $$invalidate(9, chart.data = data, chart);
            chart.update();
          } else {
          }
        }
      }
      if ($$self.$$.dirty & 128) {
        $:
          console.log("queue", queue);
      }
    };
    return [
      readonly,
      dataStore2,
      dataKey,
      transform,
      buttonName,
      inputEvent,
      titleKey,
      queue,
      data,
      chart
    ];
  }
  var Chart_1 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance67, create_fragment68, safe_not_equal, {
        dataStore: 1,
        dataKey: 2,
        readonly: 0,
        transform: 3,
        buttonName: 4,
        inputEvent: 5,
        titleKey: 6
      });
    }
  };
  var Chart_default = Chart_1;

  // elos-web/src/ExpandList.svelte
  function get_each_context4(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[11] = list[i];
    return child_ctx;
  }
  function get_each_context_1(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[14] = list[i];
    return child_ctx;
  }
  function get_each_context_2(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[17] = list[i];
    return child_ctx;
  }
  function create_else_block_12(ctx) {
    let p;
    let t0;
    let t1;
    let t2;
    return {
      c() {
        p = element("p");
        t0 = text("No List Given (");
        t1 = text(ctx[2]);
        t2 = text(")");
        attr(p, "class", "svelte-18eb8y2");
      },
      m(target, anchor) {
        insert(target, p, anchor);
        append(p, t0);
        append(p, t1);
        append(p, t2);
      },
      p(ctx2, dirty) {
        if (dirty & 4)
          set_data(t1, ctx2[2]);
      },
      d(detaching) {
        if (detaching)
          detach(p);
      }
    };
  }
  function create_if_block58(ctx) {
    let each_1_anchor;
    let each_value = Object.values(ctx[2]);
    let each_blocks = [];
    for (let i = 0; i < each_value.length; i += 1) {
      each_blocks[i] = create_each_block4(get_each_context4(ctx, each_value, i));
    }
    let each_1_else = null;
    if (!each_value.length) {
      each_1_else = create_else_block4(ctx);
    }
    return {
      c() {
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        each_1_anchor = empty();
        if (each_1_else) {
          each_1_else.c();
        }
      },
      m(target, anchor) {
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].m(target, anchor);
        }
        insert(target, each_1_anchor, anchor);
        if (each_1_else) {
          each_1_else.m(target, anchor);
        }
      },
      p(ctx2, dirty) {
        if (dirty & 7) {
          each_value = Object.values(ctx2[2]);
          let i;
          for (i = 0; i < each_value.length; i += 1) {
            const child_ctx = get_each_context4(ctx2, each_value, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
            } else {
              each_blocks[i] = create_each_block4(child_ctx);
              each_blocks[i].c();
              each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
            }
          }
          for (; i < each_blocks.length; i += 1) {
            each_blocks[i].d(1);
          }
          each_blocks.length = each_value.length;
          if (!each_value.length && each_1_else) {
            each_1_else.p(ctx2, dirty);
          } else if (!each_value.length) {
            each_1_else = create_else_block4(ctx2);
            each_1_else.c();
            each_1_else.m(each_1_anchor.parentNode, each_1_anchor);
          } else if (each_1_else) {
            each_1_else.d(1);
            each_1_else = null;
          }
        }
      },
      d(detaching) {
        destroy_each(each_blocks, detaching);
        if (detaching)
          detach(each_1_anchor);
        if (each_1_else)
          each_1_else.d(detaching);
      }
    };
  }
  function create_else_block4(ctx) {
    let p;
    let t0;
    let t1_value = ctx[2].length + "";
    let t1;
    let t2;
    let t3_value = ctx[11].prototype + "";
    let t3;
    let t4;
    return {
      c() {
        p = element("p");
        t0 = text("No Data (");
        t1 = text(t1_value);
        t2 = text(", ");
        t3 = text(t3_value);
        t4 = text(")");
        attr(p, "class", "svelte-18eb8y2");
      },
      m(target, anchor) {
        insert(target, p, anchor);
        append(p, t0);
        append(p, t1);
        append(p, t2);
        append(p, t3);
        append(p, t4);
      },
      p(ctx2, dirty) {
        if (dirty & 4 && t1_value !== (t1_value = ctx2[2].length + ""))
          set_data(t1, t1_value);
        if (dirty & 4 && t3_value !== (t3_value = ctx2[11].prototype + ""))
          set_data(t3, t3_value);
      },
      d(detaching) {
        if (detaching)
          detach(p);
      }
    };
  }
  function create_if_block_22(ctx) {
    let span;
    let t_value = ctx[11][ctx[1]] + "";
    let t;
    return {
      c() {
        span = element("span");
        t = text(t_value);
        attr(span, "class", "svelte-18eb8y2");
      },
      m(target, anchor) {
        insert(target, span, anchor);
        append(span, t);
      },
      p(ctx2, dirty) {
        if (dirty & 6 && t_value !== (t_value = ctx2[11][ctx2[1]] + ""))
          set_data(t, t_value);
      },
      d(detaching) {
        if (detaching)
          detach(span);
      }
    };
  }
  function create_if_block_13(ctx) {
    let table;
    let each_value_1 = ctx[0](ctx[11]);
    let each_blocks = [];
    for (let i = 0; i < each_value_1.length; i += 1) {
      each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    }
    return {
      c() {
        table = element("table");
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        attr(table, "class", "svelte-18eb8y2");
      },
      m(target, anchor) {
        insert(target, table, anchor);
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].m(table, null);
        }
      },
      p(ctx2, dirty) {
        if (dirty & 5) {
          each_value_1 = ctx2[0](ctx2[11]);
          let i;
          for (i = 0; i < each_value_1.length; i += 1) {
            const child_ctx = get_each_context_1(ctx2, each_value_1, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
            } else {
              each_blocks[i] = create_each_block_1(child_ctx);
              each_blocks[i].c();
              each_blocks[i].m(table, null);
            }
          }
          for (; i < each_blocks.length; i += 1) {
            each_blocks[i].d(1);
          }
          each_blocks.length = each_value_1.length;
        }
      },
      d(detaching) {
        if (detaching)
          detach(table);
        destroy_each(each_blocks, detaching);
      }
    };
  }
  function create_each_block_2(ctx) {
    let p;
    let t_value = ctx[17] + "";
    let t;
    return {
      c() {
        p = element("p");
        t = text(t_value);
        attr(p, "class", "svelte-18eb8y2");
      },
      m(target, anchor) {
        insert(target, p, anchor);
        append(p, t);
      },
      p(ctx2, dirty) {
        if (dirty & 5 && t_value !== (t_value = ctx2[17] + ""))
          set_data(t, t_value);
      },
      d(detaching) {
        if (detaching)
          detach(p);
      }
    };
  }
  function create_each_block_1(ctx) {
    let tr;
    let td0;
    let t0_value = ctx[14].name + "";
    let t0;
    let t1;
    let t2;
    let td1;
    let t3;
    let t4_value = ctx[14].at + "";
    let t4;
    let t5;
    let each_value_2 = ctx[14].data;
    let each_blocks = [];
    for (let i = 0; i < each_value_2.length; i += 1) {
      each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
    }
    return {
      c() {
        tr = element("tr");
        td0 = element("td");
        t0 = text(t0_value);
        t1 = space();
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        t2 = space();
        td1 = element("td");
        t3 = text("at: ");
        t4 = text(t4_value);
        t5 = space();
        attr(td0, "class", "svelte-18eb8y2");
        attr(td1, "class", "svelte-18eb8y2");
        attr(tr, "class", "svelte-18eb8y2");
      },
      m(target, anchor) {
        insert(target, tr, anchor);
        append(tr, td0);
        append(td0, t0);
        append(tr, t1);
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].m(tr, null);
        }
        append(tr, t2);
        append(tr, td1);
        append(td1, t3);
        append(td1, t4);
        append(tr, t5);
      },
      p(ctx2, dirty) {
        if (dirty & 5 && t0_value !== (t0_value = ctx2[14].name + ""))
          set_data(t0, t0_value);
        if (dirty & 5) {
          each_value_2 = ctx2[14].data;
          let i;
          for (i = 0; i < each_value_2.length; i += 1) {
            const child_ctx = get_each_context_2(ctx2, each_value_2, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
            } else {
              each_blocks[i] = create_each_block_2(child_ctx);
              each_blocks[i].c();
              each_blocks[i].m(tr, t2);
            }
          }
          for (; i < each_blocks.length; i += 1) {
            each_blocks[i].d(1);
          }
          each_blocks.length = each_value_2.length;
        }
        if (dirty & 5 && t4_value !== (t4_value = ctx2[14].at + ""))
          set_data(t4, t4_value);
      },
      d(detaching) {
        if (detaching)
          detach(tr);
        destroy_each(each_blocks, detaching);
      }
    };
  }
  function create_each_block4(ctx) {
    let p;
    let t0;
    let t1;
    let if_block0 = ctx[1] && ctx[1] in ctx[11] && ctx[11][ctx[1]] !== null && create_if_block_22(ctx);
    let if_block1 = ctx[11] && ctx[11].length > 0 && ctx[0] && create_if_block_13(ctx);
    return {
      c() {
        p = element("p");
        if (if_block0)
          if_block0.c();
        t0 = space();
        if (if_block1)
          if_block1.c();
        t1 = space();
        attr(p, "class", "item svelte-18eb8y2");
      },
      m(target, anchor) {
        insert(target, p, anchor);
        if (if_block0)
          if_block0.m(p, null);
        append(p, t0);
        if (if_block1)
          if_block1.m(p, null);
        append(p, t1);
      },
      p(ctx2, dirty) {
        if (ctx2[1] && ctx2[1] in ctx2[11] && ctx2[11][ctx2[1]] !== null) {
          if (if_block0) {
            if_block0.p(ctx2, dirty);
          } else {
            if_block0 = create_if_block_22(ctx2);
            if_block0.c();
            if_block0.m(p, t0);
          }
        } else if (if_block0) {
          if_block0.d(1);
          if_block0 = null;
        }
        if (ctx2[11] && ctx2[11].length > 0 && ctx2[0]) {
          if (if_block1) {
            if_block1.p(ctx2, dirty);
          } else {
            if_block1 = create_if_block_13(ctx2);
            if_block1.c();
            if_block1.m(p, t1);
          }
        } else if (if_block1) {
          if_block1.d(1);
          if_block1 = null;
        }
      },
      d(detaching) {
        if (detaching)
          detach(p);
        if (if_block0)
          if_block0.d();
        if (if_block1)
          if_block1.d();
      }
    };
  }
  function create_fragment69(ctx) {
    let div;
    function select_block_type(ctx2, dirty) {
      if (ctx2[2])
        return create_if_block58;
      return create_else_block_12;
    }
    let current_block_type = select_block_type(ctx, -1);
    let if_block = current_block_type(ctx);
    return {
      c() {
        div = element("div");
        if_block.c();
        attr(div, "class", "svelte-18eb8y2");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        if_block.m(div, null);
      },
      p(ctx2, [dirty]) {
        if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block.d(1);
          if_block = current_block_type(ctx2);
          if (if_block) {
            if_block.c();
            if_block.m(div, null);
          }
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(div);
        if_block.d();
      }
    };
  }
  function instance68($$self, $$props, $$invalidate) {
    const dispatch = createEventDispatcher();
    let { readonly = false } = $$props;
    let { dataStore: dataStore2 = null } = $$props;
    let { dataKey = null } = $$props;
    let { transform = null } = $$props;
    let queue = null;
    let { buttonName = null } = $$props;
    let { inputEvent = null } = $$props;
    let { titleKey = null } = $$props;
    function didClick(e) {
      console.log("did click", e);
      dispatch("didClick", e);
    }
    function close(e) {
      var div = e.target.parentElement;
      div.style.display = "none";
      dispatch("removed", e);
    }
    onMount(async () => {
      console.log("ExpandList mounted");
      if (dataStore2) {
        dataStore2.subscribe((val) => {
          if (val) {
            console.log("ExpandList update", dataKey, val);
            if (dataKey) {
              $$invalidate(2, queue = val[dataKey]);
            } else {
              $$invalidate(2, queue = val);
            }
          }
        });
      }
    });
    $$self.$$set = ($$props2) => {
      if ("readonly" in $$props2)
        $$invalidate(3, readonly = $$props2.readonly);
      if ("dataStore" in $$props2)
        $$invalidate(4, dataStore2 = $$props2.dataStore);
      if ("dataKey" in $$props2)
        $$invalidate(5, dataKey = $$props2.dataKey);
      if ("transform" in $$props2)
        $$invalidate(0, transform = $$props2.transform);
      if ("buttonName" in $$props2)
        $$invalidate(6, buttonName = $$props2.buttonName);
      if ("inputEvent" in $$props2)
        $$invalidate(7, inputEvent = $$props2.inputEvent);
      if ("titleKey" in $$props2)
        $$invalidate(1, titleKey = $$props2.titleKey);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 192) {
        $:
          $$invalidate(3, readonly = !buttonName || !inputEvent);
      }
      if ($$self.$$.dirty & 2) {
        $:
          titleKey;
      }
    };
    return [
      transform,
      titleKey,
      queue,
      readonly,
      dataStore2,
      dataKey,
      buttonName,
      inputEvent
    ];
  }
  var ExpandList = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance68, create_fragment69, safe_not_equal, {
        readonly: 3,
        dataStore: 4,
        dataKey: 5,
        transform: 0,
        buttonName: 6,
        inputEvent: 7,
        titleKey: 1
      });
    }
  };
  var ExpandList_default = ExpandList;

  // elos-web/src/SelectList.svelte
  function get_each_context5(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[10] = list[i];
    child_ctx[12] = i;
    return child_ctx;
  }
  function create_else_block_13(ctx) {
    let li;
    return {
      c() {
        li = element("li");
        li.textContent = "No Data";
        attr(li, "class", "svelte-84ijo1");
      },
      m(target, anchor) {
        insert(target, li, anchor);
      },
      d(detaching) {
        if (detaching)
          detach(li);
      }
    };
  }
  function create_else_block5(ctx) {
    let t_value = ctx[0](ctx[10]) + "";
    let t;
    return {
      c() {
        t = text(t_value);
      },
      m(target, anchor) {
        insert(target, t, anchor);
      },
      p(ctx2, dirty) {
        if (dirty & 3 && t_value !== (t_value = ctx2[0](ctx2[10]) + ""))
          set_data(t, t_value);
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(t);
      }
    };
  }
  function create_if_block59(ctx) {
    let switch_instance;
    let switch_instance_anchor;
    let current;
    var switch_value = icons[ctx[10].value.icon];
    function switch_props(ctx2) {
      return {};
    }
    if (switch_value) {
      switch_instance = new switch_value(switch_props(ctx));
    }
    return {
      c() {
        if (switch_instance)
          create_component(switch_instance.$$.fragment);
        switch_instance_anchor = empty();
      },
      m(target, anchor) {
        if (switch_instance) {
          mount_component(switch_instance, target, anchor);
        }
        insert(target, switch_instance_anchor, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        if (switch_value !== (switch_value = icons[ctx2[10].value.icon])) {
          if (switch_instance) {
            group_outros();
            const old_component = switch_instance;
            transition_out(old_component.$$.fragment, 1, 0, () => {
              destroy_component(old_component, 1);
            });
            check_outros();
          }
          if (switch_value) {
            switch_instance = new switch_value(switch_props(ctx2));
            create_component(switch_instance.$$.fragment);
            transition_in(switch_instance.$$.fragment, 1);
            mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
          } else {
            switch_instance = null;
          }
        } else if (switch_value) {
        }
      },
      i(local) {
        if (current)
          return;
        if (switch_instance)
          transition_in(switch_instance.$$.fragment, local);
        current = true;
      },
      o(local) {
        if (switch_instance)
          transition_out(switch_instance.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(switch_instance_anchor);
        if (switch_instance)
          destroy_component(switch_instance, detaching);
      }
    };
  }
  function create_each_block5(key_1, ctx) {
    let li;
    let current_block_type_index;
    let if_block;
    let t;
    let li_index_value;
    let li_item_value;
    let li_title_value;
    let current;
    let mounted;
    let dispose;
    const if_block_creators = [create_if_block59, create_else_block5];
    const if_blocks = [];
    function select_block_type(ctx2, dirty) {
      if (ctx2[10].value.icon)
        return 0;
      return 1;
    }
    current_block_type_index = select_block_type(ctx, -1);
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    function click_handler() {
      return ctx[7](ctx[10]);
    }
    return {
      key: key_1,
      first: null,
      c() {
        li = element("li");
        if_block.c();
        t = space();
        attr(li, "index", li_index_value = ctx[12]);
        attr(li, "item", li_item_value = ctx[10]);
        attr(li, "title", li_title_value = ctx[10].value.highlight);
        attr(li, "class", "svelte-84ijo1");
        toggle_class(li, "active", ctx[10].active);
        this.first = li;
      },
      m(target, anchor) {
        insert(target, li, anchor);
        if_blocks[current_block_type_index].m(li, null);
        append(li, t);
        current = true;
        if (!mounted) {
          dispose = listen(li, "click", stop_propagation(prevent_default(click_handler)));
          mounted = true;
        }
      },
      p(new_ctx, dirty) {
        ctx = new_ctx;
        let previous_block_index = current_block_type_index;
        current_block_type_index = select_block_type(ctx, dirty);
        if (current_block_type_index === previous_block_index) {
          if_blocks[current_block_type_index].p(ctx, dirty);
        } else {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
            if_block.c();
          } else {
            if_block.p(ctx, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(li, t);
        }
        if (!current || dirty & 2 && li_index_value !== (li_index_value = ctx[12])) {
          attr(li, "index", li_index_value);
        }
        if (!current || dirty & 2 && li_item_value !== (li_item_value = ctx[10])) {
          attr(li, "item", li_item_value);
        }
        if (!current || dirty & 2 && li_title_value !== (li_title_value = ctx[10].value.highlight)) {
          attr(li, "title", li_title_value);
        }
        if (dirty & 2) {
          toggle_class(li, "active", ctx[10].active);
        }
      },
      i(local) {
        if (current)
          return;
        transition_in(if_block);
        current = true;
      },
      o(local) {
        transition_out(if_block);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(li);
        if_blocks[current_block_type_index].d();
        mounted = false;
        dispose();
      }
    };
  }
  function create_fragment70(ctx) {
    let section;
    let ul;
    let each_blocks = [];
    let each_1_lookup = new Map();
    let current;
    let each_value = ctx[1];
    const get_key = (ctx2) => ctx2[10].name;
    for (let i = 0; i < each_value.length; i += 1) {
      let child_ctx = get_each_context5(ctx, each_value, i);
      let key = get_key(child_ctx);
      each_1_lookup.set(key, each_blocks[i] = create_each_block5(key, child_ctx));
    }
    let each_1_else = null;
    if (!each_value.length) {
      each_1_else = create_else_block_13(ctx);
    }
    return {
      c() {
        section = element("section");
        ul = element("ul");
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        if (each_1_else) {
          each_1_else.c();
        }
        attr(ul, "class", "pill-nav svelte-84ijo1");
        attr(section, "class", "svelte-84ijo1");
      },
      m(target, anchor) {
        insert(target, section, anchor);
        append(section, ul);
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].m(ul, null);
        }
        if (each_1_else) {
          each_1_else.m(ul, null);
        }
        current = true;
      },
      p(ctx2, [dirty]) {
        if (dirty & 7) {
          each_value = ctx2[1];
          group_outros();
          each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, ul, outro_and_destroy_block, create_each_block5, null, get_each_context5);
          check_outros();
          if (each_value.length) {
            if (each_1_else) {
              each_1_else.d(1);
              each_1_else = null;
            }
          } else if (!each_1_else) {
            each_1_else = create_else_block_13(ctx2);
            each_1_else.c();
            each_1_else.m(ul, null);
          }
        }
      },
      i(local) {
        if (current)
          return;
        for (let i = 0; i < each_value.length; i += 1) {
          transition_in(each_blocks[i]);
        }
        current = true;
      },
      o(local) {
        for (let i = 0; i < each_blocks.length; i += 1) {
          transition_out(each_blocks[i]);
        }
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(section);
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].d();
        }
        if (each_1_else)
          each_1_else.d();
      }
    };
  }
  function toggleActive(item2) {
    item2.active = !item2.active;
  }
  function instance69($$self, $$props, $$invalidate) {
    const dispatch = createEventDispatcher();
    let { eventName = "menuToggle" } = $$props;
    let { source = null } = $$props;
    let { transform = (e) => {
      return e.name.slice(10).toUpperCase();
    } } = $$props;
    let { data = {} } = $$props;
    let { items = [] } = $$props;
    const updateFromSource = async (source2) => {
      if (source2 !== null) {
        let response = await _fetch(source2);
        console.log("getting data from", source2, response);
        $$invalidate(3, items = response.data);
      }
    };
    let visibleItems = [];
    function _sendEvent(item2) {
      console.log("clicked sendEvent --", eventName, item2);
      if (eventName === "filterType") {
      } else {
        dispatch(eventName, item2);
      }
      toggleActive(item2);
    }
    onMount(async () => {
      console.log("SelectList mounted", data);
      updateFromSource(source);
      dispatch("didMount", data);
    });
    const click_handler = (item2) => _sendEvent(item2);
    $$self.$$set = ($$props2) => {
      if ("eventName" in $$props2)
        $$invalidate(4, eventName = $$props2.eventName);
      if ("source" in $$props2)
        $$invalidate(5, source = $$props2.source);
      if ("transform" in $$props2)
        $$invalidate(0, transform = $$props2.transform);
      if ("data" in $$props2)
        $$invalidate(6, data = $$props2.data);
      if ("items" in $$props2)
        $$invalidate(3, items = $$props2.items);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 32) {
        $:
          source !== null ? updateFromSource(source) : null;
      }
      if ($$self.$$.dirty & 10) {
        $:
          $$invalidate(1, visibleItems = items.map((item2, idx) => {
            return {
              ...item2,
              active: visibleItems.length > idx ? visibleItems[idx].active : false
            };
          }));
      }
    };
    return [
      transform,
      visibleItems,
      _sendEvent,
      items,
      eventName,
      source,
      data,
      click_handler
    ];
  }
  var SelectList = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance69, create_fragment70, safe_not_equal, {
        eventName: 4,
        source: 5,
        transform: 0,
        data: 6,
        items: 3
      });
    }
  };
  var SelectList_default = SelectList;

  // elos-web/src/RotateList.svelte
  function get_each_context6(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[11] = list[i];
    return child_ctx;
  }
  function get_each_context_12(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[14] = list[i];
    return child_ctx;
  }
  function get_each_context_22(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[17] = list[i];
    return child_ctx;
  }
  function create_else_block_14(ctx) {
    let p;
    let t0;
    let t1;
    let t2;
    return {
      c() {
        p = element("p");
        t0 = text("No List Given (");
        t1 = text(ctx[2]);
        t2 = text(")");
        attr(p, "class", "svelte-q2f8jr");
      },
      m(target, anchor) {
        insert(target, p, anchor);
        append(p, t0);
        append(p, t1);
        append(p, t2);
      },
      p(ctx2, dirty) {
        if (dirty & 4)
          set_data(t1, ctx2[2]);
      },
      d(detaching) {
        if (detaching)
          detach(p);
      }
    };
  }
  function create_if_block60(ctx) {
    let each_1_anchor;
    let each_value = Object.values(ctx[2]);
    let each_blocks = [];
    for (let i = 0; i < each_value.length; i += 1) {
      each_blocks[i] = create_each_block6(get_each_context6(ctx, each_value, i));
    }
    let each_1_else = null;
    if (!each_value.length) {
      each_1_else = create_else_block6(ctx);
    }
    return {
      c() {
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        each_1_anchor = empty();
        if (each_1_else) {
          each_1_else.c();
        }
      },
      m(target, anchor) {
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].m(target, anchor);
        }
        insert(target, each_1_anchor, anchor);
        if (each_1_else) {
          each_1_else.m(target, anchor);
        }
      },
      p(ctx2, dirty) {
        if (dirty & 7) {
          each_value = Object.values(ctx2[2]);
          let i;
          for (i = 0; i < each_value.length; i += 1) {
            const child_ctx = get_each_context6(ctx2, each_value, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
            } else {
              each_blocks[i] = create_each_block6(child_ctx);
              each_blocks[i].c();
              each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
            }
          }
          for (; i < each_blocks.length; i += 1) {
            each_blocks[i].d(1);
          }
          each_blocks.length = each_value.length;
          if (!each_value.length && each_1_else) {
            each_1_else.p(ctx2, dirty);
          } else if (!each_value.length) {
            each_1_else = create_else_block6(ctx2);
            each_1_else.c();
            each_1_else.m(each_1_anchor.parentNode, each_1_anchor);
          } else if (each_1_else) {
            each_1_else.d(1);
            each_1_else = null;
          }
        }
      },
      d(detaching) {
        destroy_each(each_blocks, detaching);
        if (detaching)
          detach(each_1_anchor);
        if (each_1_else)
          each_1_else.d(detaching);
      }
    };
  }
  function create_else_block6(ctx) {
    let p;
    let t0;
    let t1_value = ctx[2].length + "";
    let t1;
    let t2;
    let t3_value = ctx[11].prototype + "";
    let t3;
    let t4;
    return {
      c() {
        p = element("p");
        t0 = text("No Data (");
        t1 = text(t1_value);
        t2 = text(", ");
        t3 = text(t3_value);
        t4 = text(")");
        attr(p, "class", "svelte-q2f8jr");
      },
      m(target, anchor) {
        insert(target, p, anchor);
        append(p, t0);
        append(p, t1);
        append(p, t2);
        append(p, t3);
        append(p, t4);
      },
      p(ctx2, dirty) {
        if (dirty & 4 && t1_value !== (t1_value = ctx2[2].length + ""))
          set_data(t1, t1_value);
        if (dirty & 4 && t3_value !== (t3_value = ctx2[11].prototype + ""))
          set_data(t3, t3_value);
      },
      d(detaching) {
        if (detaching)
          detach(p);
      }
    };
  }
  function create_if_block_23(ctx) {
    let span;
    let t_value = ctx[11][ctx[1]] + "";
    let t;
    return {
      c() {
        span = element("span");
        t = text(t_value);
        attr(span, "class", "svelte-q2f8jr");
      },
      m(target, anchor) {
        insert(target, span, anchor);
        append(span, t);
      },
      p(ctx2, dirty) {
        if (dirty & 6 && t_value !== (t_value = ctx2[11][ctx2[1]] + ""))
          set_data(t, t_value);
      },
      d(detaching) {
        if (detaching)
          detach(span);
      }
    };
  }
  function create_if_block_14(ctx) {
    let table;
    let each_value_1 = ctx[0](ctx[11]);
    let each_blocks = [];
    for (let i = 0; i < each_value_1.length; i += 1) {
      each_blocks[i] = create_each_block_12(get_each_context_12(ctx, each_value_1, i));
    }
    return {
      c() {
        table = element("table");
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        attr(table, "class", "svelte-q2f8jr");
      },
      m(target, anchor) {
        insert(target, table, anchor);
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].m(table, null);
        }
      },
      p(ctx2, dirty) {
        if (dirty & 5) {
          each_value_1 = ctx2[0](ctx2[11]);
          let i;
          for (i = 0; i < each_value_1.length; i += 1) {
            const child_ctx = get_each_context_12(ctx2, each_value_1, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
            } else {
              each_blocks[i] = create_each_block_12(child_ctx);
              each_blocks[i].c();
              each_blocks[i].m(table, null);
            }
          }
          for (; i < each_blocks.length; i += 1) {
            each_blocks[i].d(1);
          }
          each_blocks.length = each_value_1.length;
        }
      },
      d(detaching) {
        if (detaching)
          detach(table);
        destroy_each(each_blocks, detaching);
      }
    };
  }
  function create_each_block_22(ctx) {
    let p;
    let t_value = ctx[17] + "";
    let t;
    return {
      c() {
        p = element("p");
        t = text(t_value);
        attr(p, "class", "svelte-q2f8jr");
      },
      m(target, anchor) {
        insert(target, p, anchor);
        append(p, t);
      },
      p(ctx2, dirty) {
        if (dirty & 5 && t_value !== (t_value = ctx2[17] + ""))
          set_data(t, t_value);
      },
      d(detaching) {
        if (detaching)
          detach(p);
      }
    };
  }
  function create_each_block_12(ctx) {
    let tr;
    let td0;
    let t0_value = ctx[14].name + "";
    let t0;
    let t1;
    let t2;
    let td1;
    let t3;
    let t4_value = ctx[14].at + "";
    let t4;
    let t5;
    let each_value_2 = ctx[14].data;
    let each_blocks = [];
    for (let i = 0; i < each_value_2.length; i += 1) {
      each_blocks[i] = create_each_block_22(get_each_context_22(ctx, each_value_2, i));
    }
    return {
      c() {
        tr = element("tr");
        td0 = element("td");
        t0 = text(t0_value);
        t1 = space();
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        t2 = space();
        td1 = element("td");
        t3 = text("at: ");
        t4 = text(t4_value);
        t5 = space();
        attr(td0, "class", "svelte-q2f8jr");
        attr(td1, "class", "svelte-q2f8jr");
        attr(tr, "class", "svelte-q2f8jr");
      },
      m(target, anchor) {
        insert(target, tr, anchor);
        append(tr, td0);
        append(td0, t0);
        append(tr, t1);
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].m(tr, null);
        }
        append(tr, t2);
        append(tr, td1);
        append(td1, t3);
        append(td1, t4);
        append(tr, t5);
      },
      p(ctx2, dirty) {
        if (dirty & 5 && t0_value !== (t0_value = ctx2[14].name + ""))
          set_data(t0, t0_value);
        if (dirty & 5) {
          each_value_2 = ctx2[14].data;
          let i;
          for (i = 0; i < each_value_2.length; i += 1) {
            const child_ctx = get_each_context_22(ctx2, each_value_2, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
            } else {
              each_blocks[i] = create_each_block_22(child_ctx);
              each_blocks[i].c();
              each_blocks[i].m(tr, t2);
            }
          }
          for (; i < each_blocks.length; i += 1) {
            each_blocks[i].d(1);
          }
          each_blocks.length = each_value_2.length;
        }
        if (dirty & 5 && t4_value !== (t4_value = ctx2[14].at + ""))
          set_data(t4, t4_value);
      },
      d(detaching) {
        if (detaching)
          detach(tr);
        destroy_each(each_blocks, detaching);
      }
    };
  }
  function create_each_block6(ctx) {
    let p;
    let t0;
    let t1;
    let if_block0 = ctx[1] && ctx[1] in ctx[11] && ctx[11][ctx[1]] !== null && create_if_block_23(ctx);
    let if_block1 = ctx[11] && ctx[11].length > 0 && ctx[0] && create_if_block_14(ctx);
    return {
      c() {
        p = element("p");
        if (if_block0)
          if_block0.c();
        t0 = space();
        if (if_block1)
          if_block1.c();
        t1 = space();
        attr(p, "class", "item svelte-q2f8jr");
      },
      m(target, anchor) {
        insert(target, p, anchor);
        if (if_block0)
          if_block0.m(p, null);
        append(p, t0);
        if (if_block1)
          if_block1.m(p, null);
        append(p, t1);
      },
      p(ctx2, dirty) {
        if (ctx2[1] && ctx2[1] in ctx2[11] && ctx2[11][ctx2[1]] !== null) {
          if (if_block0) {
            if_block0.p(ctx2, dirty);
          } else {
            if_block0 = create_if_block_23(ctx2);
            if_block0.c();
            if_block0.m(p, t0);
          }
        } else if (if_block0) {
          if_block0.d(1);
          if_block0 = null;
        }
        if (ctx2[11] && ctx2[11].length > 0 && ctx2[0]) {
          if (if_block1) {
            if_block1.p(ctx2, dirty);
          } else {
            if_block1 = create_if_block_14(ctx2);
            if_block1.c();
            if_block1.m(p, t1);
          }
        } else if (if_block1) {
          if_block1.d(1);
          if_block1 = null;
        }
      },
      d(detaching) {
        if (detaching)
          detach(p);
        if (if_block0)
          if_block0.d();
        if (if_block1)
          if_block1.d();
      }
    };
  }
  function create_fragment71(ctx) {
    let div;
    function select_block_type(ctx2, dirty) {
      if (ctx2[2])
        return create_if_block60;
      return create_else_block_14;
    }
    let current_block_type = select_block_type(ctx, -1);
    let if_block = current_block_type(ctx);
    return {
      c() {
        div = element("div");
        if_block.c();
        attr(div, "class", "svelte-q2f8jr");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        if_block.m(div, null);
      },
      p(ctx2, [dirty]) {
        if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block.d(1);
          if_block = current_block_type(ctx2);
          if (if_block) {
            if_block.c();
            if_block.m(div, null);
          }
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(div);
        if_block.d();
      }
    };
  }
  function instance70($$self, $$props, $$invalidate) {
    const dispatch = createEventDispatcher();
    let { readonly = false } = $$props;
    let { dataStore: dataStore2 = null } = $$props;
    let { dataKey = null } = $$props;
    let { transform = null } = $$props;
    let queue = null;
    let { buttonName = null } = $$props;
    let { inputEvent = null } = $$props;
    let { titleKey = null } = $$props;
    function didClick(e) {
      console.log("did click", e);
      dispatch("didClick", e);
    }
    function close(e) {
      var div = e.target.parentElement;
      div.style.display = "none";
      dispatch("removed", e);
    }
    onMount(async () => {
      console.log("ExpandList mounted");
      if (dataStore2) {
        dataStore2.subscribe((val) => {
          if (val) {
            console.log("ExpandList update", dataKey, val);
            if (dataKey) {
              $$invalidate(2, queue = val[dataKey]);
            } else {
              $$invalidate(2, queue = val);
            }
          }
        });
      }
    });
    $$self.$$set = ($$props2) => {
      if ("readonly" in $$props2)
        $$invalidate(3, readonly = $$props2.readonly);
      if ("dataStore" in $$props2)
        $$invalidate(4, dataStore2 = $$props2.dataStore);
      if ("dataKey" in $$props2)
        $$invalidate(5, dataKey = $$props2.dataKey);
      if ("transform" in $$props2)
        $$invalidate(0, transform = $$props2.transform);
      if ("buttonName" in $$props2)
        $$invalidate(6, buttonName = $$props2.buttonName);
      if ("inputEvent" in $$props2)
        $$invalidate(7, inputEvent = $$props2.inputEvent);
      if ("titleKey" in $$props2)
        $$invalidate(1, titleKey = $$props2.titleKey);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 192) {
        $:
          $$invalidate(3, readonly = !buttonName || !inputEvent);
      }
      if ($$self.$$.dirty & 2) {
        $:
          titleKey;
      }
    };
    return [
      transform,
      titleKey,
      queue,
      readonly,
      dataStore2,
      dataKey,
      buttonName,
      inputEvent
    ];
  }
  var RotateList = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance70, create_fragment71, safe_not_equal, {
        readonly: 3,
        dataStore: 4,
        dataKey: 5,
        transform: 0,
        buttonName: 6,
        inputEvent: 7,
        titleKey: 1
      });
    }
  };
  var RotateList_default = RotateList;

  // elos-web/src/Tracker.svelte
  function create_fragment72(ctx) {
    let section;
    return {
      c() {
        section = element("section");
      },
      m(target, anchor) {
        insert(target, section, anchor);
      },
      p: noop,
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(section);
      }
    };
  }
  var Tracker = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, null, create_fragment72, safe_not_equal, {});
    }
  };
  var Tracker_default = Tracker;

  // elos-web/src/Editor.svelte
  function instance71($$self, $$props, $$invalidate) {
    let { editor: editor2 } = $$props;
    let rootEl;
    let { data = null } = $$props;
    let { theme = "vs-light" } = $$props;
    let { language = "markdown" } = $$props;
    let { features = ["wordWrap"] } = $$props;
    const jsonfiy = (lang, intake) => {
      try {
        if (lang === "json")
          return JSON.stringify(intake, null, 4);
        return "" + intake;
      } catch (e) {
        console.log("error jsonifying", e, intake);
        return "" + intake;
      }
    };
    let _data = null;
    let { state = {} } = $$props;
    let { controls = [
      {
        save: (target, __data) => {
          console.log("saved", target, __data);
          _send(target, { data: __data });
        }
      }
    ] } = $$props;
    let { onChange = [
      (e) => {
        console.log("onchange: ", e);
      }
    ] } = $$props;
    onMount(async () => {
      console.log("Editor mounted");
      rootEl = document.getElementById("editorRoot");
    });
    $$self.$$set = ($$props2) => {
      if ("editor" in $$props2)
        $$invalidate(1, editor2 = $$props2.editor);
      if ("data" in $$props2)
        $$invalidate(2, data = $$props2.data);
      if ("theme" in $$props2)
        $$invalidate(3, theme = $$props2.theme);
      if ("language" in $$props2)
        $$invalidate(4, language = $$props2.language);
      if ("features" in $$props2)
        $$invalidate(5, features = $$props2.features);
      if ("state" in $$props2)
        $$invalidate(0, state = $$props2.state);
      if ("controls" in $$props2)
        $$invalidate(6, controls = $$props2.controls);
      if ("onChange" in $$props2)
        $$invalidate(7, onChange = $$props2.onChange);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 263) {
        $: {
          if (editor2 && data && _data === null) {
            _fetch(data).then((x) => {
              $$invalidate(8, _data = x);
              if (_data) {
                $$invalidate(0, state.source = _data, state);
                editor2.getModel().setValue(jsonfiy(state.language, _data));
                editor2.layout();
              }
            });
          }
        }
      }
      if ($$self.$$.dirty & 56) {
        $:
          $$invalidate(0, state = { source: null, theme, language, features });
      }
      if ($$self.$$.dirty & 16) {
        $:
          $$invalidate(0, state.language = ((x) => {
            switch (x) {
              case "md":
                return "markdown";
              case "js":
                return "javascript";
              case "py":
                return "python";
              default:
                return x;
            }
          })(language), state);
      }
    };
    return [state, editor2, data, theme, language, features, controls, onChange, _data];
  }
  var Editor = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance71, null, safe_not_equal, {
        editor: 1,
        data: 2,
        theme: 3,
        language: 4,
        features: 5,
        state: 0,
        controls: 6,
        onChange: 7
      });
    }
  };
  var Editor_default = Editor;

  // elos-web/src/Files.svelte
  function create_fragment73(ctx) {
    let section;
    let div;
    let span0;
    let t0_value = ctx[1].filetype + "";
    let t0;
    let t1;
    let span1;
    let t2;
    let t3;
    let t4_value = ctx[2] + ctx[1].pageSize + "";
    let t4;
    let t5;
    let t6_value = (ctx[0] || []).length + "";
    let t6;
    let t7;
    let t8;
    let itemlist;
    let current;
    itemlist = new ItemList_default({
      props: {
        buttonName: "Search",
        titleKey: "file.title",
        dataStore: stores.files,
        dataKey: "files",
        inputEvent: ctx[4]
      }
    });
    itemlist.$on("didClick", openFile);
    return {
      c() {
        section = element("section");
        div = element("div");
        span0 = element("span");
        t0 = text(t0_value);
        t1 = space();
        span1 = element("span");
        t2 = text(ctx[2]);
        t3 = text(" - ");
        t4 = text(t4_value);
        t5 = text(" (");
        t6 = text(t6_value);
        t7 = text(")");
        t8 = space();
        create_component(itemlist.$$.fragment);
        attr(div, "class", "filename svelte-hxkhy9");
        attr(section, "class", "svelte-hxkhy9");
      },
      m(target, anchor) {
        insert(target, section, anchor);
        append(section, div);
        append(div, span0);
        append(span0, t0);
        append(div, t1);
        append(div, span1);
        append(span1, t2);
        append(span1, t3);
        append(span1, t4);
        append(span1, t5);
        append(span1, t6);
        append(span1, t7);
        append(section, t8);
        mount_component(itemlist, section, null);
        current = true;
      },
      p(ctx2, [dirty]) {
        if ((!current || dirty & 2) && t0_value !== (t0_value = ctx2[1].filetype + ""))
          set_data(t0, t0_value);
        if (!current || dirty & 4)
          set_data(t2, ctx2[2]);
        if ((!current || dirty & 6) && t4_value !== (t4_value = ctx2[2] + ctx2[1].pageSize + ""))
          set_data(t4, t4_value);
        if ((!current || dirty & 1) && t6_value !== (t6_value = (ctx2[0] || []).length + ""))
          set_data(t6, t6_value);
      },
      i(local) {
        if (current)
          return;
        transition_in(itemlist.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(itemlist.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(section);
        destroy_component(itemlist);
      }
    };
  }
  function instance72($$self, $$props, $$invalidate) {
    const dispatch = createEventDispatcher();
    let { files = [] } = $$props;
    let { metadata = {
      pageSize: 10,
      pageNum: 1,
      filetype: "md",
      keywords: ""
    } } = $$props;
    let { pageOffset = 0 } = $$props;
    function submitUpdates(e) {
      console.log("Files submitUpdates", e);
      fileList(...metadata);
    }
    function incrementPage(e) {
      console.log("Files incrementPage", e);
      stores.files.update((n) => ({
        ...n,
        pageNum: n.pageNum + 1,
        dirty: true
      }));
    }
    onMount(() => {
      console.log("Files mounted");
      stores.files.subscribe((val) => {
        if (val && !val.dirty) {
          console.log("Files subscription got update", val);
          $$invalidate(0, files = val.files || []);
          $$invalidate(1, metadata = (({ files: files2, ...rest }) => rest)(val));
        }
      });
    });
    const func = (e) => submitUpdates(e);
    $$self.$$set = ($$props2) => {
      if ("files" in $$props2)
        $$invalidate(0, files = $$props2.files);
      if ("metadata" in $$props2)
        $$invalidate(1, metadata = $$props2.metadata);
      if ("pageOffset" in $$props2)
        $$invalidate(2, pageOffset = $$props2.pageOffset);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 2) {
        $:
          $$invalidate(2, pageOffset = (metadata.pageNum - 1) * metadata.pageSize);
      }
      if ($$self.$$.dirty & 1) {
        $:
          files;
      }
      if ($$self.$$.dirty & 2) {
        $:
          metadata;
      }
    };
    return [files, metadata, pageOffset, submitUpdates, func];
  }
  var Files = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance72, create_fragment73, safe_not_equal, { files: 0, metadata: 1, pageOffset: 2 });
    }
  };
  var Files_default = Files;

  // elos-web/src/DropSite.svelte
  function create_fragment74(ctx) {
    let section;
    let div;
    let mounted;
    let dispose;
    return {
      c() {
        section = element("section");
        div = element("div");
        div.innerHTML = `<p>Drag one or more files to this Drop Zone ...</p>`;
        attr(div, "id", "drop_zone");
        attr(div, "class", "svelte-ixc6v3");
      },
      m(target, anchor) {
        insert(target, section, anchor);
        append(section, div);
        if (!mounted) {
          dispose = [
            listen(div, "drop", dropHandler),
            listen(div, "dragover", dragOverHandler)
          ];
          mounted = true;
        }
      },
      p: noop,
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(section);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function dropHandler(ev) {
    console.log("File(s) dropped");
    ev.preventDefault();
    if (ev.dataTransfer.items) {
      for (var item2 in ev.dataTransfer.items) {
        if (item2.kind === "file") {
          console.log("file.name = ", file);
        }
      }
    }
  }
  function dragOverHandler(ev) {
    console.log("File(s) in drop zone");
    ev.preventDefault();
  }
  var DropSite = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, null, create_fragment74, safe_not_equal, {});
    }
  };
  var DropSite_default = DropSite;

  // elos-web/src/Pdf.svelte
  function create_fragment75(ctx) {
    let div;
    let iframe;
    let iframe_src_value;
    return {
      c() {
        div = element("div");
        iframe = element("iframe");
        if (!src_url_equal(iframe.src, iframe_src_value = ctx[0]))
          attr(iframe, "src", iframe_src_value);
        attr(iframe, "class", "svelte-87dvcj");
        attr(div, "id", "container");
        attr(div, "class", "svelte-87dvcj");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        append(div, iframe);
      },
      p(ctx2, [dirty]) {
        if (dirty & 1 && !src_url_equal(iframe.src, iframe_src_value = ctx2[0])) {
          attr(iframe, "src", iframe_src_value);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(div);
      }
    };
  }
  function instance73($$self, $$props, $$invalidate) {
    let { viewerFile = "about:blank" } = $$props;
    let { target = "#" } = $$props;
    let { pageNum = 1 } = $$props;
    onMount(() => {
      console.log("Pdf mounted");
    });
    $$self.$$set = ($$props2) => {
      if ("viewerFile" in $$props2)
        $$invalidate(0, viewerFile = $$props2.viewerFile);
      if ("target" in $$props2)
        $$invalidate(1, target = $$props2.target);
      if ("pageNum" in $$props2)
        $$invalidate(2, pageNum = $$props2.pageNum);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 3) {
        $:
          $$invalidate(0, viewerFile = `/api/load?filepath=${viewerFile}${target}`);
      }
      if ($$self.$$.dirty & 4) {
        $:
          pageNum;
      }
    };
    return [viewerFile, target, pageNum];
  }
  var Pdf = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance73, create_fragment75, safe_not_equal, { viewerFile: 0, target: 1, pageNum: 2 });
    }
  };
  var Pdf_default = Pdf;

  // elos-web/src/DataGrid.svelte
  var import_svelte_data_grid = __toModule(require_svelte_data_grid());

  // elos-web/src/cell/textbox-cell.svelte
  var import_debounce = __toModule(require_debounce());
  function create_fragment76(ctx) {
    let div;
    let input;
    let mounted;
    let dispose;
    return {
      c() {
        div = element("div");
        input = element("input");
        attr(input, "type", "text");
        attr(input, "class", "svelte-1bez19j");
        attr(div, "class", "textbox-cell svelte-1bez19j");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        append(div, input);
        ctx[7](input);
        if (!mounted) {
          dispose = [
            listen(input, "input", ctx[3]),
            listen(input, "focus", ctx[1]),
            listen(input, "blur", ctx[2])
          ];
          mounted = true;
        }
      },
      p: noop,
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(div);
        ctx[7](null);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance74($$self, $$props, $$invalidate) {
    const dispatch = createEventDispatcher();
    let { textbox = null } = $$props;
    let { column } = $$props;
    let { rowNumber } = $$props;
    let { row } = $$props;
    let prevColumn;
    let prevRow;
    beforeUpdate(() => {
      if (prevColumn !== column || prevRow !== row) {
        const updateTextbox = () => {
          if (textbox)
            $$invalidate(0, textbox.value = row.data[column.dataName], textbox);
        };
        if (textbox) {
          updateTextbox();
        } else {
          setTimeout(updateTextbox, 0);
        }
        prevColumn = column;
      }
    });
    afterUpdate(() => {
      if (prevRow !== row) {
        if (column.activeRow && column.activeRow === rowNumber && textbox) {
          textbox.focus();
        } else if (textbox === document.activeElement) {
          textbox.blur();
        }
        prevRow = row;
      }
    });
    function onFocus(event) {
      $$invalidate(4, column.activeRow = rowNumber, column);
    }
    function onBlur(event) {
      if (event.sourceCapabilities) {
        delete column.activeRow;
      }
    }
    function onInput(event) {
      const value = textbox.value;
      setTimeout(() => {
        dispatch("valueupdate", { row, column, value, rowNumber });
      }, 0);
    }
    function input_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        textbox = $$value;
        $$invalidate(0, textbox);
      });
    }
    $$self.$$set = ($$props2) => {
      if ("textbox" in $$props2)
        $$invalidate(0, textbox = $$props2.textbox);
      if ("column" in $$props2)
        $$invalidate(4, column = $$props2.column);
      if ("rowNumber" in $$props2)
        $$invalidate(5, rowNumber = $$props2.rowNumber);
      if ("row" in $$props2)
        $$invalidate(6, row = $$props2.row);
    };
    return [textbox, onFocus, onBlur, onInput, column, rowNumber, row, input_binding];
  }
  var Textbox_cell = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance74, create_fragment76, safe_not_equal, {
        textbox: 0,
        column: 4,
        rowNumber: 5,
        row: 6,
        onFocus: 1,
        onBlur: 2,
        onInput: 3
      });
    }
    get onFocus() {
      return this.$$.ctx[1];
    }
    get onBlur() {
      return this.$$.ctx[2];
    }
    get onInput() {
      return this.$$.ctx[3];
    }
  };
  var textbox_cell_default = Textbox_cell;

  // elos-web/src/Select.svelte
  function get_each_context7(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[4] = list[i];
    return child_ctx;
  }
  function create_each_block7(ctx) {
    let option;
    let t_value = ctx[4].name + "";
    let t;
    let option_value_value;
    return {
      c() {
        option = element("option");
        t = text(t_value);
        option.__value = option_value_value = ctx[4];
        option.value = option.__value;
      },
      m(target, anchor) {
        insert(target, option, anchor);
        append(option, t);
      },
      p(ctx2, dirty) {
        if (dirty & 2 && t_value !== (t_value = ctx2[4].name + ""))
          set_data(t, t_value);
        if (dirty & 2 && option_value_value !== (option_value_value = ctx2[4])) {
          option.__value = option_value_value;
          option.value = option.__value;
        }
      },
      d(detaching) {
        if (detaching)
          detach(option);
      }
    };
  }
  function create_fragment77(ctx) {
    let div;
    let label;
    let t0_value = ctx[1].label + "";
    let t0;
    let t1;
    let select;
    let mounted;
    let dispose;
    let each_value = ctx[1].options;
    let each_blocks = [];
    for (let i = 0; i < each_value.length; i += 1) {
      each_blocks[i] = create_each_block7(get_each_context7(ctx, each_value, i));
    }
    return {
      c() {
        div = element("div");
        label = element("label");
        t0 = text(t0_value);
        t1 = space();
        select = element("select");
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        if (ctx[0] === void 0)
          add_render_callback(() => ctx[3].call(select));
      },
      m(target, anchor) {
        insert(target, div, anchor);
        append(div, label);
        append(label, t0);
        append(div, t1);
        append(div, select);
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].m(select, null);
        }
        select_option(select, ctx[0]);
        if (!mounted) {
          dispose = listen(select, "change", ctx[3]);
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (dirty & 2 && t0_value !== (t0_value = ctx2[1].label + ""))
          set_data(t0, t0_value);
        if (dirty & 2) {
          each_value = ctx2[1].options;
          let i;
          for (i = 0; i < each_value.length; i += 1) {
            const child_ctx = get_each_context7(ctx2, each_value, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
            } else {
              each_blocks[i] = create_each_block7(child_ctx);
              each_blocks[i].c();
              each_blocks[i].m(select, null);
            }
          }
          for (; i < each_blocks.length; i += 1) {
            each_blocks[i].d(1);
          }
          each_blocks.length = each_value.length;
        }
        if (dirty & 3) {
          select_option(select, ctx2[0]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(div);
        destroy_each(each_blocks, detaching);
        mounted = false;
        dispose();
      }
    };
  }
  function instance75($$self, $$props, $$invalidate) {
    let { watcher } = $$props;
    let { selectValue = null } = $$props;
    let data = { label: "", options: [], value: null };
    onMount(async () => {
      console.log("Select mounted");
      if (watcher) {
        watcher.subscribe((val) => {
          if (val) {
            $$invalidate(1, data = val);
          }
        });
      }
    });
    function select_change_handler() {
      selectValue = select_value(this);
      $$invalidate(0, selectValue);
      $$invalidate(1, data);
    }
    $$self.$$set = ($$props2) => {
      if ("watcher" in $$props2)
        $$invalidate(2, watcher = $$props2.watcher);
      if ("selectValue" in $$props2)
        $$invalidate(0, selectValue = $$props2.selectValue);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 5) {
        $: {
          if (watcher && selectValue) {
            watcher.update((n) => {
              n.value = selectValue;
              return n;
            });
          }
        }
      }
    };
    return [selectValue, data, watcher, select_change_handler];
  }
  var Select = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance75, create_fragment77, safe_not_equal, { watcher: 2, selectValue: 0 });
    }
  };
  var Select_default = Select;

  // elos-web/src/DataGrid.svelte
  function create_if_block61(ctx) {
    let datagrid;
    let updating_rows;
    let updating_columns;
    let updating_allowResizeFromTableCells;
    let updating_allowResizeFromTableHeaders;
    let updating_allowColumnReordering;
    let updating_rowHeight;
    let current;
    function datagrid_rows_binding(value) {
      ctx[13](value);
    }
    function datagrid_columns_binding(value) {
      ctx[14](value);
    }
    function datagrid_allowResizeFromTableCells_binding(value) {
      ctx[15](value);
    }
    function datagrid_allowResizeFromTableHeaders_binding(value) {
      ctx[16](value);
    }
    function datagrid_allowColumnReordering_binding(value) {
      ctx[17](value);
    }
    function datagrid_rowHeight_binding(value) {
      ctx[18](value);
    }
    let datagrid_props = {};
    if (ctx[1].rows !== void 0) {
      datagrid_props.rows = ctx[1].rows;
    }
    if (ctx[1].columns !== void 0) {
      datagrid_props.columns = ctx[1].columns;
    }
    if (ctx[3] !== void 0) {
      datagrid_props.allowResizeFromTableCells = ctx[3];
    }
    if (ctx[4] !== void 0) {
      datagrid_props.allowResizeFromTableHeaders = ctx[4];
    }
    if (ctx[5] !== void 0) {
      datagrid_props.allowColumnReordering = ctx[5];
    }
    if (ctx[6] !== void 0) {
      datagrid_props.rowHeight = ctx[6];
    }
    datagrid = new import_svelte_data_grid.default({ props: datagrid_props });
    ctx[12](datagrid);
    binding_callbacks.push(() => bind(datagrid, "rows", datagrid_rows_binding));
    binding_callbacks.push(() => bind(datagrid, "columns", datagrid_columns_binding));
    binding_callbacks.push(() => bind(datagrid, "allowResizeFromTableCells", datagrid_allowResizeFromTableCells_binding));
    binding_callbacks.push(() => bind(datagrid, "allowResizeFromTableHeaders", datagrid_allowResizeFromTableHeaders_binding));
    binding_callbacks.push(() => bind(datagrid, "allowColumnReordering", datagrid_allowColumnReordering_binding));
    binding_callbacks.push(() => bind(datagrid, "rowHeight", datagrid_rowHeight_binding));
    datagrid.$on("valueUpdated", valueUpdated);
    return {
      c() {
        create_component(datagrid.$$.fragment);
      },
      m(target, anchor) {
        mount_component(datagrid, target, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        const datagrid_changes = {};
        if (!updating_rows && dirty & 2) {
          updating_rows = true;
          datagrid_changes.rows = ctx2[1].rows;
          add_flush_callback(() => updating_rows = false);
        }
        if (!updating_columns && dirty & 2) {
          updating_columns = true;
          datagrid_changes.columns = ctx2[1].columns;
          add_flush_callback(() => updating_columns = false);
        }
        if (!updating_allowResizeFromTableCells && dirty & 8) {
          updating_allowResizeFromTableCells = true;
          datagrid_changes.allowResizeFromTableCells = ctx2[3];
          add_flush_callback(() => updating_allowResizeFromTableCells = false);
        }
        if (!updating_allowResizeFromTableHeaders && dirty & 16) {
          updating_allowResizeFromTableHeaders = true;
          datagrid_changes.allowResizeFromTableHeaders = ctx2[4];
          add_flush_callback(() => updating_allowResizeFromTableHeaders = false);
        }
        if (!updating_allowColumnReordering && dirty & 32) {
          updating_allowColumnReordering = true;
          datagrid_changes.allowColumnReordering = ctx2[5];
          add_flush_callback(() => updating_allowColumnReordering = false);
        }
        if (!updating_rowHeight && dirty & 64) {
          updating_rowHeight = true;
          datagrid_changes.rowHeight = ctx2[6];
          add_flush_callback(() => updating_rowHeight = false);
        }
        datagrid.$set(datagrid_changes);
      },
      i(local) {
        if (current)
          return;
        transition_in(datagrid.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(datagrid.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        ctx[12](null);
        destroy_component(datagrid, detaching);
      }
    };
  }
  function create_fragment78(ctx) {
    let section;
    let button0;
    let t1;
    let button1;
    let t3;
    let select;
    let updating_watcher;
    let t4;
    let current;
    let mounted;
    let dispose;
    function select_watcher_binding(value) {
      ctx[11](value);
    }
    let select_props = {};
    if (ctx[7] !== void 0) {
      select_props.watcher = ctx[7];
    }
    select = new Select_default({ props: select_props });
    binding_callbacks.push(() => bind(select, "watcher", select_watcher_binding));
    let if_block = ctx[0] && create_if_block61(ctx);
    return {
      c() {
        section = element("section");
        button0 = element("button");
        button0.textContent = "Add";
        t1 = space();
        button1 = element("button");
        button1.textContent = "Save";
        t3 = space();
        create_component(select.$$.fragment);
        t4 = space();
        if (if_block)
          if_block.c();
        attr(section, "class", "grid-wrap svelte-10ftsu0");
      },
      m(target, anchor) {
        insert(target, section, anchor);
        append(section, button0);
        append(section, t1);
        append(section, button1);
        append(section, t3);
        mount_component(select, section, null);
        append(section, t4);
        if (if_block)
          if_block.m(section, null);
        current = true;
        if (!mounted) {
          dispose = [
            listen(button0, "click", addNewRow),
            listen(button1, "click", ctx[8])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        const select_changes = {};
        if (!updating_watcher && dirty & 128) {
          updating_watcher = true;
          select_changes.watcher = ctx2[7];
          add_flush_callback(() => updating_watcher = false);
        }
        select.$set(select_changes);
        if (ctx2[0]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
            if (dirty & 1) {
              transition_in(if_block, 1);
            }
          } else {
            if_block = create_if_block61(ctx2);
            if_block.c();
            transition_in(if_block, 1);
            if_block.m(section, null);
          }
        } else if (if_block) {
          group_outros();
          transition_out(if_block, 1, 1, () => {
            if_block = null;
          });
          check_outros();
        }
      },
      i(local) {
        if (current)
          return;
        transition_in(select.$$.fragment, local);
        transition_in(if_block);
        current = true;
      },
      o(local) {
        transition_out(select.$$.fragment, local);
        transition_out(if_block);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(section);
        destroy_component(select);
        if (if_block)
          if_block.d();
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function rowDefaults() {
    return {
      metric_id: null,
      entity_id: "me",
      name: "stress",
      value_string: null,
      timestamp: Date.now()
    };
  }
  function addNewRow() {
    rows.push(rowDefaults());
    rows = rows;
  }
  function zip(keys, vals) {
    return keys.reduce((m, key, index) => {
      m[key] = vals[index];
      return m;
    }, {});
  }
  function renderRows(data) {
    return data.rows.map((row, row_i) => {
      return zip(data.columns, row);
    });
  }
  function valueUpdated(e) {
    console.log("value updated", e);
  }
  function instance76($$self, $$props, $$invalidate) {
    let grid;
    let allowResizeFromTableCells = true;
    let allowResizeFromTableHeaders = true;
    let allowColumnReordering = true;
    let rowHeight = 50;
    const updateData = async () => {
      let results = await _fetch(`/api/db/${dbName}`);
      console.log("[DataGrid] Fetch", results);
      columns = renderColumns(results["columns"]);
      rows = renderRows(results);
    };
    function renderColumns(columns2) {
      let grid_el = document.getElementsByClassName("grid-wrap");
      if (grid_el == void 0) {
        return;
      }
      return columns2.map((val, i) => {
        console.log(val);
        return {
          display: val,
          dataName: val,
          width: grid_el == void 0 ? Math.floor(grid_el.clientWidth / columns2.length) : 75,
          cellComponent: textbox_cell_default
        };
      });
    }
    function pushValues() {
      const { columns: columns2 } = grid.get();
      _send("/api/db/metrics", params = {
        body: { columns: grid.get(), rows: grid.data }
      }).then((response) => {
        console.log(response);
      }).catch((error) => {
        console.log("got error on fetch", error);
      });
    }
    let { dataStore: dataStore2 = null } = $$props;
    let { dataKey = null } = $$props;
    let { selectedTable = null } = $$props;
    let { data = {
      rows: [],
      columns: [],
      name: "",
      storeName: "",
      category: "metrics"
    } } = $$props;
    let tableTypes = {
      stress: {
        storeName: "profile",
        name: "stress",
        fields: ["name", "value", "range", "at"]
      },
      calories: {
        storeName: "profile",
        name: "calories",
        fields: ["name", "count", "from", "at"]
      }
    };
    let selectWatcher = writable({
      label: "Data Types",
      options: Object.values(tableTypes),
      value: selectedTable || Object.values(tableTypes)[0]
    });
    onMount(async () => {
      console.log("DataGrid mounted");
      if (dataStore2) {
        dataStore2.subscribe((val) => {
          console.log("[DataGrid] profile updated", val);
        });
      }
      if (selectWatcher) {
        selectWatcher.subscribe((val) => {
          console.log("[DataGrid] selectWatcher updated", val, dataKey);
          $$invalidate(0, selectedTable = val.value);
          if (selectedTable) {
            $$invalidate(1, data.store = stores[selectedTable.storeName], data);
            $$invalidate(1, data.columns = selectedTable.fields.map((field) => ({
              display: field,
              dataName: field,
              width: 100
            })), data);
            $$invalidate(1, data.rows = get_store_value(data.store)[dataKey].filter((x) => x.name == selectedTable.name), data);
            console.log("=>>", data.rows);
          }
        });
      }
    });
    function select_watcher_binding(value) {
      selectWatcher = value;
      $$invalidate(7, selectWatcher);
    }
    function datagrid_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        grid = $$value;
        $$invalidate(2, grid);
      });
    }
    function datagrid_rows_binding(value) {
      if ($$self.$$.not_equal(data.rows, value)) {
        data.rows = value;
        $$invalidate(1, data);
      }
    }
    function datagrid_columns_binding(value) {
      if ($$self.$$.not_equal(data.columns, value)) {
        data.columns = value;
        $$invalidate(1, data);
      }
    }
    function datagrid_allowResizeFromTableCells_binding(value) {
      allowResizeFromTableCells = value;
      $$invalidate(3, allowResizeFromTableCells);
    }
    function datagrid_allowResizeFromTableHeaders_binding(value) {
      allowResizeFromTableHeaders = value;
      $$invalidate(4, allowResizeFromTableHeaders);
    }
    function datagrid_allowColumnReordering_binding(value) {
      allowColumnReordering = value;
      $$invalidate(5, allowColumnReordering);
    }
    function datagrid_rowHeight_binding(value) {
      rowHeight = value;
      $$invalidate(6, rowHeight);
    }
    $$self.$$set = ($$props2) => {
      if ("dataStore" in $$props2)
        $$invalidate(9, dataStore2 = $$props2.dataStore);
      if ("dataKey" in $$props2)
        $$invalidate(10, dataKey = $$props2.dataKey);
      if ("selectedTable" in $$props2)
        $$invalidate(0, selectedTable = $$props2.selectedTable);
      if ("data" in $$props2)
        $$invalidate(1, data = $$props2.data);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 4) {
        $: {
          if (grid) {
            grid.$on("[DataGrid] valueUpdated", (e) => {
              console.log("grid value updated", e);
            });
          }
        }
      }
    };
    return [
      selectedTable,
      data,
      grid,
      allowResizeFromTableCells,
      allowResizeFromTableHeaders,
      allowColumnReordering,
      rowHeight,
      selectWatcher,
      pushValues,
      dataStore2,
      dataKey,
      select_watcher_binding,
      datagrid_binding,
      datagrid_rows_binding,
      datagrid_columns_binding,
      datagrid_allowResizeFromTableCells_binding,
      datagrid_allowResizeFromTableHeaders_binding,
      datagrid_allowColumnReordering_binding,
      datagrid_rowHeight_binding
    ];
  }
  var DataGrid_1 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance76, create_fragment78, safe_not_equal, {
        dataStore: 9,
        dataKey: 10,
        selectedTable: 0,
        data: 1
      });
    }
  };
  var DataGrid_default = DataGrid_1;

  // elos-web/src/config/polls.js
  var pollTypes = [
    {
      title: "Calories",
      name: "calories",
      context: "food",
      category: "personal_metric",
      fields: [
        {
          label: "Count",
          name: "count",
          type: "number",
          showValue: false
        },
        {
          label: "From",
          name: "from",
          type: "text",
          showValue: false
        }
      ]
    },
    {
      title: "Weight",
      name: "weight",
      context: "body",
      category: "personal_metric",
      fields: [
        {
          label: "Lb",
          name: "value",
          type: "number",
          showValue: false
        }
      ]
    },
    {
      title: "Current Stress",
      name: "stress",
      context: "current_time",
      category: "personal_metric",
      fields: [{
        label: "",
        name: "stress",
        type: "slider",
        min: 0,
        max: 10,
        showValue: true
      }]
    },
    {
      title: "Brain Clearing",
      name: "clearing",
      message: "Write at least 100 words. Any words.",
      affinity: "morning",
      category: "session_prompt",
      fields: [{
        label: "",
        name: "entry",
        type: "entry",
        showValue: false
      }]
    },
    {
      title: "Day Start",
      name: "start",
      message: "What is your main focus today?",
      affinity: "morning",
      category: "session_prompt",
      fields: [{
        label: "",
        name: "entry",
        type: "entry",
        showValue: false
      }]
    },
    {
      title: "Day Evening",
      name: "interlude",
      message: "What are you most proud of today?",
      affinity: "evening",
      category: "session_prompt",
      fields: [{
        label: "",
        name: "entry",
        type: "entry",
        showValue: false
      }]
    },
    {
      title: "Day Check-in",
      name: "check_in",
      message: "What's on your mind?",
      affinity: "checkin",
      category: "session_prompt",
      fields: [{
        label: "",
        name: "entry",
        type: "entry",
        showValue: false
      }]
    }
  ];
  var fieldTypes = {
    "entry_type": {
      label: "Choose an Entry Type",
      type: "select",
      options: pollTypes
    },
    "slider": {
      label: "Feeling 0-10",
      type: "slider",
      min: 0,
      max: 10
    },
    "entry": {
      type: "textarea",
      rows: 4,
      cols: 50
    },
    "text": {
      type: "input",
      format: "text"
    },
    "number": {
      type: "input",
      format: "number"
    }
  };

  // elos-web/src/EntryForm.svelte
  function get_each_context8(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[15] = list[i];
    child_ctx[16] = list;
    child_ctx[17] = i;
    return child_ctx;
  }
  function get_each_context_13(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[18] = list[i];
    return child_ctx;
  }
  function create_if_block62(ctx) {
    let label0;
    let t0_value = ctx[0].title + "";
    let t0;
    let label0_for_value;
    let t1;
    let label1;
    let t2;
    let t3;
    let input;
    let mounted;
    let dispose;
    let if_block = ctx[0].message && create_if_block_8(ctx);
    let each_value = ctx[0].fields;
    let each_blocks = [];
    for (let i = 0; i < each_value.length; i += 1) {
      each_blocks[i] = create_each_block8(get_each_context8(ctx, each_value, i));
    }
    return {
      c() {
        label0 = element("label");
        t0 = text(t0_value);
        t1 = space();
        label1 = element("label");
        if (if_block)
          if_block.c();
        t2 = space();
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        t3 = space();
        input = element("input");
        attr(label0, "for", label0_for_value = ctx[0].name);
        attr(label1, "name", "sub-title");
        attr(input, "type", "submit");
        input.value = "Submit";
        attr(input, "class", "svelte-17rnl1l");
      },
      m(target, anchor) {
        insert(target, label0, anchor);
        append(label0, t0);
        insert(target, t1, anchor);
        insert(target, label1, anchor);
        if (if_block)
          if_block.m(label1, null);
        insert(target, t2, anchor);
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].m(target, anchor);
        }
        insert(target, t3, anchor);
        insert(target, input, anchor);
        if (!mounted) {
          dispose = listen(input, "submit", prevent_default(ctx[2]));
          mounted = true;
        }
      },
      p(ctx2, dirty) {
        if (dirty & 1 && t0_value !== (t0_value = ctx2[0].title + ""))
          set_data(t0, t0_value);
        if (dirty & 1 && label0_for_value !== (label0_for_value = ctx2[0].name)) {
          attr(label0, "for", label0_for_value);
        }
        if (ctx2[0].message) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block_8(ctx2);
            if_block.c();
            if_block.m(label1, null);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
        if (dirty & 1) {
          each_value = ctx2[0].fields;
          let i;
          for (i = 0; i < each_value.length; i += 1) {
            const child_ctx = get_each_context8(ctx2, each_value, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
            } else {
              each_blocks[i] = create_each_block8(child_ctx);
              each_blocks[i].c();
              each_blocks[i].m(t3.parentNode, t3);
            }
          }
          for (; i < each_blocks.length; i += 1) {
            each_blocks[i].d(1);
          }
          each_blocks.length = each_value.length;
        }
      },
      d(detaching) {
        if (detaching)
          detach(label0);
        if (detaching)
          detach(t1);
        if (detaching)
          detach(label1);
        if (if_block)
          if_block.d();
        if (detaching)
          detach(t2);
        destroy_each(each_blocks, detaching);
        if (detaching)
          detach(t3);
        if (detaching)
          detach(input);
        mounted = false;
        dispose();
      }
    };
  }
  function create_if_block_8(ctx) {
    let span;
    let t_value = ctx[0].message + "";
    let t;
    return {
      c() {
        span = element("span");
        t = text(t_value);
      },
      m(target, anchor) {
        insert(target, span, anchor);
        append(span, t);
      },
      p(ctx2, dirty) {
        if (dirty & 1 && t_value !== (t_value = ctx2[0].message + ""))
          set_data(t, t_value);
      },
      d(detaching) {
        if (detaching)
          detach(span);
      }
    };
  }
  function create_if_block_7(ctx) {
    let span;
    let t_value = ctx[15].label + "";
    let t;
    return {
      c() {
        span = element("span");
        t = text(t_value);
      },
      m(target, anchor) {
        insert(target, span, anchor);
        append(span, t);
      },
      p(ctx2, dirty) {
        if (dirty & 1 && t_value !== (t_value = ctx2[15].label + ""))
          set_data(t, t_value);
      },
      d(detaching) {
        if (detaching)
          detach(span);
      }
    };
  }
  function create_if_block_6(ctx) {
    let span;
    let t_value = ctx[15].value + "";
    let t;
    return {
      c() {
        span = element("span");
        t = text(t_value);
      },
      m(target, anchor) {
        insert(target, span, anchor);
        append(span, t);
      },
      p(ctx2, dirty) {
        if (dirty & 1 && t_value !== (t_value = ctx2[15].value + ""))
          set_data(t, t_value);
      },
      d(detaching) {
        if (detaching)
          detach(span);
      }
    };
  }
  function create_if_block_5(ctx) {
    let input;
    let input_id_value;
    let input_name_value;
    let input_min_value;
    let input_max_value;
    let mounted;
    let dispose;
    function input_change_input_handler() {
      ctx[13].call(input, ctx[16], ctx[17]);
    }
    return {
      c() {
        input = element("input");
        attr(input, "id", input_id_value = ctx[15].name);
        attr(input, "name", input_name_value = ctx[15].name);
        attr(input, "class", "slider svelte-17rnl1l");
        attr(input, "type", "range");
        attr(input, "min", input_min_value = ctx[15].min);
        attr(input, "max", input_max_value = ctx[15].max);
      },
      m(target, anchor) {
        insert(target, input, anchor);
        set_input_value(input, ctx[15].value);
        if (!mounted) {
          dispose = [
            listen(input, "change", input_change_input_handler),
            listen(input, "input", input_change_input_handler)
          ];
          mounted = true;
        }
      },
      p(new_ctx, dirty) {
        ctx = new_ctx;
        if (dirty & 1 && input_id_value !== (input_id_value = ctx[15].name)) {
          attr(input, "id", input_id_value);
        }
        if (dirty & 1 && input_name_value !== (input_name_value = ctx[15].name)) {
          attr(input, "name", input_name_value);
        }
        if (dirty & 1 && input_min_value !== (input_min_value = ctx[15].min)) {
          attr(input, "min", input_min_value);
        }
        if (dirty & 1 && input_max_value !== (input_max_value = ctx[15].max)) {
          attr(input, "max", input_max_value);
        }
        if (dirty & 1) {
          set_input_value(input, ctx[15].value);
        }
      },
      d(detaching) {
        if (detaching)
          detach(input);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function create_if_block_4(ctx) {
    let textarea;
    let textarea_id_value;
    let textarea_name_value;
    let textarea_placeholder_value;
    let textarea_rows_value;
    let textarea_cols_value;
    let mounted;
    let dispose;
    function textarea_input_handler() {
      ctx[12].call(textarea, ctx[16], ctx[17]);
    }
    return {
      c() {
        textarea = element("textarea");
        attr(textarea, "id", textarea_id_value = ctx[15].name);
        attr(textarea, "name", textarea_name_value = ctx[15].name);
        attr(textarea, "placeholder", textarea_placeholder_value = ctx[15].placeholder);
        set_style(textarea, "height", "200px");
        attr(textarea, "rows", textarea_rows_value = ctx[15].rows || 2);
        attr(textarea, "cols", textarea_cols_value = ctx[15].cols || 20);
        attr(textarea, "class", "svelte-17rnl1l");
      },
      m(target, anchor) {
        insert(target, textarea, anchor);
        set_input_value(textarea, ctx[15].value);
        if (!mounted) {
          dispose = listen(textarea, "input", textarea_input_handler);
          mounted = true;
        }
      },
      p(new_ctx, dirty) {
        ctx = new_ctx;
        if (dirty & 1 && textarea_id_value !== (textarea_id_value = ctx[15].name)) {
          attr(textarea, "id", textarea_id_value);
        }
        if (dirty & 1 && textarea_name_value !== (textarea_name_value = ctx[15].name)) {
          attr(textarea, "name", textarea_name_value);
        }
        if (dirty & 1 && textarea_placeholder_value !== (textarea_placeholder_value = ctx[15].placeholder)) {
          attr(textarea, "placeholder", textarea_placeholder_value);
        }
        if (dirty & 1 && textarea_rows_value !== (textarea_rows_value = ctx[15].rows || 2)) {
          attr(textarea, "rows", textarea_rows_value);
        }
        if (dirty & 1 && textarea_cols_value !== (textarea_cols_value = ctx[15].cols || 20)) {
          attr(textarea, "cols", textarea_cols_value);
        }
        if (dirty & 1) {
          set_input_value(textarea, ctx[15].value);
        }
      },
      d(detaching) {
        if (detaching)
          detach(textarea);
        mounted = false;
        dispose();
      }
    };
  }
  function create_if_block_32(ctx) {
    let select;
    let select_id_value;
    let select_name_value;
    let mounted;
    let dispose;
    let each_value_1 = ctx[15].options;
    let each_blocks = [];
    for (let i = 0; i < each_value_1.length; i += 1) {
      each_blocks[i] = create_each_block_13(get_each_context_13(ctx, each_value_1, i));
    }
    function select_change_handler() {
      ctx[11].call(select, ctx[16], ctx[17]);
    }
    return {
      c() {
        select = element("select");
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        attr(select, "id", select_id_value = ctx[15].name);
        attr(select, "name", select_name_value = ctx[15].name);
        attr(select, "class", "svelte-17rnl1l");
        if (ctx[15].value === void 0)
          add_render_callback(select_change_handler);
      },
      m(target, anchor) {
        insert(target, select, anchor);
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].m(select, null);
        }
        select_option(select, ctx[15].value);
        if (!mounted) {
          dispose = listen(select, "change", select_change_handler);
          mounted = true;
        }
      },
      p(new_ctx, dirty) {
        ctx = new_ctx;
        if (dirty & 1) {
          each_value_1 = ctx[15].options;
          let i;
          for (i = 0; i < each_value_1.length; i += 1) {
            const child_ctx = get_each_context_13(ctx, each_value_1, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
            } else {
              each_blocks[i] = create_each_block_13(child_ctx);
              each_blocks[i].c();
              each_blocks[i].m(select, null);
            }
          }
          for (; i < each_blocks.length; i += 1) {
            each_blocks[i].d(1);
          }
          each_blocks.length = each_value_1.length;
        }
        if (dirty & 1 && select_id_value !== (select_id_value = ctx[15].name)) {
          attr(select, "id", select_id_value);
        }
        if (dirty & 1 && select_name_value !== (select_name_value = ctx[15].name)) {
          attr(select, "name", select_name_value);
        }
        if (dirty & 1) {
          select_option(select, ctx[15].value);
        }
      },
      d(detaching) {
        if (detaching)
          detach(select);
        destroy_each(each_blocks, detaching);
        mounted = false;
        dispose();
      }
    };
  }
  function create_if_block_24(ctx) {
    let input;
    let input_id_value;
    let input_name_value;
    let input_placeholder_value;
    let mounted;
    let dispose;
    function input_input_handler_1() {
      ctx[10].call(input, ctx[16], ctx[17]);
    }
    return {
      c() {
        input = element("input");
        attr(input, "id", input_id_value = ctx[15].name);
        attr(input, "type", "text");
        attr(input, "name", input_name_value = ctx[15].name);
        attr(input, "placeholder", input_placeholder_value = ctx[15].placeholder);
        attr(input, "class", "svelte-17rnl1l");
      },
      m(target, anchor) {
        insert(target, input, anchor);
        set_input_value(input, ctx[15].value);
        if (!mounted) {
          dispose = listen(input, "input", input_input_handler_1);
          mounted = true;
        }
      },
      p(new_ctx, dirty) {
        ctx = new_ctx;
        if (dirty & 1 && input_id_value !== (input_id_value = ctx[15].name)) {
          attr(input, "id", input_id_value);
        }
        if (dirty & 1 && input_name_value !== (input_name_value = ctx[15].name)) {
          attr(input, "name", input_name_value);
        }
        if (dirty & 1 && input_placeholder_value !== (input_placeholder_value = ctx[15].placeholder)) {
          attr(input, "placeholder", input_placeholder_value);
        }
        if (dirty & 1 && input.value !== ctx[15].value) {
          set_input_value(input, ctx[15].value);
        }
      },
      d(detaching) {
        if (detaching)
          detach(input);
        mounted = false;
        dispose();
      }
    };
  }
  function create_if_block_15(ctx) {
    let input;
    let input_id_value;
    let input_name_value;
    let input_placeholder_value;
    let mounted;
    let dispose;
    function input_input_handler() {
      ctx[9].call(input, ctx[16], ctx[17]);
    }
    return {
      c() {
        input = element("input");
        attr(input, "id", input_id_value = ctx[15].name);
        attr(input, "type", "number");
        attr(input, "name", input_name_value = ctx[15].name);
        attr(input, "placeholder", input_placeholder_value = ctx[15].placeholder);
        attr(input, "class", "svelte-17rnl1l");
      },
      m(target, anchor) {
        insert(target, input, anchor);
        set_input_value(input, ctx[15].value);
        if (!mounted) {
          dispose = listen(input, "input", input_input_handler);
          mounted = true;
        }
      },
      p(new_ctx, dirty) {
        ctx = new_ctx;
        if (dirty & 1 && input_id_value !== (input_id_value = ctx[15].name)) {
          attr(input, "id", input_id_value);
        }
        if (dirty & 1 && input_name_value !== (input_name_value = ctx[15].name)) {
          attr(input, "name", input_name_value);
        }
        if (dirty & 1 && input_placeholder_value !== (input_placeholder_value = ctx[15].placeholder)) {
          attr(input, "placeholder", input_placeholder_value);
        }
        if (dirty & 1 && to_number(input.value) !== ctx[15].value) {
          set_input_value(input, ctx[15].value);
        }
      },
      d(detaching) {
        if (detaching)
          detach(input);
        mounted = false;
        dispose();
      }
    };
  }
  function create_each_block_13(ctx) {
    let option;
    let t_value = ctx[18].title + "";
    let t;
    let option_value_value;
    let mounted;
    let dispose;
    return {
      c() {
        option = element("option");
        t = text(t_value);
        option.__value = option_value_value = ctx[18].value;
        option.value = option.__value;
      },
      m(target, anchor) {
        insert(target, option, anchor);
        append(option, t);
        if (!mounted) {
          dispose = listen(option, "change", ctx[7]);
          mounted = true;
        }
      },
      p(ctx2, dirty) {
        if (dirty & 1 && t_value !== (t_value = ctx2[18].title + ""))
          set_data(t, t_value);
        if (dirty & 1 && option_value_value !== (option_value_value = ctx2[18].value)) {
          option.__value = option_value_value;
          option.value = option.__value;
        }
      },
      d(detaching) {
        if (detaching)
          detach(option);
        mounted = false;
        dispose();
      }
    };
  }
  function create_each_block8(ctx) {
    let label;
    let t0;
    let label_for_value;
    let t1;
    let if_block2_anchor;
    let if_block0 = ctx[15].label && create_if_block_7(ctx);
    let if_block1 = ctx[15].value && ctx[15].showValue && create_if_block_6(ctx);
    function select_block_type(ctx2, dirty) {
      if (ctx2[15].type === "number")
        return create_if_block_15;
      if (ctx2[15].type === "text")
        return create_if_block_24;
      if (ctx2[15].type === "select")
        return create_if_block_32;
      if (ctx2[15].type === "entry")
        return create_if_block_4;
      if (ctx2[15].type === "slider")
        return create_if_block_5;
    }
    let current_block_type = select_block_type(ctx, -1);
    let if_block2 = current_block_type && current_block_type(ctx);
    return {
      c() {
        label = element("label");
        if (if_block0)
          if_block0.c();
        t0 = space();
        if (if_block1)
          if_block1.c();
        t1 = space();
        if (if_block2)
          if_block2.c();
        if_block2_anchor = empty();
        attr(label, "for", label_for_value = ctx[15].name);
      },
      m(target, anchor) {
        insert(target, label, anchor);
        if (if_block0)
          if_block0.m(label, null);
        append(label, t0);
        if (if_block1)
          if_block1.m(label, null);
        insert(target, t1, anchor);
        if (if_block2)
          if_block2.m(target, anchor);
        insert(target, if_block2_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (ctx2[15].label) {
          if (if_block0) {
            if_block0.p(ctx2, dirty);
          } else {
            if_block0 = create_if_block_7(ctx2);
            if_block0.c();
            if_block0.m(label, t0);
          }
        } else if (if_block0) {
          if_block0.d(1);
          if_block0 = null;
        }
        if (ctx2[15].value && ctx2[15].showValue) {
          if (if_block1) {
            if_block1.p(ctx2, dirty);
          } else {
            if_block1 = create_if_block_6(ctx2);
            if_block1.c();
            if_block1.m(label, null);
          }
        } else if (if_block1) {
          if_block1.d(1);
          if_block1 = null;
        }
        if (dirty & 1 && label_for_value !== (label_for_value = ctx2[15].name)) {
          attr(label, "for", label_for_value);
        }
        if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if (if_block2)
            if_block2.d(1);
          if_block2 = current_block_type && current_block_type(ctx2);
          if (if_block2) {
            if_block2.c();
            if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
          }
        }
      },
      d(detaching) {
        if (detaching)
          detach(label);
        if (if_block0)
          if_block0.d();
        if (if_block1)
          if_block1.d();
        if (detaching)
          detach(t1);
        if (if_block2) {
          if_block2.d(detaching);
        }
        if (detaching)
          detach(if_block2_anchor);
      }
    };
  }
  function create_fragment79(ctx) {
    let section;
    let div;
    let select;
    let updating_watcher;
    let t;
    let form;
    let current;
    let mounted;
    let dispose;
    function select_watcher_binding(value) {
      ctx[8](value);
    }
    let select_props = {};
    if (ctx[1] !== void 0) {
      select_props.watcher = ctx[1];
    }
    select = new Select_default({ props: select_props });
    binding_callbacks.push(() => bind(select, "watcher", select_watcher_binding));
    let if_block = ctx[0] && create_if_block62(ctx);
    return {
      c() {
        section = element("section");
        div = element("div");
        create_component(select.$$.fragment);
        t = space();
        form = element("form");
        if (if_block)
          if_block.c();
        attr(form, "id", "entryform");
        attr(div, "class", "container svelte-17rnl1l");
      },
      m(target, anchor) {
        insert(target, section, anchor);
        append(section, div);
        mount_component(select, div, null);
        append(div, t);
        append(div, form);
        if (if_block)
          if_block.m(form, null);
        current = true;
        if (!mounted) {
          dispose = [
            listen(form, "submit", stop_propagation(prevent_default(ctx[2]))),
            listen(div, "pointerdown", stop_propagation(ctx[6]))
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        const select_changes = {};
        if (!updating_watcher && dirty & 2) {
          updating_watcher = true;
          select_changes.watcher = ctx2[1];
          add_flush_callback(() => updating_watcher = false);
        }
        select.$set(select_changes);
        if (ctx2[0]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block62(ctx2);
            if_block.c();
            if_block.m(form, null);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      i(local) {
        if (current)
          return;
        transition_in(select.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(select.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(section);
        destroy_component(select);
        if (if_block)
          if_block.d();
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance77($$self, $$props, $$invalidate) {
    const dispatch = createEventDispatcher();
    let { item: item2 } = $$props;
    let { dataStore: dataStore2 = null } = $$props;
    let { dataKey = "metrics" } = $$props;
    let { selectedForm = null } = $$props;
    function doSubmit(e) {
      let selector = document.querySelector("#entryform");
      let data = new FormData(selector);
      if (dataStore2) {
        console.log("EntryForm got data", data);
        dataStore2.update((n) => {
          console.log("datastore got data", n);
          n[dataKey] = n[dataKey] || {};
          n[dataKey][selectedForm.name] = [
            ...n[dataKey][selectedForm.name] || [],
            {
              name: selectedForm.name,
              title: selectedForm.title,
              category: selectedForm.category,
              context: selectedForm.context,
              at: Date.now(),
              data: selectedForm.fields.map((n2) => {
                return [n2.name, n2.value];
              })
            }
          ];
          return n;
        });
      }
    }
    let formWatcher = writable({ ...fieldTypes.entry_type, value: null });
    onMount(async () => {
      console.log("EntryForm mounted");
      if (formWatcher) {
        formWatcher.subscribe((val) => {
          console.log("selectedForm updated", val);
          $$invalidate(0, selectedForm = val.value);
        });
      }
    });
    function pointerdown_handler(event) {
      bubble.call(this, $$self, event);
    }
    function change_handler(event) {
      bubble.call(this, $$self, event);
    }
    function select_watcher_binding(value) {
      formWatcher = value;
      $$invalidate(1, formWatcher);
    }
    function input_input_handler(each_value, field_index) {
      each_value[field_index].value = to_number(this.value);
      $$invalidate(0, selectedForm);
    }
    function input_input_handler_1(each_value, field_index) {
      each_value[field_index].value = this.value;
      $$invalidate(0, selectedForm);
    }
    function select_change_handler(each_value, field_index) {
      each_value[field_index].value = select_value(this);
      $$invalidate(0, selectedForm);
    }
    function textarea_input_handler(each_value, field_index) {
      each_value[field_index].value = this.value;
      $$invalidate(0, selectedForm);
    }
    function input_change_input_handler(each_value, field_index) {
      each_value[field_index].value = to_number(this.value);
      $$invalidate(0, selectedForm);
    }
    $$self.$$set = ($$props2) => {
      if ("item" in $$props2)
        $$invalidate(3, item2 = $$props2.item);
      if ("dataStore" in $$props2)
        $$invalidate(4, dataStore2 = $$props2.dataStore);
      if ("dataKey" in $$props2)
        $$invalidate(5, dataKey = $$props2.dataKey);
      if ("selectedForm" in $$props2)
        $$invalidate(0, selectedForm = $$props2.selectedForm);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 1) {
        $:
          selectedForm;
      }
    };
    return [
      selectedForm,
      formWatcher,
      doSubmit,
      item2,
      dataStore2,
      dataKey,
      pointerdown_handler,
      change_handler,
      select_watcher_binding,
      input_input_handler,
      input_input_handler_1,
      select_change_handler,
      textarea_input_handler,
      input_change_input_handler
    ];
  }
  var EntryForm = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance77, create_fragment79, safe_not_equal, {
        item: 3,
        dataStore: 4,
        dataKey: 5,
        selectedForm: 0
      });
    }
  };
  var EntryForm_default = EntryForm;

  // elos-web/src/ImageGallery.svelte
  function get_each_context9(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[7] = list[i];
    return child_ctx;
  }
  function create_else_block7(ctx) {
    let t;
    return {
      c() {
        t = text("No Data");
      },
      m(target, anchor) {
        insert(target, t, anchor);
      },
      d(detaching) {
        if (detaching)
          detach(t);
      }
    };
  }
  function create_each_block9(ctx) {
    let p;
    let t0_value = ctx[7] + "";
    let t0;
    let t1;
    let img;
    let img_src_value;
    return {
      c() {
        p = element("p");
        t0 = text(t0_value);
        t1 = space();
        img = element("img");
        if (!src_url_equal(img.src, img_src_value = ctx[7]))
          attr(img, "src", img_src_value);
        attr(img, "class", "svelte-z741zk");
      },
      m(target, anchor) {
        insert(target, p, anchor);
        append(p, t0);
        insert(target, t1, anchor);
        insert(target, img, anchor);
      },
      p(ctx2, dirty) {
        if (dirty & 1 && t0_value !== (t0_value = ctx2[7] + ""))
          set_data(t0, t0_value);
        if (dirty & 1 && !src_url_equal(img.src, img_src_value = ctx2[7])) {
          attr(img, "src", img_src_value);
        }
      },
      d(detaching) {
        if (detaching)
          detach(p);
        if (detaching)
          detach(t1);
        if (detaching)
          detach(img);
      }
    };
  }
  function create_fragment80(ctx) {
    let section;
    let div1;
    let div0;
    let each_value = ctx[0];
    let each_blocks = [];
    for (let i = 0; i < each_value.length; i += 1) {
      each_blocks[i] = create_each_block9(get_each_context9(ctx, each_value, i));
    }
    let each_1_else = null;
    if (!each_value.length) {
      each_1_else = create_else_block7(ctx);
    }
    return {
      c() {
        section = element("section");
        div1 = element("div");
        div0 = element("div");
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        if (each_1_else) {
          each_1_else.c();
        }
        attr(div0, "class", "column svelte-z741zk");
        attr(div1, "class", "row svelte-z741zk");
      },
      m(target, anchor) {
        insert(target, section, anchor);
        append(section, div1);
        append(div1, div0);
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].m(div0, null);
        }
        if (each_1_else) {
          each_1_else.m(div0, null);
        }
      },
      p(ctx2, [dirty]) {
        if (dirty & 1) {
          each_value = ctx2[0];
          let i;
          for (i = 0; i < each_value.length; i += 1) {
            const child_ctx = get_each_context9(ctx2, each_value, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
            } else {
              each_blocks[i] = create_each_block9(child_ctx);
              each_blocks[i].c();
              each_blocks[i].m(div0, null);
            }
          }
          for (; i < each_blocks.length; i += 1) {
            each_blocks[i].d(1);
          }
          each_blocks.length = each_value.length;
          if (each_value.length) {
            if (each_1_else) {
              each_1_else.d(1);
              each_1_else = null;
            }
          } else if (!each_1_else) {
            each_1_else = create_else_block7(ctx2);
            each_1_else.c();
            each_1_else.m(div0, null);
          }
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(section);
        destroy_each(each_blocks, detaching);
        if (each_1_else)
          each_1_else.d();
      }
    };
  }
  function instance78($$self, $$props, $$invalidate) {
    const omit_props_names = ["images", "imageLinks", "dataStore"];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let { images = [] } = $$props;
    let { imageLinks = [] } = $$props;
    let { dataStore: dataStore2 } = $$props;
    let elements = document.getElementsByClassName("column");
    function scale(percent = 25) {
      for (let i = 0; i < elements.length; i++) {
        elements[i].style.flex = `${percent}%`;
      }
    }
    onMount(async () => {
      console.log("ImageGallery mounted", $$props, $$restProps);
      if (dataStore2 !== void 0) {
        dataStore2.subscribe((val) => {
          if (val === void 0) {
            console.log("ImageGallery dataStore had no value?", get_store_value(dataStore2));
            return;
          }
          console.log("ImageGallery dataStore got update", val);
          if (val.files !== void 0 && val.files.length > 0) {
            $$invalidate(1, images = val.files);
          }
        });
      }
    });
    $$self.$$set = ($$new_props) => {
      $$invalidate(6, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
      $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("images" in $$new_props)
        $$invalidate(1, images = $$new_props.images);
      if ("imageLinks" in $$new_props)
        $$invalidate(0, imageLinks = $$new_props.imageLinks);
      if ("dataStore" in $$new_props)
        $$invalidate(2, dataStore2 = $$new_props.dataStore);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 2) {
        $:
          $$invalidate(0, imageLinks = images.slice(0, 9).map((img) => {
            return `/api/load?filepath=${img.locations[0].split("/Volumes/FATMAN/")[1]}`;
          }));
      }
      if ($$self.$$.dirty & 3) {
        $:
          console.log("images: ", imageLinks, images);
      }
    };
    $$props = exclude_internal_props($$props);
    return [imageLinks, images, dataStore2];
  }
  var ImageGallery = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance78, create_fragment80, safe_not_equal, { images: 1, imageLinks: 0, dataStore: 2 });
    }
  };
  var ImageGallery_default = ImageGallery;

  // elos-web/src/PkgEntry.svelte
  function create_fragment81(ctx) {
    let div2;
    let div0;
    let h2;
    let t1;
    let span0;
    let t2_value = ctx[0]["metadata.format"] + "";
    let t2;
    let t3;
    let span1;
    let t4_value = ctx[0]["metadata.content.variation"] + "";
    let t4;
    let t5;
    let div1;
    let div2_class_value;
    return {
      c() {
        div2 = element("div");
        div0 = element("div");
        h2 = element("h2");
        h2.textContent = `${title}`;
        t1 = space();
        span0 = element("span");
        t2 = text(t2_value);
        t3 = text("\n     |\n    ");
        span1 = element("span");
        t4 = text(t4_value);
        t5 = space();
        div1 = element("div");
        attr(h2, "class", "svelte-346eva");
        attr(span0, "class", "tag-box svelte-346eva");
        attr(span1, "class", "tag-box svelte-346eva");
        attr(div0, "class", "main");
        attr(div1, "class", "editor");
        attr(div2, "class", div2_class_value = "container " + ctx[1]() + " svelte-346eva");
      },
      m(target, anchor) {
        insert(target, div2, anchor);
        append(div2, div0);
        append(div0, h2);
        append(div0, t1);
        append(div0, span0);
        append(span0, t2);
        append(div0, t3);
        append(div0, span1);
        append(span1, t4);
        append(div2, t5);
        append(div2, div1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 1 && t2_value !== (t2_value = ctx2[0]["metadata.format"] + ""))
          set_data(t2, t2_value);
        if (dirty & 1 && t4_value !== (t4_value = ctx2[0]["metadata.content.variation"] + ""))
          set_data(t4, t4_value);
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(div2);
      }
    };
  }
  var title = "placeholder title";
  async function fetch_(uri, cb) {
    const ret = await fetch(uri);
    cb(await ret.json());
  }
  function instance79($$self, $$props, $$invalidate) {
    let { pkg = {} } = $$props;
    let attributed = pkg["metadata.teachers"];
    let keywords = pkg["metadata.skills.keywords"];
    async function fetch_pkg_index() {
      let loc = `/api/pkg?name=${pkg["name"]}`;
      await fetch_(loc, (ret) => {
        console.log(ret);
        $$invalidate(0, pkg = ret);
      });
    }
    onMount(() => {
      fetch_pkg_index();
    });
    function package_type() {
      if (pkg["metadata.content.type"] == "course-1") {
        return "small";
      } else if (pkg["metadata.content.type"] == "course-2") {
        return "large";
      }
    }
    $$self.$$set = ($$props2) => {
      if ("pkg" in $$props2)
        $$invalidate(0, pkg = $$props2.pkg);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 1) {
        $:
          console.log("PkgEntry: ", pkg);
      }
    };
    return [pkg, package_type];
  }
  var PkgEntry = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance79, create_fragment81, safe_not_equal, { pkg: 0 });
    }
  };
  var PkgEntry_default = PkgEntry;

  // elos-web/src/PkgIndex.svelte
  function get_each_context10(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[2] = list[i];
    return child_ctx;
  }
  function create_each_block10(ctx) {
    let tr;
    let pkgentry;
    let current;
    pkgentry = new PkgEntry_default({ props: { pkg: ctx[2] } });
    return {
      c() {
        tr = element("tr");
        create_component(pkgentry.$$.fragment);
        attr(tr, "class", "svelte-l8zbvb");
      },
      m(target, anchor) {
        insert(target, tr, anchor);
        mount_component(pkgentry, tr, null);
        current = true;
      },
      p(ctx2, dirty) {
        const pkgentry_changes = {};
        if (dirty & 1)
          pkgentry_changes.pkg = ctx2[2];
        pkgentry.$set(pkgentry_changes);
      },
      i(local) {
        if (current)
          return;
        transition_in(pkgentry.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(pkgentry.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(tr);
        destroy_component(pkgentry);
      }
    };
  }
  function create_fragment82(ctx) {
    let div;
    let hr;
    let t0;
    let h3;
    let t2;
    let table;
    let t3;
    let ul;
    let current;
    let each_value = ctx[0];
    let each_blocks = [];
    for (let i = 0; i < each_value.length; i += 1) {
      each_blocks[i] = create_each_block10(get_each_context10(ctx, each_value, i));
    }
    const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
      each_blocks[i] = null;
    });
    return {
      c() {
        div = element("div");
        hr = element("hr");
        t0 = space();
        h3 = element("h3");
        h3.textContent = "Package Index";
        t2 = space();
        table = element("table");
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        t3 = space();
        ul = element("ul");
        attr(table, "id", "container-pkgs");
        attr(table, "class", "svelte-l8zbvb");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        append(div, hr);
        append(div, t0);
        append(div, h3);
        append(div, t2);
        append(div, table);
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].m(table, null);
        }
        append(table, t3);
        append(table, ul);
        current = true;
      },
      p(ctx2, [dirty]) {
        if (dirty & 1) {
          each_value = ctx2[0];
          let i;
          for (i = 0; i < each_value.length; i += 1) {
            const child_ctx = get_each_context10(ctx2, each_value, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
              transition_in(each_blocks[i], 1);
            } else {
              each_blocks[i] = create_each_block10(child_ctx);
              each_blocks[i].c();
              transition_in(each_blocks[i], 1);
              each_blocks[i].m(table, t3);
            }
          }
          group_outros();
          for (i = each_value.length; i < each_blocks.length; i += 1) {
            out(i);
          }
          check_outros();
        }
      },
      i(local) {
        if (current)
          return;
        for (let i = 0; i < each_value.length; i += 1) {
          transition_in(each_blocks[i]);
        }
        current = true;
      },
      o(local) {
        each_blocks = each_blocks.filter(Boolean);
        for (let i = 0; i < each_blocks.length; i += 1) {
          transition_out(each_blocks[i]);
        }
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(div);
        destroy_each(each_blocks, detaching);
      }
    };
  }
  async function fetch_2(uri, cb) {
    const ret = await fetch(uri);
    let ret_json = await ret.json();
    console.log("[]", ret_json);
    cb(ret_json);
  }
  function instance80($$self, $$props, $$invalidate) {
    let { pkgs = [] } = $$props;
    async function fetch_pkg_index() {
      let loc = `/api/pkg`;
      await fetch_2(loc, (ret) => {
        $$invalidate(0, pkgs = ret);
      });
    }
    onMount(() => {
      console.log("PkgIndex mounted");
      fetch_pkg_index();
    });
    $$self.$$set = ($$props2) => {
      if ("pkgs" in $$props2)
        $$invalidate(0, pkgs = $$props2.pkgs);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 1) {
        $:
          pkgs;
      }
    };
    return [pkgs];
  }
  var PkgIndex = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance80, create_fragment82, safe_not_equal, { pkgs: 0 });
    }
  };
  var PkgIndex_default = PkgIndex;

  // elos-web/src/Wizard.svelte
  function create_fragment83(ctx) {
    let form;
    let itemlist;
    let updating_queue;
    let t0;
    let div1;
    let div0;
    let button0;
    let t2;
    let button1;
    let t4;
    let div2;
    let t7;
    let div3;
    let files;
    let updating_selected_files;
    let t8;
    let div4;
    let editor_1;
    let updating_fileset_selected;
    let t9;
    let div5;
    let p;
    let button2;
    let current;
    let mounted;
    let dispose;
    function itemlist_queue_binding(value) {
      ctx[2](value);
    }
    let itemlist_props = {};
    if (ctx[0] !== void 0) {
      itemlist_props.queue = ctx[0];
    }
    itemlist = new ItemList_default({ props: itemlist_props });
    binding_callbacks.push(() => bind(itemlist, "queue", itemlist_queue_binding));
    itemlist.$on("dequeue", ctx[3]);
    function files_selected_files_binding(value) {
      ctx[6](value);
    }
    let files_props = {};
    if (ctx[0] !== void 0) {
      files_props.selected_files = ctx[0];
    }
    files = new Files_default({ props: files_props });
    binding_callbacks.push(() => bind(files, "selected_files", files_selected_files_binding));
    function editor_1_fileset_selected_binding(value) {
      ctx[7](value);
    }
    let editor_1_props = {};
    if (ctx[0] !== void 0) {
      editor_1_props.fileset_selected = ctx[0];
    }
    editor_1 = new Editor_default({ props: editor_1_props });
    binding_callbacks.push(() => bind(editor_1, "fileset_selected", editor_1_fileset_selected_binding));
    return {
      c() {
        form = element("form");
        create_component(itemlist.$$.fragment);
        t0 = space();
        div1 = element("div");
        div0 = element("div");
        button0 = element("button");
        button0.textContent = "Previous";
        t2 = space();
        button1 = element("button");
        button1.textContent = "Next";
        t4 = space();
        div2 = element("div");
        div2.innerHTML = `<span class="step svelte-om5pol"></span> 
    <span class="step svelte-om5pol"></span> 
    <span class="step svelte-om5pol"></span>`;
        t7 = space();
        div3 = element("div");
        create_component(files.$$.fragment);
        t8 = space();
        div4 = element("div");
        create_component(editor_1.$$.fragment);
        t9 = space();
        div5 = element("div");
        p = element("p");
        button2 = element("button");
        button2.textContent = "1";
        attr(button0, "type", "button");
        attr(button0, "id", "prevBtn");
        attr(button0, "class", "svelte-om5pol");
        attr(button1, "type", "button");
        attr(button1, "id", "nextBtn");
        attr(button1, "class", "svelte-om5pol");
        set_style(div0, "float", "right");
        attr(div0, "class", "svelte-om5pol");
        set_style(div1, "overflow", "auto");
        attr(div1, "class", "svelte-om5pol");
        set_style(div2, "text-align", "center");
        set_style(div2, "margin-top", "40px");
        attr(div2, "class", "svelte-om5pol");
        attr(div3, "class", "tab svelte-om5pol");
        attr(div4, "class", "tab svelte-om5pol");
        attr(button2, "type", "button");
        attr(button2, "id", "");
        attr(button2, "class", "svelte-om5pol");
        attr(p, "class", "svelte-om5pol");
        attr(div5, "class", "tab svelte-om5pol");
        attr(form, "id", "regForm");
        attr(form, "class", "svelte-om5pol");
      },
      m(target, anchor) {
        insert(target, form, anchor);
        mount_component(itemlist, form, null);
        append(form, t0);
        append(form, div1);
        append(div1, div0);
        append(div0, button0);
        append(div0, t2);
        append(div0, button1);
        append(form, t4);
        append(form, div2);
        append(form, t7);
        append(form, div3);
        mount_component(files, div3, null);
        append(form, t8);
        append(form, div4);
        mount_component(editor_1, div4, null);
        append(form, t9);
        append(form, div5);
        append(div5, p);
        append(p, button2);
        current = true;
        if (!mounted) {
          dispose = [
            listen(button0, "click", prevent_default(ctx[4])),
            listen(button1, "click", prevent_default(ctx[5])),
            listen(button2, "click", prevent_default(click_handler_2))
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        const itemlist_changes = {};
        if (!updating_queue && dirty & 1) {
          updating_queue = true;
          itemlist_changes.queue = ctx2[0];
          add_flush_callback(() => updating_queue = false);
        }
        itemlist.$set(itemlist_changes);
        const files_changes = {};
        if (!updating_selected_files && dirty & 1) {
          updating_selected_files = true;
          files_changes.selected_files = ctx2[0];
          add_flush_callback(() => updating_selected_files = false);
        }
        files.$set(files_changes);
        const editor_1_changes = {};
        if (!updating_fileset_selected && dirty & 1) {
          updating_fileset_selected = true;
          editor_1_changes.fileset_selected = ctx2[0];
          add_flush_callback(() => updating_fileset_selected = false);
        }
        editor_1.$set(editor_1_changes);
      },
      i(local) {
        if (current)
          return;
        transition_in(itemlist.$$.fragment, local);
        transition_in(files.$$.fragment, local);
        transition_in(editor_1.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(itemlist.$$.fragment, local);
        transition_out(files.$$.fragment, local);
        transition_out(editor_1.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(form);
        destroy_component(itemlist);
        destroy_component(files);
        destroy_component(editor_1);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  var editor = null;
  function fixStepIndicator(n) {
    var i, x = document.getElementsByClassName("step");
    for (i = 0; i < x.length; i++) {
      x[i].className = x[i].className.replace(" active", "");
    }
    if (x[n] === void 0)
      return;
    x[n].className += " active";
  }
  var click_handler_2 = () => 1;
  function instance81($$self, $$props, $$invalidate) {
    let { selected_files = [] } = $$props;
    let currentTab = 1;
    function showTab(n) {
      var x = document.getElementsByClassName("tab");
      x[n].style.display = "block";
      if (n == 0) {
        document.getElementById("prevBtn").style.display = "none";
      } else {
        document.getElementById("prevBtn").style.display = "inline";
      }
      if (n == x.length - 1) {
        document.getElementById("nextBtn").innerHTML = "Preview";
      } else {
        document.getElementById("nextBtn").innerHTML = "Next";
      }
      fixStepIndicator(n);
      currentTab = n;
    }
    function nextPrev(n) {
      var x = document.getElementsByClassName("tab");
      x[currentTab].style.display = "none";
      currentTab = currentTab + n;
      if (currentTab >= x.length) {
        document.getElementById("regForm").submit();
        return false;
      }
      showTab(currentTab);
    }
    let editor_editor;
    onMount(() => {
      console.log("Wizard mounted");
      showTab(1);
      if (editor_editor != null) {
        console.log(editor_editor);
        editor_editor.layout();
      }
    });
    function itemlist_queue_binding(value) {
      selected_files = value;
      $$invalidate(0, selected_files);
    }
    function dequeue_handler(event) {
      bubble.call(this, $$self, event);
    }
    const click_handler = () => nextPrev(-1);
    const click_handler_1 = () => nextPrev(1);
    function files_selected_files_binding(value) {
      selected_files = value;
      $$invalidate(0, selected_files);
    }
    function editor_1_fileset_selected_binding(value) {
      selected_files = value;
      $$invalidate(0, selected_files);
    }
    $$self.$$set = ($$props2) => {
      if ("selected_files" in $$props2)
        $$invalidate(0, selected_files = $$props2.selected_files);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 1) {
        $:
          selected_files;
      }
    };
    $:
      editor_editor = editor ? editor.editor : null;
    return [
      selected_files,
      nextPrev,
      itemlist_queue_binding,
      dequeue_handler,
      click_handler,
      click_handler_1,
      files_selected_files_binding,
      editor_1_fileset_selected_binding
    ];
  }
  var Wizard = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance81, create_fragment83, safe_not_equal, { selected_files: 0 });
    }
  };
  var Wizard_default = Wizard;

  // elos-web/src/PkgCreate.svelte
  function create_fragment84(ctx) {
    let div;
    let wizard;
    let current;
    wizard = new Wizard_default({});
    return {
      c() {
        div = element("div");
        create_component(wizard.$$.fragment);
        attr(div, "class", "main");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        mount_component(wizard, div, null);
        current = true;
      },
      p: noop,
      i(local) {
        if (current)
          return;
        transition_in(wizard.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(wizard.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(div);
        destroy_component(wizard);
      }
    };
  }
  function instance82($$self) {
    let selected_files;
    onMount(() => {
      console.log("PkgCreate mounted");
    });
    $:
      selected_files;
    return [];
  }
  var PkgCreate = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance82, create_fragment84, safe_not_equal, {});
    }
  };
  var PkgCreate_default = PkgCreate;

  // elos-web/src/components.js
  var components = {
    "options": Options_default,
    "toolbar": Toolbar_default,
    "commandbar": CommandBar_default,
    "timer": Timer_default,
    "clock": Clock_default,
    "profile": Profile_default,
    "todo": Todo_default,
    "rotatelist": RotateList_default,
    "chart": Chart_default,
    "expandlist": ExpandList_default,
    "itemlist": ItemList_default,
    "selectlist": SelectList_default,
    "tracker": Tracker_default,
    "editor": Editor_default,
    "files": Files_default,
    "drop": DropSite_default,
    "actionmenu": ActionMenu_default,
    "spotify_controls": SpotifyControls_default,
    "location_ops": LocationOps_default,
    "web_players": WebPlayers_default,
    "pdf": Pdf_default,
    "datagrid": DataGrid_default,
    "entryform": EntryForm_default,
    "imagegallery": ImageGallery_default,
    "pkgindex": PkgIndex_default,
    "pkgcreate": PkgCreate_default
  };

  // elos-web/src/lib/layout_grid/other.js
  var debounce2 = (fn, ms = 0) => {
    let timeoutId;
    return function(...args) {
      clearTimeout(timeoutId);
      timeoutId = setTimeout(() => fn.apply(this, args), ms);
    };
  };
  function getRowsCount(items) {
    return Math.max(...items.map((val) => val.y + val.h), 1);
  }
  var getColumnFromBreakpoints = (breakpoints, windowWidth, cols) => {
    var found = false, tempCols = cols;
    if (breakpoints) {
      for (var i = breakpoints.length - 1; i >= 0; i--) {
        const [resolution, cols2] = breakpoints[i];
        if (windowWidth <= resolution) {
          found = true;
          tempCols = cols2;
          break;
        }
      }
    }
    if (!found)
      return cols;
    return tempCols;
  };

  // elos-web/src/lib/layout_grid/container.js
  function getContainerHeight(items, yPerPx) {
    return getRowsCount(items) * yPerPx;
  }

  // elos-web/src/lib/layout_grid/matrix.js
  var makeMatrix = (rows2, cols) => Array.from(Array(rows2), () => new Array(cols));
  function makeMatrixFromItems(items, _row = getRowsCount(items), _col) {
    let matrix = makeMatrix(_row, _col);
    for (var i = 0; i < items.length; i++) {
      const value = items[i];
      const { x, y, h } = value;
      const w = Math.min(_col, value.w);
      for (var j = y; j < y + h; j++) {
        const row = matrix[j];
        for (var k = x; k < x + w; k++) {
          row[k] = value;
        }
      }
    }
    return matrix;
  }
  function findCloseBlocks(items, matrix, curObject) {
    const { h, x, y } = curObject;
    const w = Math.min(matrix[0].length, curObject.w);
    const tempR = matrix.slice(y, y + h);
    let result = [];
    for (var i = 0; i < tempR.length; i++) {
      let tempA = tempR[i].slice(x, x + w);
      result = [...result, ...tempA.map((val) => val.id && val.id !== curObject.id && val.id).filter(Boolean)];
    }
    return [...new Set(result)];
  }
  function makeMatrixFromItemsIgnore(items, ignoreList, _row, _col) {
    let matrix = makeMatrix(_row, _col);
    for (var i = 0; i < items.length; i++) {
      const value = items[i];
      const { x, y, h, id } = value;
      const w = Math.min(_col, value.w);
      if (ignoreList.indexOf(id) === -1) {
        for (var j = y; j < y + h; j++) {
          const row = matrix[j];
          if (row) {
            for (var k = x; k < x + w; k++) {
              row[k] = value;
            }
          }
        }
      }
    }
    return matrix;
  }
  function findItemsById(closeBlocks, items) {
    return items.filter((value) => closeBlocks.indexOf(value.id) !== -1);
  }

  // elos-web/src/lib/layout_grid/item.js
  function responsiveItems(items, cols) {
    return items.map((val) => {
      const breakpoint = val.breakpoints[cols];
      if (breakpoint) {
        return { ...val, ...breakpoint };
      }
      return val;
    });
  }
  function getItemById(id, items) {
    const index = items.findIndex((value) => value.id === id);
    return {
      index,
      item: items[index]
    };
  }
  function findFreeSpaceForItem(matrix, item2, items = []) {
    const cols = matrix[0].length;
    const w = Math.min(cols, item2.w);
    let xNtime = cols - w;
    for (var i = 0; i < matrix.length; i++) {
      const row = matrix[i];
      for (var j = 0; j < xNtime + 1; j++) {
        const sliceA = row.slice(j, j + w);
        const empty2 = sliceA.every((val) => val === void 0);
        if (empty2) {
          const isEmpty = matrix.slice(i, i + item2.h).every((a) => a.slice(j, j + w).every((n) => n === void 0));
          if (isEmpty) {
            return { y: i, x: j };
          }
        }
      }
    }
    return {
      y: getRowsCount(items),
      x: 0
    };
  }
  function assignPosition(item2, position, value) {
    return value.id === item2.id ? { ...item2, ...position } : value;
  }
  var replaceItem = (item2, cachedItem, value) => value.id === item2.id ? cachedItem : value;
  function moveItem($item, items, cols, originalItem) {
    let matrix = makeMatrixFromItemsIgnore(items, [$item.id], getRowsCount(items), cols);
    const closeBlocks = findCloseBlocks(items, matrix, $item);
    let closeObj = findItemsById(closeBlocks, items);
    const fixed = closeObj.find((value) => value.fixed);
    if (fixed) {
      if (originalItem) {
        return items.map(replaceItem.bind(null, $item, originalItem));
      }
    }
    matrix = makeMatrixFromItemsIgnore(items, closeBlocks, getRowsCount(items), cols);
    let tempItems = items;
    let tempCloseBlocks = closeBlocks;
    let exclude = [];
    closeObj.forEach((item2) => {
      let position = findFreeSpaceForItem(matrix, item2, tempItems);
      exclude.push(item2.id);
      if (position) {
        tempItems = tempItems.map(assignPosition.bind(null, item2, position));
        let getIgnoreItems = tempCloseBlocks.filter((value) => exclude.indexOf(value) === -1);
        matrix = makeMatrixFromItemsIgnore(tempItems, getIgnoreItems, getRowsCount(tempItems), cols);
      }
    });
    return tempItems;
  }
  function normalize(items, col) {
    let result = items.slice();
    result.forEach((value) => {
      if (!value.static) {
        result = moveItem(value, result, col, { ...value });
      }
    });
    return result;
  }
  function adjust(items, col) {
    let matrix = makeMatrix(getRowsCount(items), col);
    let res = [];
    items.forEach((item2) => {
      let position = findFreeSpaceForItem(matrix, item2, items);
      res.push({ ...item2, ...position });
      matrix = makeMatrixFromItems(res, getRowsCount(res), col);
    });
    return res;
  }

  // elos-web/src/LayoutGridMoveResize.svelte
  function create_if_block_16(ctx) {
    let div;
    let mounted;
    let dispose;
    return {
      c() {
        div = element("div");
        attr(div, "class", "svlt-grid-resizer svelte-dwiwbn");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        if (!mounted) {
          dispose = listen(div, "pointerdown", ctx[14]);
          mounted = true;
        }
      },
      p: noop,
      d(detaching) {
        if (detaching)
          detach(div);
        mounted = false;
        dispose();
      }
    };
  }
  function create_if_block63(ctx) {
    let div;
    return {
      c() {
        div = element("div");
        attr(div, "class", "svlt-grid-shadow transition svelte-dwiwbn");
        set_style(div, "width", ctx[10].w * ctx[6] - ctx[8] * 2 + "px");
        set_style(div, "height", ctx[10].h * ctx[7] - ctx[8] * 2 + "px");
        set_style(div, "transform", "translate(" + (ctx[10].x * ctx[6] + ctx[8]) + "px, " + (ctx[10].y * ctx[7] + ctx[8]) + "px)");
      },
      m(target, anchor) {
        insert(target, div, anchor);
      },
      p(ctx2, dirty) {
        if (dirty[0] & 1344) {
          set_style(div, "width", ctx2[10].w * ctx2[6] - ctx2[8] * 2 + "px");
        }
        if (dirty[0] & 1408) {
          set_style(div, "height", ctx2[10].h * ctx2[7] - ctx2[8] * 2 + "px");
        }
        if (dirty[0] & 1472) {
          set_style(div, "transform", "translate(" + (ctx2[10].x * ctx2[6] + ctx2[8]) + "px, " + (ctx2[10].y * ctx2[7] + ctx2[8]) + "px)");
        }
      },
      d(detaching) {
        if (detaching)
          detach(div);
      }
    };
  }
  function create_fragment85(ctx) {
    let div;
    let t0;
    let t1;
    let if_block1_anchor;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[21].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[20], null);
    let if_block0 = ctx[4] && create_if_block_16(ctx);
    let if_block1 = ctx[11] && create_if_block63(ctx);
    return {
      c() {
        div = element("div");
        if (default_slot)
          default_slot.c();
        t0 = space();
        if (if_block0)
          if_block0.c();
        t1 = space();
        if (if_block1)
          if_block1.c();
        if_block1_anchor = empty();
        attr(div, "class", "svlt-grid-item svelte-dwiwbn");
        set_style(div, "overflow", ctx[9].props && ctx[9].props.overflow ? ctx[9].props.overflow : "scroll");
        set_style(div, "width", (ctx[11] ? ctx[12].width : ctx[0]) + "px");
        set_style(div, "height", (ctx[11] ? ctx[12].height : ctx[1]) + "px");
        set_style(div, "transform", "translate(" + (ctx[11] ? ctx[12].left : ctx[2]) + "px, " + (ctx[11] ? ctx[12].top : ctx[3]) + "px)");
        toggle_class(div, "transition", !ctx[11]);
        toggle_class(div, "active", ctx[11]);
        toggle_class(div, "no-user", ctx[11]);
      },
      m(target, anchor) {
        insert(target, div, anchor);
        if (default_slot) {
          default_slot.m(div, null);
        }
        append(div, t0);
        if (if_block0)
          if_block0.m(div, null);
        insert(target, t1, anchor);
        if (if_block1)
          if_block1.m(target, anchor);
        insert(target, if_block1_anchor, anchor);
        current = true;
        if (!mounted) {
          dispose = listen(div, "pointerdown", function() {
            if (is_function(ctx[5] && ctx[13]))
              (ctx[5] && ctx[13]).apply(this, arguments);
          });
          mounted = true;
        }
      },
      p(new_ctx, dirty) {
        ctx = new_ctx;
        if (default_slot) {
          if (default_slot.p && (!current || dirty[0] & 1048576)) {
            update_slot_base(default_slot, default_slot_template, ctx, ctx[20], !current ? get_all_dirty_from_scope(ctx[20]) : get_slot_changes(default_slot_template, ctx[20], dirty, null), null);
          }
        }
        if (ctx[4]) {
          if (if_block0) {
            if_block0.p(ctx, dirty);
          } else {
            if_block0 = create_if_block_16(ctx);
            if_block0.c();
            if_block0.m(div, null);
          }
        } else if (if_block0) {
          if_block0.d(1);
          if_block0 = null;
        }
        if (!current || dirty[0] & 512) {
          set_style(div, "overflow", ctx[9].props && ctx[9].props.overflow ? ctx[9].props.overflow : "scroll");
        }
        if (!current || dirty[0] & 6145) {
          set_style(div, "width", (ctx[11] ? ctx[12].width : ctx[0]) + "px");
        }
        if (!current || dirty[0] & 6146) {
          set_style(div, "height", (ctx[11] ? ctx[12].height : ctx[1]) + "px");
        }
        if (!current || dirty[0] & 6156) {
          set_style(div, "transform", "translate(" + (ctx[11] ? ctx[12].left : ctx[2]) + "px, " + (ctx[11] ? ctx[12].top : ctx[3]) + "px)");
        }
        if (dirty[0] & 2048) {
          toggle_class(div, "transition", !ctx[11]);
        }
        if (dirty[0] & 2048) {
          toggle_class(div, "active", ctx[11]);
        }
        if (dirty[0] & 2048) {
          toggle_class(div, "no-user", ctx[11]);
        }
        if (ctx[11]) {
          if (if_block1) {
            if_block1.p(ctx, dirty);
          } else {
            if_block1 = create_if_block63(ctx);
            if_block1.c();
            if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
          }
        } else if (if_block1) {
          if_block1.d(1);
          if_block1 = null;
        }
      },
      i(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(div);
        if (default_slot)
          default_slot.d(detaching);
        if (if_block0)
          if_block0.d();
        if (detaching)
          detach(t1);
        if (if_block1)
          if_block1.d(detaching);
        if (detaching)
          detach(if_block1_anchor);
        mounted = false;
        dispose();
      }
    };
  }
  function instance83($$self, $$props, $$invalidate) {
    let { $$slots: slots = {}, $$scope } = $$props;
    const dispatch = createEventDispatcher();
    let { width } = $$props;
    let { height } = $$props;
    let { left } = $$props;
    let { top } = $$props;
    let { resizable } = $$props;
    let { draggable } = $$props;
    let { id } = $$props;
    let { xPerPx } = $$props;
    let { yPerPx } = $$props;
    let { gap } = $$props;
    let { item: item2 } = $$props;
    let { dynamic } = $$props;
    let { max } = $$props;
    let { min } = $$props;
    let { cols } = $$props;
    let shadow = {
      x: item2.x,
      y: item2.y,
      w: item2.w,
      h: item2.h
    };
    let active = false;
    let debounce3 = false;
    let initX, initY;
    let xyRef = { x: left, y: top };
    let newXY = { x: 0, y: 0 };
    let clone = { ...item2 };
    let cloneBound = { width, height, top, left };
    const inActivate = () => $$invalidate(11, active = false);
    let repaint = (listen2 = true) => {
      const onUpdate = !listen2 ? false : inActivate;
      dispatch("repaint", { id, shadow, clone, onUpdate });
    };
    beforeUpdate(() => {
      if (xPerPx && !debounce3) {
        xyRef = { x: left, y: top };
        $$invalidate(10, shadow = {
          x: item2.x,
          y: item2.y,
          w: item2.w,
          h: item2.h
        });
        debounce3 = true;
      }
    });
    const pointerdown = ({ pageX, pageY, clientX, clientY }) => {
      initX = pageX;
      initY = pageY;
      clone = { ...item2 };
      $$invalidate(12, cloneBound = { width, height, top, left });
      debounce3 = false;
      $$invalidate(11, active = true);
      window.addEventListener("pointermove", pointermove);
      window.addEventListener("pointerup", pointerup);
      window.addEventListener("pointercancel", pointerup);
    };
    const pointermove = ({ pageX, pageY, clientX, clientY }) => {
      newXY = { x: initX - pageX, y: initY - pageY };
      $$invalidate(12, cloneBound.left = xyRef.x - newXY.x, cloneBound);
      $$invalidate(12, cloneBound.top = xyRef.y - newXY.y, cloneBound);
      let gridX = Math.round(cloneBound.left / xPerPx);
      let gridY = Math.round(cloneBound.top / yPerPx);
      $$invalidate(10, shadow.x = Math.max(Math.min(gridX, cols - shadow.w), 0), shadow);
      $$invalidate(10, shadow.y = Math.max(gridY, 0), shadow);
      if (dynamic)
        repaint(false);
    };
    const pointerup = (e) => {
      xyRef.x -= newXY.x;
      xyRef.y -= newXY.y;
      window.removeEventListener("pointerdown", pointerdown);
      window.removeEventListener("pointermove", pointermove);
      window.removeEventListener("pointerup", pointerup);
      window.removeEventListener("pointercancel", pointerup);
      repaint();
    };
    let resizeInitX, resizeInitY;
    let initialWidth = 0;
    let initialHeight = 0;
    const resizePointerDown = (e) => {
      e.stopPropagation();
      const { pageX, pageY } = e;
      resizeInitX = pageX;
      resizeInitY = pageY;
      initialWidth = width;
      initialHeight = height;
      clone = { ...item2 };
      $$invalidate(12, cloneBound = { width, height, top, left });
      $$invalidate(11, active = true);
      const { x, y, w, h } = item2;
      $$invalidate(10, shadow = { x, y, w, h });
      window.addEventListener("pointermove", resizePointerMove);
      window.addEventListener("pointerup", resizePointerUp);
      window.addEventListener("pointercancel", resizePointerUp);
    };
    const resizePointerMove = ({ pageX, pageY }) => {
      $$invalidate(12, cloneBound.width = initialWidth + pageX - resizeInitX, cloneBound);
      $$invalidate(12, cloneBound.height = initialHeight + pageY - resizeInitY, cloneBound);
      $$invalidate(10, shadow.w = Math.round(cloneBound.width / xPerPx), shadow);
      $$invalidate(10, shadow.h = Math.round(cloneBound.height / yPerPx), shadow);
      let maxWidth = Math.min(max.w, cols) || cols;
      $$invalidate(10, shadow.w = Math.max(Math.min(maxWidth, shadow.w), min.w), shadow);
      $$invalidate(10, shadow.h = Math.max(shadow.h, min.h), shadow);
      if (max.h) {
        $$invalidate(10, shadow.h = Math.min(max.h, shadow.h), shadow);
      }
    };
    const resizePointerUp = (e) => {
      e.stopPropagation();
      repaint();
      window.removeEventListener("pointermove", resizePointerMove);
      window.removeEventListener("pointerup", resizePointerUp);
      window.removeEventListener("pointercancel", resizePointerUp);
    };
    $$self.$$set = ($$props2) => {
      if ("width" in $$props2)
        $$invalidate(0, width = $$props2.width);
      if ("height" in $$props2)
        $$invalidate(1, height = $$props2.height);
      if ("left" in $$props2)
        $$invalidate(2, left = $$props2.left);
      if ("top" in $$props2)
        $$invalidate(3, top = $$props2.top);
      if ("resizable" in $$props2)
        $$invalidate(4, resizable = $$props2.resizable);
      if ("draggable" in $$props2)
        $$invalidate(5, draggable = $$props2.draggable);
      if ("id" in $$props2)
        $$invalidate(15, id = $$props2.id);
      if ("xPerPx" in $$props2)
        $$invalidate(6, xPerPx = $$props2.xPerPx);
      if ("yPerPx" in $$props2)
        $$invalidate(7, yPerPx = $$props2.yPerPx);
      if ("gap" in $$props2)
        $$invalidate(8, gap = $$props2.gap);
      if ("item" in $$props2)
        $$invalidate(9, item2 = $$props2.item);
      if ("dynamic" in $$props2)
        $$invalidate(16, dynamic = $$props2.dynamic);
      if ("max" in $$props2)
        $$invalidate(17, max = $$props2.max);
      if ("min" in $$props2)
        $$invalidate(18, min = $$props2.min);
      if ("cols" in $$props2)
        $$invalidate(19, cols = $$props2.cols);
      if ("$$scope" in $$props2)
        $$invalidate(20, $$scope = $$props2.$$scope);
    };
    return [
      width,
      height,
      left,
      top,
      resizable,
      draggable,
      xPerPx,
      yPerPx,
      gap,
      item2,
      shadow,
      active,
      cloneBound,
      pointerdown,
      resizePointerDown,
      id,
      dynamic,
      max,
      min,
      cols,
      $$scope,
      slots
    ];
  }
  var LayoutGridMoveResize = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance83, create_fragment85, safe_not_equal, {
        width: 0,
        height: 1,
        left: 2,
        top: 3,
        resizable: 4,
        draggable: 5,
        id: 15,
        xPerPx: 6,
        yPerPx: 7,
        gap: 8,
        item: 9,
        dynamic: 16,
        max: 17,
        min: 18,
        cols: 19
      }, null, [-1, -1]);
    }
  };
  var LayoutGridMoveResize_default = LayoutGridMoveResize;

  // elos-web/src/LayoutGrid.svelte
  function get_each_context11(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[24] = list[i];
    child_ctx[26] = i;
    return child_ctx;
  }
  var get_default_slot_changes = (dirty) => ({
    item: dirty & 1,
    index: dirty & 1
  });
  var get_default_slot_context = (ctx) => ({
    item: ctx[24],
    index: ctx[26]
  });
  function create_default_slot(ctx) {
    let options;
    let t0;
    let t1;
    let current;
    options = new Options_default({
      props: {
        id: "opt_" + ctx[24].target,
        panelOpts: ctx[24].props
      }
    });
    const default_slot_template = ctx[17].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[19], get_default_slot_context);
    return {
      c() {
        create_component(options.$$.fragment);
        t0 = space();
        if (default_slot)
          default_slot.c();
        t1 = space();
      },
      m(target, anchor) {
        mount_component(options, target, anchor);
        insert(target, t0, anchor);
        if (default_slot) {
          default_slot.m(target, anchor);
        }
        insert(target, t1, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        const options_changes = {};
        if (dirty & 1)
          options_changes.id = "opt_" + ctx2[24].target;
        if (dirty & 1)
          options_changes.panelOpts = ctx2[24].props;
        options.$set(options_changes);
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 524289)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[19], !current ? get_all_dirty_from_scope(ctx2[19]) : get_slot_changes(default_slot_template, ctx2[19], dirty, get_default_slot_changes), get_default_slot_context);
          }
        }
      },
      i(local) {
        if (current)
          return;
        transition_in(options.$$.fragment, local);
        transition_in(default_slot, local);
        current = true;
      },
      o(local) {
        transition_out(options.$$.fragment, local);
        transition_out(default_slot, local);
        current = false;
      },
      d(detaching) {
        destroy_component(options, detaching);
        if (detaching)
          detach(t0);
        if (default_slot)
          default_slot.d(detaching);
        if (detaching)
          detach(t1);
      }
    };
  }
  function create_each_block11(key_1, ctx) {
    let first;
    let moveresize;
    let current;
    moveresize = new LayoutGridMoveResize_default({
      props: {
        id: ctx[24].id,
        resizable: ctx[24].resizable,
        draggable: ctx[24].draggable,
        xPerPx: ctx[6],
        yPerPx: ctx[8],
        width: Math.min(ctx[4], ctx[24].w) * ctx[6] - ctx[1] * 2,
        height: ctx[24].h * ctx[8] - ctx[1] * 2,
        top: ctx[24].y * ctx[8] + ctx[1],
        left: ctx[24].x * ctx[6] + ctx[1],
        gap: ctx[1],
        item: ctx[24],
        min: ctx[24].min,
        max: ctx[24].max,
        dynamic: ctx[2],
        cols: ctx[4],
        $$slots: { default: [create_default_slot] },
        $$scope: { ctx }
      }
    });
    moveresize.$on("load", ctx[3]);
    moveresize.$on("repaint", ctx[3]);
    return {
      key: key_1,
      first: null,
      c() {
        first = empty();
        create_component(moveresize.$$.fragment);
        this.first = first;
      },
      m(target, anchor) {
        insert(target, first, anchor);
        mount_component(moveresize, target, anchor);
        current = true;
      },
      p(new_ctx, dirty) {
        ctx = new_ctx;
        const moveresize_changes = {};
        if (dirty & 1)
          moveresize_changes.id = ctx[24].id;
        if (dirty & 1)
          moveresize_changes.resizable = ctx[24].resizable;
        if (dirty & 1)
          moveresize_changes.draggable = ctx[24].draggable;
        if (dirty & 64)
          moveresize_changes.xPerPx = ctx[6];
        if (dirty & 83)
          moveresize_changes.width = Math.min(ctx[4], ctx[24].w) * ctx[6] - ctx[1] * 2;
        if (dirty & 3)
          moveresize_changes.height = ctx[24].h * ctx[8] - ctx[1] * 2;
        if (dirty & 3)
          moveresize_changes.top = ctx[24].y * ctx[8] + ctx[1];
        if (dirty & 67)
          moveresize_changes.left = ctx[24].x * ctx[6] + ctx[1];
        if (dirty & 2)
          moveresize_changes.gap = ctx[1];
        if (dirty & 1)
          moveresize_changes.item = ctx[24];
        if (dirty & 1)
          moveresize_changes.min = ctx[24].min;
        if (dirty & 1)
          moveresize_changes.max = ctx[24].max;
        if (dirty & 4)
          moveresize_changes.dynamic = ctx[2];
        if (dirty & 16)
          moveresize_changes.cols = ctx[4];
        if (dirty & 524289) {
          moveresize_changes.$$scope = { dirty, ctx };
        }
        moveresize.$set(moveresize_changes);
      },
      i(local) {
        if (current)
          return;
        transition_in(moveresize.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(moveresize.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(first);
        destroy_component(moveresize, detaching);
      }
    };
  }
  function create_fragment86(ctx) {
    let div;
    let each_blocks = [];
    let each_1_lookup = new Map();
    let current;
    let each_value = ctx[0];
    const get_key = (ctx2) => ctx2[24].id;
    for (let i = 0; i < each_value.length; i += 1) {
      let child_ctx = get_each_context11(ctx, each_value, i);
      let key = get_key(child_ctx);
      each_1_lookup.set(key, each_blocks[i] = create_each_block11(key, child_ctx));
    }
    return {
      c() {
        div = element("div");
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        attr(div, "class", "svlt-grid-container svelte-p0xk9p");
        set_style(div, "height", ctx[7] + "px");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].m(div, null);
        }
        ctx[18](div);
        current = true;
      },
      p(ctx2, [dirty]) {
        if (dirty & 524639) {
          each_value = ctx2[0];
          group_outros();
          each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block11, null, get_each_context11);
          check_outros();
        }
        if (!current || dirty & 128) {
          set_style(div, "height", ctx2[7] + "px");
        }
      },
      i(local) {
        if (current)
          return;
        for (let i = 0; i < each_value.length; i += 1) {
          transition_in(each_blocks[i]);
        }
        current = true;
      },
      o(local) {
        for (let i = 0; i < each_blocks.length; i += 1) {
          transition_out(each_blocks[i]);
        }
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(div);
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].d();
        }
        ctx[18](null);
      }
    };
  }
  function instance84($$self, $$props, $$invalidate) {
    let containerHeight;
    let { $$slots: slots = {}, $$scope } = $$props;
    const dispatch = createEventDispatcher();
    let { items } = $$props;
    let { rowHeight } = $$props;
    let { cols } = $$props;
    let { gap = 10 } = $$props;
    let { breakpoints = [] } = $$props;
    let { dynamicCols = true } = $$props;
    let { debounceUpdate = 100 } = $$props;
    let { debounceResize = 100 } = $$props;
    let { dynamic = false } = $$props;
    let getComputedCols;
    let container;
    let xPerPx = 0;
    let yPerPx = rowHeight;
    let documentWidth;
    let containerWidth;
    let prevCols;
    const onResize = debounce2(() => {
      if (breakpoints.length) {
        $$invalidate(0, items = responsiveItems(items, getComputedCols));
      }
      dispatch("resize", {
        cols: getComputedCols,
        xPerPx,
        yPerPx,
        width: containerWidth
      });
    }, debounceResize);
    onMount(() => {
      const sizeObserver = new ResizeObserver((entries) => {
        let width = entries[0].contentRect.width;
        if (width === containerWidth)
          return;
        $$invalidate(4, getComputedCols = getColumnFromBreakpoints(breakpoints, width, cols));
        $$invalidate(6, xPerPx = width / getComputedCols);
        if (!containerWidth) {
          if (breakpoints.length) {
            $$invalidate(0, items = responsiveItems(items, getComputedCols));
          }
          dispatch("mount", { cols: getComputedCols, xPerPx, yPerPx });
        } else {
          onResize();
        }
        $$invalidate(15, containerWidth = width);
      });
      sizeObserver.observe(container);
      return () => sizeObserver.disconnect();
    });
    const updateMatrix = ({ detail }) => {
      let activeItem = getItemById(detail.id, items).item;
      if (activeItem) {
        activeItem = Object.assign(activeItem, detail.shadow);
        $$invalidate(0, items = moveItem(activeItem, items, getComputedCols, detail.clone));
        console.log("updateMatrix", detail);
        if (detail.onUpdate)
          detail.onUpdate();
        dispatch("change", {
          unsafeItem: activeItem,
          id: activeItem.id
        });
      }
    };
    const handleRepaint = debounce2(updateMatrix, debounceUpdate);
    function div_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        container = $$value;
        $$invalidate(5, container);
      });
    }
    $$self.$$set = ($$props2) => {
      if ("items" in $$props2)
        $$invalidate(0, items = $$props2.items);
      if ("rowHeight" in $$props2)
        $$invalidate(9, rowHeight = $$props2.rowHeight);
      if ("cols" in $$props2)
        $$invalidate(10, cols = $$props2.cols);
      if ("gap" in $$props2)
        $$invalidate(1, gap = $$props2.gap);
      if ("breakpoints" in $$props2)
        $$invalidate(11, breakpoints = $$props2.breakpoints);
      if ("dynamicCols" in $$props2)
        $$invalidate(12, dynamicCols = $$props2.dynamicCols);
      if ("debounceUpdate" in $$props2)
        $$invalidate(13, debounceUpdate = $$props2.debounceUpdate);
      if ("debounceResize" in $$props2)
        $$invalidate(14, debounceResize = $$props2.debounceResize);
      if ("dynamic" in $$props2)
        $$invalidate(2, dynamic = $$props2.dynamic);
      if ("$$scope" in $$props2)
        $$invalidate(19, $$scope = $$props2.$$scope);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 1) {
        $:
          $$invalidate(7, containerHeight = getContainerHeight(items, yPerPx));
      }
      if ($$self.$$.dirty & 103424) {
        $: {
          if (prevCols !== cols && dynamicCols) {
            $$invalidate(6, xPerPx = containerWidth / cols);
          }
          $$invalidate(16, prevCols = cols);
        }
      }
    };
    return [
      items,
      gap,
      dynamic,
      handleRepaint,
      getComputedCols,
      container,
      xPerPx,
      containerHeight,
      yPerPx,
      rowHeight,
      cols,
      breakpoints,
      dynamicCols,
      debounceUpdate,
      debounceResize,
      containerWidth,
      prevCols,
      slots,
      div_binding,
      $$scope
    ];
  }
  var LayoutGrid = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance84, create_fragment86, safe_not_equal, {
        items: 0,
        rowHeight: 9,
        cols: 10,
        gap: 1,
        breakpoints: 11,
        dynamicCols: 12,
        debounceUpdate: 13,
        debounceResize: 14,
        dynamic: 2,
        handleRepaint: 3
      });
    }
    get handleRepaint() {
      return this.$$.ctx[3];
    }
  };
  var LayoutGrid_default = LayoutGrid;

  // elos-web/src/lib/layout_grid/helper.js
  function makeItem(item2) {
    const { min = { w: 1, h: 1 }, max } = item2;
    return {
      fixed: false,
      resizable: !item2.fixed,
      draggable: !item2.fixed,
      min: {
        w: Math.max(1, min.w),
        h: Math.max(1, min.h)
      },
      max: { ...max },
      ...item2
    };
  }
  var gridHelp = {
    normalize(items, col, rows2) {
      return normalize(items, col, rows2);
    },
    adjust(items, col) {
      return adjust(items, col);
    },
    item(obj) {
      return makeItem(obj);
    },
    findSpace(item2, items, cols) {
      let matrix = makeMatrixFromItems(items, getRowsCount(items), cols);
      let position = findFreeSpaceForItem(matrix, item2, items);
      return position;
    }
  };
  var helper_default = gridHelp;

  // elos-web/src/App.svelte
  function create_default_slot2(ctx) {
    let div;
    let span;
    let t0_value = ctx[13].target.replace("panel-", "").replace("-", " ") + "";
    let t0;
    let t1;
    let hr;
    let t2;
    let switch_instance;
    let item2 = ctx[13];
    let current;
    const switch_instance_spread_levels = [
      { id: ctx[13].target },
      { data: ctx[13] },
      ctx[13].props,
      { index: ctx[14] }
    ];
    const assign_switch_instance = () => ctx[3](switch_instance, item2);
    const unassign_switch_instance = () => ctx[3](null, item2);
    var switch_value = components[ctx[13].componentName];
    function switch_props(ctx2) {
      let switch_instance_props = {};
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
      return { props: switch_instance_props };
    }
    if (switch_value) {
      switch_instance = new switch_value(switch_props(ctx));
      assign_switch_instance();
      switch_instance.$on("didMount", ctx[2]);
    }
    return {
      c() {
        div = element("div");
        span = element("span");
        t0 = text(t0_value);
        t1 = space();
        hr = element("hr");
        t2 = space();
        if (switch_instance)
          create_component(switch_instance.$$.fragment);
        attr(div, "class", "svelte-18z0dj1");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        append(div, span);
        append(span, t0);
        append(span, t1);
        append(span, hr);
        append(div, t2);
        if (switch_instance) {
          mount_component(switch_instance, div, null);
        }
        current = true;
      },
      p(ctx2, dirty) {
        if ((!current || dirty & 8192) && t0_value !== (t0_value = ctx2[13].target.replace("panel-", "").replace("-", " ") + ""))
          set_data(t0, t0_value);
        if (item2 !== ctx2[13]) {
          unassign_switch_instance();
          item2 = ctx2[13];
          assign_switch_instance();
        }
        const switch_instance_changes = dirty & 24576 ? get_spread_update(switch_instance_spread_levels, [
          dirty & 8192 && { id: ctx2[13].target },
          dirty & 8192 && { data: ctx2[13] },
          dirty & 8192 && get_spread_object(ctx2[13].props),
          dirty & 16384 && { index: ctx2[14] }
        ]) : {};
        if (switch_value !== (switch_value = components[ctx2[13].componentName])) {
          if (switch_instance) {
            group_outros();
            const old_component = switch_instance;
            transition_out(old_component.$$.fragment, 1, 0, () => {
              destroy_component(old_component, 1);
            });
            check_outros();
          }
          if (switch_value) {
            switch_instance = new switch_value(switch_props(ctx2));
            assign_switch_instance();
            switch_instance.$on("didMount", ctx2[2]);
            create_component(switch_instance.$$.fragment);
            transition_in(switch_instance.$$.fragment, 1);
            mount_component(switch_instance, div, null);
          } else {
            switch_instance = null;
          }
        } else if (switch_value) {
          switch_instance.$set(switch_instance_changes);
        }
      },
      i(local) {
        if (current)
          return;
        if (switch_instance)
          transition_in(switch_instance.$$.fragment, local);
        current = true;
      },
      o(local) {
        if (switch_instance)
          transition_out(switch_instance.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(div);
        unassign_switch_instance();
        if (switch_instance)
          destroy_component(switch_instance);
      }
    };
  }
  function create_fragment87(ctx) {
    let main;
    let section;
    let layoutgrid;
    let updating_items;
    let current;
    function layoutgrid_items_binding(value) {
      ctx[4](value);
    }
    let layoutgrid_props = {
      cols: layoutConfig.columnCount,
      gap: layoutConfig.panelGap,
      rowHeight: layoutConfig.rowHeight,
      $$slots: {
        default: [
          create_default_slot2,
          ({ item: item2, index }) => ({ 13: item2, 14: index }),
          ({ item: item2, index }) => (item2 ? 8192 : 0) | (index ? 16384 : 0)
        ]
      },
      $$scope: { ctx }
    };
    if (ctx[0] !== void 0) {
      layoutgrid_props.items = ctx[0];
    }
    layoutgrid = new LayoutGrid_default({ props: layoutgrid_props });
    binding_callbacks.push(() => bind(layoutgrid, "items", layoutgrid_items_binding));
    return {
      c() {
        main = element("main");
        section = element("section");
        create_component(layoutgrid.$$.fragment);
        attr(section, "class", "svelte-18z0dj1");
        attr(main, "class", "svelte-18z0dj1");
      },
      m(target, anchor) {
        insert(target, main, anchor);
        append(main, section);
        mount_component(layoutgrid, section, null);
        current = true;
      },
      p(ctx2, [dirty]) {
        const layoutgrid_changes = {};
        if (dirty & 57346) {
          layoutgrid_changes.$$scope = { dirty, ctx: ctx2 };
        }
        if (!updating_items && dirty & 1) {
          updating_items = true;
          layoutgrid_changes.items = ctx2[0];
          add_flush_callback(() => updating_items = false);
        }
        layoutgrid.$set(layoutgrid_changes);
      },
      i(local) {
        if (current)
          return;
        transition_in(layoutgrid.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(layoutgrid.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(main);
        destroy_component(layoutgrid);
      }
    };
  }
  function instance85($$self, $$props, $$invalidate) {
    console.log("PANEL TYPES", panelTypes);
    const genId = () => "_" + Math.random().toString(36).substr(2, 9);
    let items = [];
    let objects2 = {};
    function hydrateParams(item2) {
      if (!components.hasOwnProperty(item2.componentName)) {
        console.log("MISSING COMPONENT", item2.componentName);
      }
      if (item2.props !== void 0 && item2.props.dataStore !== void 0 && item2.props.dataStore) {
        item2.props.dataStore = stores[item2.props.dataStore];
        if (item2.target in objects2 && objects2[item2.target]) {
          objects2[item2.target].$set("dataStore", item2.props.dataStore);
        }
      }
      if (item2.event !== void 0) {
        switch (item2.event.callback) {
          case "updateFiletype":
            item2.event.callback = updateFiletype;
            break;
          case "togglePanel":
            item2.event.callback = togglePanel;
            break;
          case "openFile":
            item2.event.callback = openFile;
            break;
        }
        if (item2 && item2.target && item2.target in objects2 && objects2[item2.target] !== null) {
          objects2[item2.target].$on(item2.event.name, item2.event.callback);
        }
      }
      return item2;
    }
    function positionItem(item2) {
      return {
        ...item2,
        ...helper_default.findSpace(item2, items, layoutConfig.columnCount)
      };
    }
    function _newItem(options = {}) {
      return positionItem(helper_default.item({
        w: layoutConfig.columnCount,
        h: 7,
        id: genId(),
        ...hydrateParams(options)
      }));
    }
    function add2(panelTarget, options = {}) {
      if (!panelTypes.hasOwnProperty(panelTarget)) {
        console.log("MISSING PANEL", panelTarget);
      }
      options = { ...panelTypes[panelTarget], ...options };
      let rootItem = _newItem(options);
      $$invalidate(0, items = [...items, rootItem]);
      console.log("ADDING", panelTarget, rootItem);
      return true;
    }
    const onAdd = (val) => {
      console.log("did onAdd", val);
      let item2 = val.detail;
      if (item2 && item2.event && item2.target in objects2) {
        objects2[item2.target].$on(item2.event.name, item2.event.callback);
      }
    };
    const remove = (item2) => {
      $$invalidate(0, items = items.filter((value) => value.target !== item2));
      if (items.length > 0) {
        delete objects2[item2];
      }
    };
    function togglePanel(e) {
      _togglePanel(e.detail.name);
    }
    function _togglePanel(itemName) {
      let _layout = items.filter((value) => value.target === itemName);
      if (_layout.length > 0)
        remove(itemName);
      else
        add2(itemName);
    }
    onMount(async () => {
      console.log("App mounted");
      add2("panel-mainmenu");
      add2("panel-timer");
      add2("panel-actionmenu");
      add2("panel-web-players");
    });
    function switch_instance_binding($$value, item2) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        objects2[item2.target] = $$value;
        $$invalidate(1, objects2);
      });
    }
    function layoutgrid_items_binding(value) {
      items = value;
      $$invalidate(0, items);
    }
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 1) {
        $:
          items;
      }
    };
    return [items, objects2, onAdd, switch_instance_binding, layoutgrid_items_binding];
  }
  var App = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance85, create_fragment87, safe_not_equal, {});
    }
  };
  var App_default = App;

  // elos-web/src/main.js
  var app = new App_default({
    target: document.body,
    props: {}
  });
  window.app = app;
  var main_default = app;
})();
/*!
 * Chart.js v2.9.4
 * https://www.chartjs.org
 * (c) 2020 Chart.js Contributors
 * Released under the MIT License
 */
/*! @license DOMPurify 2.3.1 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.3.1/LICENSE */
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! moment.js
//! momentjs.com
//! version : 2.29.1
